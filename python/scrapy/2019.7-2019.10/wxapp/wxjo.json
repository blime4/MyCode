{"title": "5个套路看懂微信小程序开发 ", "author": "Rolan", "pub_time": "2019-6-21 00:17", "content": "你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信小程序的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。在开始之前，先做100字的铺垫。一个页面 = 4个文件小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：js 文件——数据来源；wxml 文件——页面的骨架；wxss 文件——页面的装饰效果；json 文件——可选，配置页面上的零件。另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。部分语言过于通俗是为了更好的理解。绑定数据现在就开始我们的第一个套路。小程序简易教程 -> 编写代码 -> 创建页面 -> 第二个代码块依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js 文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 data），就是页面上需要用到的数据。这就叫做数据绑定。「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。声明的格式是这样的（类似上图中的内容）：Page({data: {greeting: 'Hello World'}//...})在微信开发工具中是这样的：注意看红框中的内容，和上面的代码块是一样的注意看 data 那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：{{greeting}}注意看{{ }}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。这就完成了我们的第一个套路——数据绑定。简单吧！但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？答案是我们的页面上，也就是 wxml 这个文件中。这就是我们的下一个套路——显示数据。显示数据上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：<text class=\"your-class\">{{greeting}}</text>在微信开发工具中的样子是这样的：还是看红框内的内容，也请注意这是在 wxml 文件中我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：最左边红框中的文字一点装饰效果都没有为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：标签样式表什么是标签，我们从例子中来理解：{{greeting}}两边的<text class=\"your-class\">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class=\"your-class\"就是<text>这个标签的一个属性，<text>标签会表现出class=\"your-class\"的规定的样子。那么class=\"your-class\"这个属性的完整意思是什么呢？他的意思是<text>的 class 对应样式表中的your-class。对，你可以把等号理解为对应。而后面的\"your-class\"就是我们在样式表中规定好的一种装饰效果。这里出现了我们的第2个工具：样式表。样式表是写在 wxss 文件中的，我们来看看怎么写：.your-class {display: flex;flex-direction: column;align-items: center;color: blue;}在开发者工具中的样子是这样的：你通过理解代码中英文的字面意思就可以了解到，我把字的 color 定义为蓝色，把位置定义为 center。最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class 属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 class 属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)到这里，我们的前两个套路就已经简单的介绍完了。总结一下：绑定数据：在 js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。显示数据：在 wxml 中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss 文件中写好。不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css 大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：Page({data: {greeting: 'Hello World',farewell: 'Goodbye!'}//其他内容})而对应显示这两个数据的示例代码是这样的：<!--index.wxml--><text class=\"your-class\">{{greeting}}</text><view class=\"your-class\">{{farewell}}</view>在开发者工具中显示的样子是这样的：我在写教程的过程中升级了一次开发者工具，所以界面有变化大家可以看到，我在最右侧的红箭头处加入了一行新代码， 然后显示出了新数据。但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml 文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。绑定交互绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。绑定交互分为两步：声明：在 js 文件中声明交互的名称。使用：在 wxml 文件中使用这个交互。先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）请在 js 文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}在开发者工具中的样子是：这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say Goodbye!。而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 wxml 中插入这样的代码片段：<button bindtap=\"changeWord\" type='primary' class=\"your-button\" size='default'>改变文字</button>在开发者工具中的的样子是这样的：这里的重点是bindtap=\"changeWord\"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 Never Say Goodbye!除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。你会发现他们的开头都是 bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。执行交互就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：changeWord: function() {// 这里写交互的实际内容}我们这里介绍两种交互内容的写法，足够解决很多问题了：修改页面数据弹窗第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}这几行代码中间的部分，就是要执行的交互内容：this.setData({farewell: 'Never Say Goodbye!'})即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 Never Say Goodbye!。如果你想修改其他数据，比如greeting，你可以如法炮制：changeAnotherWord: function() {this.setData({greeting: 'Hello, again!'})}你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: 'Hello, again!'）。如果你也想修改页面上的数据，请如法炮制。我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。声明交互的代码如下（在 js 文件中），我们用showConfirmation作为名称： showConfirmation: function() {\r\n var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n }\r\n在微信开发者工具中是这样的：先不要在乎这里面陌生的代码，我们继续看使用交互的部分：<button bindtap=\"showConfirmation\" type='primary' class=\"your-button\" size='default'>改变文字</button>我把上一个套路中出现的 button 改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：写完之后，我再去点「改变文字」的按钮，就会出现对话框：箭头连接的两部分是一样的，你发现了吗你会发现，所有的不一样，都只是在 js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码： var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：我们只需要像填空一样，把制作对话框需要的 title, content, showCancel 等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。但在这段代码中，有一个比较难解释的地方，就是var that = this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var that = this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：使用wx.showModal跳转到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。要跳转到下一个页面，我们只需要最后一个套路：跳转。跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。我们先在 js 文件中声明一个名为navigateToLogs的交互：navigateToLogs: function() {wx.navigateTo({url: '/pages/logs/logs'})}在开发者工具中的样子是这样的：这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。在 wxml 中使用这个交互：<button bindtap=\"navigateToLogs\" type='default' class=\"your-button\" size='default'>跳转</button>在开发者工具中的样子是这样的：好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。已经看完了效果，我们回来看那段不熟悉的代码：wx.navigateTo({url: '/pages/logs/logs'})这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs 路径下的页面（url: '/pages/logs/logs'）。其中 url 这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？大家看下图红框中的文件结构，会发现 logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。总结一下好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：绑定数据——在 js 文件中声明数据名称显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果绑定交互——在 js 文件中声明交互的名称执行交互——在 js 文件中支出要修改的数据或者显示弹窗跳转——跳转到下一页，开辟新的战场番外篇——调取微信数据微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。共勉。这种标记叫做选择器，可以在这个小程序 wxss 文档的选择器那一节找到而且是个简版的css，不会用到复杂一点的级联样式另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on 开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml 中绑定到标签。微信还有2个可用弹窗类交互，大家可以对照文档进行实验。微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。"}
{"title": "当微信小程序遇上TensorFlow - 官方文档 ", "author": "Rolan", "pub_time": "2019-7-19 00:32", "content": "前一段时间为了在微信小程序中使用tensorflow.js，对tfjs-core代码做了一些修改，具体情况请参考我之前写的几篇文档：重磅好消息！ TensorFlow开始支持微信小程序当微信小程序遇上TensorFlow - tensorflow.js篇当微信小程序遇上TensorFlow - 本地缓存模型后来，我厚着脸皮向tensorflow/tfjs-core项目提交了一个PR，不出意外，这个提交被拒了。当然谷歌的开发人员还是比较友好，给了我一个文档链接：https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wx6afed118d9e81df9原来google有一份这样的开发指导文档，而且还是中文的，为啥没在tfjs的文档中列出？ 循着这份文档，我还找到了tensorflow项目组的tfjs微信小程序示例：https://github.com/tensorflow/tfjs-wechat/tree/master/demo/mobilenet这个项目说明也是中文的，看来微信小程序虽然红红火火，但真的还是仅限于中文世界。就如同我所预想的，按照这个文档，一定不会那么顺利，实际做下来，也确实印证了这一点，下面就谈谈几个要点：官方是采用微信小程序插件来增加tensorflow js支持的，要在微信小程序中使用tfjs插件， 不能使用测试号 ，需要在小程序管理后台的“设置-第三方服务-插件管理”中添加插件。具体方法为：开发者可登录小程序管理后台，通过 appid [wx6afed118d9e81df9] 查找插件并添加。本插件无需申请，添加后可直接使用。直接导入github.com/tensorflow/tfjs-wechat/tree/master/demo/mobilenet中的代码，到了 点击微信开发工具中的‘构建npm’菜单 这一步，总是提示：没有找到可以构建的 npm 包尝试了很多次，也上网寻求帮助，始终无法解决。后来还是决定自己新建一个项目，然后在项目根目录执行：$ npm init在后续的提示里，一直按回车键，使用默认值：This utility will walk you through creating a package.json file.\r\nIt only covers the most common items, and tries to guess sensible defaults.\r\n\r\nSee `npm help json` for definitive documentation on these fields\r\nand exactly what they do.\r\n\r\nUse `npm install <pkg>` afterwards to install a package and\r\nsave it as a dependency in the package.json file.\r\n\r\nPress ^C at any time to quit.\r\npackage name: (wechat-tfjs-examples)\r\nversion: (1.0.0)\r\ndescription:\r\nentry point: (app.js)\r\ntest command:\r\ngit repository: (https://github.com/mogoweb/wechat-tfjs-examples)\r\nkeywords:\r\nauthor:\r\nlicense: (ISC)\r\nAbout to write to D:\\work\\ai\\wechat-tfjs-examples\\package.json:\r\n\r\n{\r\n  \"name\": \"wechat-tfjs-examples\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"微信小程序中使用TensorFlow js的示例代码，pages下面每个目录一个示例。\",\r\n  \"main\": \"app.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+https://github.com/mogoweb/wechat-tfjs-examples.git\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/mogoweb/wechat-tfjs-examples/issues\"\r\n  },\r\n  \"homepage\": \"https://github.com/mogoweb/wechat-tfjs-examples#readme\"\r\n}\r\n\r\nIs this OK? (yes)在项目下多了package.json文件，往该文件中添加：\"devDependencies\": {\r\n    \"miniprogram-api-typings\": \"^2.6.5-2\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@tensorflow/tfjs-core\": \"1.2.2\",\r\n    \"@tensorflow/tfjs-converter\": \"1.2.2\",\r\n    \"@tensorflow/tfjs-layers\": \"1.2.2\",\r\n    \"fetch-wechat\": \"0.0.3\"\r\n  }接着执行：$ npm install再点击开发工具中的 构建npm ，就可以继续下去。这时可能会弹出提示：未找到npm包入口文件忽略之。3. TensorFlow.js有一个联合包 - @tensorflow/tfjs，包含了四个分npm包：tfjs-core: 基础包\r\ntfjs-converter: GraphModel 导入和执行包\r\ntfjs-layers: LayersModel 创建，导入和执行包\r\ntfjs-data：数据流工具包 对于小程序而言，由于有2M的app大小限制，不建议直接使用联合包，而是按照需求加载分包。\r\n如果小程序只需要导入和运行GraphModel模型的的话，建议只加入tfjs-core和tfjs-converter包。这样可以尽量减少导入包的大小。如果需要创建,导入或训练LayersModel模型，需要再加入 tfjs-layers包。在我的示例代码中，使用到tfjs-core和tfjs-layers包，导入代码如下：import * as tf from '@tensorflow/tfjs-layers';\r\nimport * as tfc from '@tensorflow/tfjs-core';小结使用tensorflow的官方方法，可以跟上tfjs的最新进展，可以在第一时间上使用最新特性，推荐使用这种方法。但我之前的尝试也不是毫无价值，tfjs官方没有增加对模型本地缓存的支持，每次都需要从网络加载模型，当然不排除以后tfjs官方也会添加这样的特性。我把调试好的tensorflow示例放在github上，请访问：https://github.com/mogoweb/wechat-tfjs-examples然后切换到 official 分支。"}
{"title": "1小时带你撸一个小程序cli脚手架 ", "author": "Rolan", "pub_time": "2019-7-19 00:12", "content": "在正文之前先大致描述下什么是cli工具，cli工具英文名command-line interface,也就是命令行交互接口，比较典型的几个case例如，create-react-app，vue-cli，具体可以去百度一下，下面gif是小打卡目前用的一套自动化发布工具:wrench:可以看到整个发布流程大致是以选择或默认项的形式实现，大致分析下面几步选择打包形式    开发模式/debug模式/发布模式设置版本号填写发布信息选择环境是否提交版本commit是不是非常无脑？是不是再也不用担心线上发错环境了？有了它就算不同项目间，就算一天发n次版本还需要担心什么呢？当然除了简单的发布功能还，还可以做很多的事情，比如 创建page/component模版 等一些更多有趣的事情为了节约版面就不贴图了，具体可以看下仓库 github.com/jinxuanzhen… （目前该工具是从小打卡现有的cli库中抽离的部分功能）明确痛点也就是我为什么要做这么一个工具，其实最开始我只是为了解决一个问题，就是在整个发布流程中需要人工去改动/确认发布环境和版本信息，大致可以想象下把线下环境发布到线上的尴尬处境后续发现从cli角度触发，很多东西都变得简单了，大致列了下：环境变量切换（线上环境，线下环境）创建启动模版，包括页面，组件自动化发布...准备工作本文会以快速创建页面模版文件为例教你怎么快速撸一个属于自己的cli工具，如果觉得自己做比较麻烦，可以clone下我的仓库自己改装下需要了解的三方库中间会用到一些第三方库commander ， 一个解析命令行命令和参数工具inquirer ，常用交互式命令行用户界面的集合chalk ，美化你的终端输出样式fuzzy，字符串模糊匹配的插件，根据输入关键词进行模糊匹配json-format，json美化/格式化工具其他的一些小知识：比如path模块，fs模块，大家可以去node官网自行查看：nodejs.org/api/搭建开发环境创建一个空文件夹，并且npm初始化, 并且创建一个index.js页面，这个index.js将作为你整个包的入口文件npm init -y\r\n复制代码安装上述的三方包，当然也可以后续按需安装，这样更能清楚每个包是做什么的npm install @moyuyc/inquirer-autocomplete-prompt commander chalk commander fuzzy inquirer json-format --save\r\n复制代码在package.json里添加bin字段, 将自定义的命令软连到全局环境，同时执行npm link创建链接，这里如果报错{code EACCES，errno:13，...}，是因为权限不足，可以尝试sudo npm link\"bin\": {\r\n    \"cli-demo\": \"./index.js\"\r\n  }\r\n复制代码在入口文件，index.js 行首加入一行指定当前脚本由node.js进行解析#!/usr/bin/env node\t\t\t// 指定运行环境\r\n\r\n// 输出文本\r\nconsole.log('Hello World!!!');\r\n复制代码这时可以在命令行中执行 cli-demo 验收一下成果了ok，可以看到当在全局状态下输入自定义命令时，正确运行了入口文件，也就意味着的开发玩具已经搭建完成Let‘ Go整理逻辑以快速创建页面模版文件为例，就需要考虑需要哪些逻辑:设置页面名称找到已有模版文件copy到项目中修改app.json识别命令行在刚才的 Hello World!!! 环节，已经可以正确识别cli-demo，但是需要在一个cli工具中集成更多功能，可能需要有不同的执行策略，以git为例： git clone, git status，git push ，所以需要识别不同的命令和参数，是时候就需要用到 commander 这个第三方包帮助解析命令行参数了，当然你也可以自己撸一个lib，本质上还是方便解析 process.argvindex.js (本质上这个js就是一个路由)#!/usr/bin/env node\r\n\r\nconst version                       = require('./package').version;                 // 版本号\r\n\r\n/* = package import\r\n-------------------------------------------------------------- */\r\n\r\nconst program                       = require('commander');                         // 命令行解析\r\n\r\n/* = task events\r\n-------------------------------------------------------------- */\r\nconst createProgramFs               = require('./lib/create-program-fs');           // 创建项目文件\r\n\r\n\r\n/* = config\r\n-------------------------------------------------------------- */\r\n\r\n// 设置版本号\r\nprogram.version(version, '-v, --version');\r\n\r\n/* = deal receive command\r\n-------------------------------------------------------------- */\r\n\r\nprogram\r\n    .command('create')\t\t\r\n    .description('创建页面或组件')\r\n    .action((cmd, options) => createProgramFs(cmd));\r\n\r\n/* 后续可以根据不同的命令进行不同的处理，可以简单的理解为路由 */\r\n// program\r\n//     .command('build [cli]')\r\n//     .description('执行打包构建')\r\n//     .action((cmd, env) => callback);\r\n\r\n/* = main entrance\r\n-------------------------------------------------------------- */\r\nprogram.parse(process.argv)\r\n复制代码这时候当键入 cli-demo create 时会自动执行createProgramFscreateProgramFs.jsmodule.exports = function () {\r\n    console.log('Hi, create-program-fs.js');\r\n};\r\n复制代码命令行输入 cli-demo create可以看到已经成功的 开辟出了一块独立的业务模块 ，后续就只需要依据需求填补相应的内容即可创建交互命令收到执行命令，这个时候按第一张图，是需要开始一系列QA（当然你也可以不做交互式，直接配置命令行参数），引入三方包  inquirer ，来指定问题队列const question = [\r\n  \r\n    // 选择模式使用 page -> 创建页面 | component -> 创建组件\r\n    {\r\n        type: 'list',\r\n        name: 'mode',\r\n        message: '选择想要创建的模版',\r\n        choices: [\r\n            'page',\r\n            'component',\r\n        ]\r\n    },\r\n    \r\n    // 设置名称\r\n    {\r\n        type: 'input',\r\n        name: 'name',\r\n        message: answer => `设置 ${answer.mode} 名称 (e.g: index):`,\r\n    },\r\n];\r\n\r\nmodule.exports = function() {\r\n\t\r\n    // 问题执行\r\n    inquirer.prompt(question).then(answers => {\r\n\t\tconsole.log(answers);\r\n    });\r\n};\r\n复制代码、可以看到通过一系列QA交互， 实际输出拿到的是一个json对象，第一步已完成创建模版文件创建一个 存放模版文件的文件夹template ，并准备好你希望的模版项目中使用模版文件为了方便阅读，下面的代码，需要明确下面变量的定义， Config.dir_root  = 命令行执行目录 Config.root  = cli项目根目录 Config.appRoot = 小程序项目路径 Config.template = 模版目录这里有两个点，一个是执行路径的问题，另一个是分包的问题，具体如下：执行路径这里一定要弄明白**__dirname， process.cwd()**的区别，同时还有一些小程序是自己搭的gulp/webpack，可能小程序项目是在src目录下，一定要分清楚__dirname： 被执行js文件的绝对路径，一般在index.js执行时缓存起来 作为项目的全局路径，比如找到template文件夹就会使用 ${__dirname}/templateprocess.cwd()：当前 命令行运行时的工作目录 ，比如在/Users/xuan/Documents/cli-demo如果当前项目在src，或其他文件夹里怎么办？可以提供一个给用户项目中的配置文件，类似于gulpfile.js或是webpack.config.js的形式，内容例如（具体可以看 git仓库 ）module.exports = {\r\n\r\n    // 小程序路径\r\n    app: './src',\r\n\r\n    // 模版文件夹\r\n    template: './template'\r\n};\r\n复制代码可以看到对象中app属性，可以 指定你当前小程序项目的路径分包因为小程序的分包机制会导致页面实际路径与在主包的路径不相符，例如：主包：pages/index/index分包：pages/main_module/pages/habit_enlist/habit_enlist解决这个问题一方面是要有页面创建要有一定的 规范，统一格式 ，另一方面需要 根据规则解析app.json，上面的主包，分包路径差不多是我目前使用的规范解析app.json// 获取app.json\r\nfunction getAppJson() {\r\n    let appJsonRoot = path.join(Config.appRoot, '/app.json');\r\n    try {\r\n        return require(appJsonRoot);\r\n    }catch (e) {\r\n        Log.error(`未找到app.json, 请检查当前文件目录是否正确，path: ${appJsonRoot}`);\r\n        process.exit(1);\t\t\t// 异常退出\r\n    }\r\n}\r\n\r\n// 解析app.json\r\nlet parseAppJson = () => {\r\n\r\n    // app Json 原文件\r\n    let appJson = __Data__.appJson = getAppJson();\r\n\r\n    // 获取主包页面\r\n    appJson.pages.forEach(path => __Data__.appPagesList[getPathSubSting(path)] = '');\r\n\r\n    // 获取分包，页面列表\r\n    appJson.subPackages.forEach(item => {\r\n        __Data__.appModuleList[getPathSubSting(item.root)] = item.root;\r\n        item.pages.forEach(path => __Data__.appPagesList[getPathSubSting(path)] = item.root);\r\n    });\r\n};\r\n\r\n// __Data__.appPagesList = 小程序全部页面\r\n// __Data__.appModuleList = 小程序全部分包页面\r\n// item结构 {util_module: 'pages/util_module/'}，这么定义结构是为了方便后续取数\r\n复制代码question队列里，增加删选分包的选项// 设置page所属module\r\n    {\r\n        type: 'autocomplete',\r\n        name: 'modulePath',\r\n        message: 'Set page ownership module',\r\n        choices: [],\r\n        suggestOnly: false,\r\n        source(answers, input) {\r\n            // none 代表放在主包\r\n            return Promise.resolve(fuzzy.filter(input, ['none', ...Object.keys(__Data__.appModuleList)]).map(el => el.original));\r\n        },\r\n        filter(input) {\r\n            if (input === 'none') {\r\n                return '';\r\n            }\r\n            return __Data__.appModuleList[input];\r\n        },\r\n        when(answer) {\r\n            return answer.mode === 'page';\r\n        }\r\n    }\r\n复制代码autocomplete类型本质上是个列表，但是可以进行模糊查询，非常方便，像小打卡有接近30个分包的情况下效果尤为明显有了文件名，有了分包路径，有了可供copy的模版，接下来就很简单了，把模版文件塞进项目就可以了，下面是一串从仓库里copy的代码，利用async/await很方便的写出一维代码，基本上的流程:获取路径 -> 校验 -> 获取文件信息 -> 复制文件 -> 修改app.json -> 输出结果信息async function createPage(name, modulePath = '') {\r\n\r\n    // 获取模版文件路径\r\n    let templateRoot = path.join(Config.template, '/page');\r\n    if (!Util.checkFileIsExists(templateRoot)) {\r\n        Log.error(`未找到模版文件, 请检查当前文件目录是否正确，path: ${templateRoot}`);\r\n        return;\r\n    }\r\n    \r\n    // 获取业务文件夹路径\r\n    let page_root = path.join(Config.appRoot, modulePath, '/pages', name);\r\n\r\n    // 查看文件夹是否存在\r\n    let isExists = await Util.checkFileIsExists(page_root);\r\n    if (isExists) {\r\n        Log.error(`当前页面已存在，请重新确认, path: ` + page_root);\r\n        return;\r\n    }\r\n\r\n    // 创建文件夹\r\n    await Util.createDir(page_root);\r\n\r\n    // 获取文件列表\r\n    let files = await Util.readDir(templateRoot);\r\n\r\n    // 复制文件\r\n    await Util.copyFilesArr(templateRoot, `${page_root}/${name}`, files);\r\n\r\n    // 填充app.json\r\n    await writePageAppJson(name, modulePath);\r\n\r\n    // 成功提示\r\n    Log.success(`createPage success, path: ` + page_root);\r\n}\r\n复制代码扩展一个基本的快速创建页面模版的cli工具就这样完成，但是有可能需要更多的一些功能自定义模版比如说每个项目的模版都有可能不太一样，很大程度上需要根据项目进行定制，这时候可能就需要前文提到的给用户开放config文件的插槽了项目中的config：// xdk.config.js\r\nmodule.exports = {\r\n\r\n    // 小程序路径\r\n    app: './',\r\n\r\n    // 模版文件夹\r\n    template: './template'\r\n};\r\n\r\n// create-program-fs.js\r\nmodule.exports = function() {\r\n\t\r\n     // 校验：当前是否存在配置文件\r\n    let customConfPath = `${Config.dir_root}/xdk.config.js`;\r\n    if (!Util.checkFileIsExists(customConfPath)) {\r\n        Log.error('当前项目尚未创建xdk.config.js文件');\r\n        return;\r\n    }\r\n\r\n    // 获取用户配置项\r\n    let {app, template = ''} = require(customConfPath);\r\n\r\n    // 小程序目录\r\n    Config.appRoot = path.resolve(path.join(Config.dir_root, app));\r\n\r\n    // 模版文件目录（默认使用cli提供的默认模版，当config文件有设置template路径时，使用自定义路径）\r\n    !!template && (Config.template = path.resolve(path.join(Config.dir_root, template))));\r\n    \r\n    // 问题执行\r\n    inquirer.prompt(question).then(answers => {\r\n\t\tconsole.log(answers);\r\n    });\r\n};\r\n复制代码发布的npm仓库目前从开发到调试本质上是在本地提供服务，利用npm link提供软连接到全局PATH，其实也可以直接发到npm上，让其他使用的该cli的成员一建安装，比如npm install -g xxxxxxx, 具体教程的话百度，google有很多，作者表示很懒，遇到问题下面留言吧。。最后可以看到整个功能逻辑相对于平时写的复杂的业务逻辑来说相对简单，主要是工具库的一些使用方面的东西，中间的难点可能就是node中概念性的一些东西，然而这些多看一下文档基本就可以解决，希望大家可以从本文中了解到如何 快速搭建一个属于自己的cli工具顺便预告下后续的话可能会更新一些如何利用cli工具做到自动化发布，版本号控制，环境变量切换，自动生成文档等一系列有趣的功能"}
{"title": "小程序日历组件 ", "author": "Rolan", "pub_time": "2019-7-19 00:42", "content": "程序日历组件\r\n闲来没事把之前想做的日历组件给做了 先上图\r\n\r\n参数\r\n\r\n        \r\n            参数\r\n            类型\r\n            说明\r\n            默认值\r\n        \r\n        \r\n            header\r\n            Boolean\r\n            是否显示头部操作栏\r\n            true\r\n        \r\n        \r\n            preMonth\r\n            Boolean\r\n            是否显示上个月按钮\r\n            true\r\n        \r\n         \r\n            nextMonth\r\n            Boolean\r\n            是否显示下个月按钮\r\n            true\r\n        \r\n         \r\n            preYear\r\n            Boolean\r\n            是否显示上一年按钮\r\n            false\r\n        \r\n         \r\n            nextYear\r\n            Boolean\r\n            是否显示下一年按钮\r\n            false\r\n        \r\n         \r\n            today\r\n            Boolean\r\n            是否显示今天按钮\r\n            false\r\n        \r\n        \r\n            weeks\r\n            Boolean\r\n            是否显示周标题\r\n            true\r\n        \r\n        \r\n            weeksType\r\n            String\r\n            周标题类型\r\n            cn\r\n        \r\n        \r\n            showMoreDays\r\n            Boolean\r\n            是否显示前后月份残余数据\r\n            false\r\n        \r\n        \r\n            formatType\r\n            String\r\n            日期连接符\r\n            -\r\n        \r\n    \r\n事件\r\n\r\n\r\n\r\n事件名称\r\n说明\r\n\r\n\r\n\r\n\r\nselect\r\n在选择日期时触发，返回选中的日期\r\n\r\n\r\n\r\n示例\r\nindex.wxml\r\n<calendar today=\"{{true}}\" bind:select=\"select\"></calendar>\r\n复制代码index.json\r\n\"usingComponents\": {\r\n        \"calendar\": \"../../../components/calendar/index\"\r\n    }\r\n复制代码index.js\r\nselect(e) {\r\n        console.log(e)\r\n    },\r\n复制代码返回选中的日期 e.detail.value\r\n\r\n详细代码看github\r\ngithub"}
{"title": "垃圾分类小程序 ", "author": "Rolan", "pub_time": "2019-7-22 00:13", "content": "垃圾分类，从我做起最近垃圾分类比较火，各大城市纷纷开始实施垃圾分类制度，提高垃圾的资源价值和经济价值。但是垃圾分类不好记，然后我自己捣鼓了一款垃圾分类小程序，来帮助大家进行垃圾分类。:smile: 做小程序的同时自己也学习了一波。小程序（垃圾的小窝）该程序实现了文字搜索，图像识别，查看分类等功能，非常具有实用性。下面贴几张图：暂时就贴这几张图了，想要了解更多，可以搜索 垃圾的小窝 或者扫小程序码体验。开发技术栈这次开发用到的技术栈有Taro+TS+Stylus，不得不说，框架还是比原生坑多的，如果不做多端的话不建议尝试框架。后续我可能会发布支付宝小程序端。希望大家能支持。小程序码欢迎大家体验:clap:并给出建议。源码地址： https://github.com/webpig/gar..."}
{"title": "微信小程序之网络通信 ", "author": "Rolan", "pub_time": "2019-7-22 00:32", "content": "关于网络通信，这里我使用的是wx.request,官方代码示例如下:wx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  data: {\r\n    x: '',\r\n    y: ''\r\n  },\r\n  header: {\r\n    'content-type': 'application/json' // 默认值\r\n  },\r\n  success (res) {\r\n    console.log(res.data)\r\n  }\r\n})对于初学者而言，官方示例可能会看不怎么懂，所以我就以我自己当初项目驱动学习的方式(开发个人的记账小程序)来作为学习实例。以登录来说，效果图如下:此次示例包含表单校验和网络请求，代码如下:login.js// pages/login/login.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    username: \"\",\r\n    password: \"\"\r\n\r\n  },\r\n   register:function(e){\r\n    wx.navigateTo({\r\n      url: '../register/register'\r\n    })\r\n\r\n  },\r\n  formSubmit: function(e) {\r\n    console.log(e.detail.value.email);\r\n    console.log(e.detail.value.pwd)\r\n    var username = e.detail.value.email;\r\n    var password = e.detail.value.pwd;\r\n    var emailReg = /^[A-Za-z\\d]+([-_.][A-Za-z\\d]+)*@([A-Za-z\\d]+[-.])+[A-Za-z\\d]{2,4}$/;\r\n    if (username == null || username == \"\") {\r\n      wx.showToast({\r\n        title: \"用户名不能为空\",\r\n        icon: 'none',\r\n        duration: 1500\r\n      })\r\n    } else if (!emailReg.test(username)) {\r\n\r\n      wx.showToast({\r\n        title: \"邮箱有误\",\r\n        icon: 'none',\r\n        duration: 1500\r\n      })\r\n\r\n    } else if (password == null || password == \"\") {\r\n      wx.showToast({\r\n        title: \"密码不能为空\",\r\n        icon: 'none',\r\n        duration: 1500\r\n      })\r\n    } else {\r\n      wx.request({\r\n\r\n        url: getApp().globalData.urlPath + \"sysUser/login\",\r\n        method: \"POST\",\r\n        data: {\r\n          username: username,\r\n          password: password\r\n        },\r\n        header: {\r\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        },\r\n        success: function(res) {\r\n          console.log(res.data);\r\n          if (res.statusCode == 200) {\r\n\r\n            //访问正常\r\n            if (res.data.code == \"000000\") {\r\n              wx.showToast({\r\n                title: \"登陆成功\",\r\n                icon: 'success',\r\n                duration: 2000,\r\n                success: function() {\r\n                  wx.navigateTo({\r\n                    url: '../manage/manage'\r\n                  })\r\n\r\n                  wx.setStorage({\r\n                    key: 'userId',\r\n                    data: res.data.user.userCode\r\n                  })\r\n\r\n                  wx.setStorage({\r\n                    key: 'userName',\r\n                    data: res.data.user.userName\r\n                  })\r\n                  console.log(\"test:\" + wx.getStorageSync('userName'));\r\n                }\r\n              })\r\n\r\n            } else if (res.data.code == \"111111\") {\r\n              wx.showToast({\r\n                title: \"密码错误\",\r\n                icon: 'none',\r\n                duration: 1500\r\n              })\r\n            } else {\r\n              wx.showToast({\r\n                title: \"该用户不存在\",\r\n                icon: 'none',\r\n                duration: 1500\r\n              })\r\n            }\r\n          } else {\r\n\r\n            wx.showLoading({\r\n              title: '系统异常',\r\n              fail\r\n            })\r\n\r\n            setTimeout(function() {\r\n              wx.hideLoading()\r\n            }, 2000)\r\n          }\r\n\r\n        }\r\n      })\r\n    }\r\n\r\n  }\r\n})关于login.js，主要是写通信逻辑的，与咱们平时写js差异并不大，唯一不同的就是api长得不样罢了。关于其中的getApp().globalData.urlPath，相当于全局变量，不用我每次都写一大串https之类的。表单校验的效果如图: 代码说明:显示消息提示框(相当于js的alert提示):wx.showToast({\r\n  title: \"邮箱有误\",\r\n  icon: 'none',\r\n  duration: 1500\r\n})获取input属性为name的值(相当于js中form.email.value,前提是这个表单name要为form，且form中的input要存在一个name=”email”)e.detail.value.email;跳转代码(相当于window.location.href):wx.navigateTo({\r\n url: '../manage/manage'\r\n})至于wx.request，我想只要是写过ajax的，都很好理解。login.json:{\r\n  \"usingComponents\": {}\r\n}关于这个login.json有什么用，我唯一想到的是页面的title(其实相当于html中的title)lgoin.wxml:<view class='container'>\r\n  <view class='header'>\r\n    <text>acs系统</text>\r\n  </view>\r\n    <view>\r\n    <text>\\n</text>\r\n  </view>\r\n  <view class='header'>\r\n  </view>\r\n  <form bindsubmit=\"formSubmit\">\r\n    <view class='section'>\r\n      <text>用户名：</text>\r\n      <input type='text' name=\"email\" placeholder='请输入邮箱' />\r\n    </view>\r\n    <view class='section'>\r\n      <text>密码:</text>\r\n      <input password='password' name=\"pwd\" placeholder='请输入密码' />\r\n    </view>\r\n    <view class='button'>\r\n      <button type='primary' form-type='submit'>登录</button>\r\n      <text>\\n</text>\r\n       <view bindtap='register' class=\"register\">注册</view>\r\n    </view>\r\n  </form>\r\n\r\n</view>wxml相当于视图(如html或者模板语言(jsp、volocity、freemarker、beetl等))视图除了可以写一些标签之类的，还可以写一些逻辑判断。后面会讲到的。login.wxss:/* pages/login/login.wxss */\r\nform{\r\n  width: 310px;\r\n  height: 240px;\r\n  line-height: 40px;\r\n  /* border: 1px solid red;  */\r\n}\r\ninput{\r\n  border: 1px solid #ccc;\r\n  width: 310px;\r\n  height: 40px;\r\n}\r\n.button{\r\n  margin-top: 20px;\r\n}\r\n.header text{\r\n  font-size: 25px;\r\n  color: #666;\r\n}\r\nform text{\r\n  font-size: 20px;\r\n  color: #666;\r\n}\r\n.register{\r\ncolor:black;\r\ndisplay: block;\r\nwidth: 310px;\r\nheight: 40px;\r\nborder: 1px solid #ccc;\r\ntext-align: center;\r\n}这个wxss就相当于css，定义视图的样式，决定视图长什么样(好看不好看)关于微信小程序网络通信，更多信息可以参考官方文档:wx.request"}
{"title": "小程序开发另类小技巧 --用户授权篇 ", "author": "Rolan", "pub_time": "2019-7-22 00:42", "content": "getUserInfo较为特殊，不包含在本文范围内，主要针对需要授权的功能性api，例如：wx.startRecord，wx.saveImageToPhotosAlbum， wx.getLocation\r\n\r\n仓库地址：github.com/jinxuanzhen…\r\n\r\n背景\r\n小程序内如果要调用部分接口需要用户进行授权，例如获取地理位置信息，收获地址，录音等等，但是小程序对于这些需要授权的接口并不是特别友好，最明显的有两点：\r\n\r\n如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调，\r\n没有统一的错误信息提示，例如错误码\r\n\r\n一般情况而言，每次授权时都应该激活弹窗进行提示，是否进行授权，例如：\r\n\r\n而小程序内只有第一次进行授权时才会主动激活弹窗（微信提供的），其他情况下都会直接走fail回调，微信文档也在句末添加了一句请开发者兼容用户拒绝授权的场景这种未做兼容的情况下如果用户想要使用录音功能，第一次点击拒绝授权，那么之后无论如何也无法再次开启录音权限**，很明显不符合我们的预期。\r\n所以我们需要一个可以进行二次授权的解决方案\r\n\r\n常见处理方法\r\n\r\n官方demo\r\n下面这段代码是微信官方提供的授权代码, 可以看到也并没有兼容拒绝过授权的场景查询是否授权（即无法再次调起授权）\r\n// 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope\r\nwx.getSetting({\r\n  success(res) {\r\n    if (!res.authSetting['scope.record']) {\r\n      wx.authorize({\r\n        scope: 'scope.record',\r\n        success () {\r\n          // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n          wx.startRecord()\r\n        }\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码\r\n一般处理方式\r\n那么正常情况下我们该怎么做呢？以地理位置信息授权为例：\r\nwx.getLocation({\r\n   success(res) { \r\n      console.log('success', res);\r\n   },\r\n   fail(err) {\r\n      // 检查是否是因为未授权引起的错误\r\n      wx.getSetting({\r\n         success (res) {               \r\n            // 当未授权时直接调用modal窗进行提示\r\n            !res.authSetting['scope.userLocation'] && wx.showModal({\r\n               content: '您暂未开启权限，是否开启',\r\n               confirmColor: '#72bd4a',\r\n               success: res => {              \r\n                  // 用户确认授权后，进入设置列表\r\n                  if (res.confirm) {\r\n                     wx.openSetting({\r\n                        success(res){\r\n                           // 查看设置结果\r\n                           console.log(!!res.authSetting['scope.userLocation'] ? '设置成功' : '设置失败');\r\n                        },\r\n                     });\r\n                  }\r\n               }\r\n            });\r\n         }\r\n      });\r\n   }\r\n});\r\n复制代码上面代码，有些同学可能会对在fail回调里直接使用wx.getSetting有些疑问，这里主要是因为\r\n\r\n微信返回的错误信息没有一个统一code\r\nerrMsg又在不同平台有不同的表现\r\n从埋点数据得出结论，调用这些api接口出错率基本集中在未授权的状态下\r\n\r\n这里为了方便就直接调用权限检查了 ，也可以稍微封装一下，方便扩展和复用，变成：\r\n  bindGetLocation(e) {\r\n        let that = this;\r\n        wx.getLocation({\r\n            success(res) {\r\n                console.log('success', res);\r\n            },\r\n            fail(err) {\r\n                that.__authorization('scope.userLocation');\r\n            }\r\n        });\r\n    },\r\n    bindGetAddress(e) {\r\n        let that = this;\r\n        wx.chooseAddress({\r\n            success(res) {\r\n                console.log('success', res);\r\n            },\r\n            fail(err) {\r\n                that.__authorization('scope.address');\r\n            }\r\n        });\r\n    },\r\n    __authorization(scope) {\r\n\t\t  \t/** 为了节省行数，不细写了，可以参考上面的fail回调，大致替换了下变量res.authSetting[scope] **/ \r\n    }\r\n复制代码看上去好像没有什么问题，fail里只引入了一行代码，\r\n这里如果只针对较少页面的话我认为已经够用了，毕竟**‘如非必要，勿增实体’，但是对于小打卡这个小程序来说可能涉及到的页面，需要调用的场景偏多**，我并不希望每次都人工去调用这些方法，毕竟人总会犯错\r\n\r\n梳理目标\r\n上文已经提到了背景和常见的处理方法，那么梳理一下我们的目标，我们到底是为了解决什么问题？列了下大致为下面三点：\r\n\r\n兼容用户拒绝授权的场景，即提供二次授权\r\n解决多场景，多页面调用没有统一规范的问题\r\n在底层解决，业务层不需要关心二次授权的问题\r\n\r\n\r\n扩展wx[funcName]方法\r\n为了节省认知成本和减少出错概率，我希望他是这个api默认携带的功能，也就是说因未授权出现错误时自动调起是否开启授权的弹窗\r\n为了实现这个功能，我们可能需要对wx的原生api进行一层包装了（关于页面的包装可以看：如何基于微信原生构建应用级小程序底层架构）\r\n\r\n为wx.getLocation添加自己的方法\r\n这里需要注意的一点是直接使用常见的装饰模式是会出现报错，因为wx这个对象在设置属性时没有设置set方法，这里需要单独处理一下\r\n// 直接装饰，会报错 Cannot set property getLocation of #<Object> which has only a getter \r\nlet $getLocation = wx.getLocation;\r\nwx.getLocation = function (obj) {\r\n    $getLocation(obj);\t\r\n};\r\n\r\n// 需要做一些小处理\r\nwx = {...wx};\t\t\t\t\t\t\t\t\t\t// \t对wx对象重新赋值\r\nlet $getLocation = wx.getLocation;\r\nwx.getLocation = function (obj) {\t\t\t\t\t\r\n    console.log('调用了wx.getLocation');\r\n    $getLocation(obj);\t\r\n};\r\n\r\n// 再次调用时会在控制台打印出 '调用了wx.getLocation' 字样\r\nwx.getLocation()\r\n复制代码\r\n劫持fail方法\r\n第一步我们已经控制了wx.getLocation这个api，接下来就是对于fail方法的劫持，因为我们需要在fail里加入我们自己的授权逻辑\r\n// 方法劫持\r\nwx.getLocation = function (obj) {\r\n    let originFail = obj.fail;\r\n\r\n    obj.fail = async function (errMsg) {\r\n        // 0 => 已授权 1 => 拒绝授权 2 => 授权成功\r\n        let authState = await authorization('scope.userLocation');\r\n        \r\n        // 已授权报错说明并不是权限问题引起，所以继续抛出错误\r\n        // 拒绝授权，走已有逻辑，继续排除错误\r\n        authState !== 2 && originFail(errMsg);\r\n    };\r\n    $getLocation(obj);\r\n};\r\n\r\n// 定义检查授权方法\r\nfunction authorization(scope) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.getSetting({\r\n            success (res) {\r\n                !res.authSetting[scope]\r\n                    ? wx.showModal({\r\n                        content: '您暂未开启权限，是否开启',\r\n                        confirmColor: '#72bd4a',\r\n                        success: res => {\r\n                            if (res.confirm) {\r\n                                wx.openSetting({\r\n                                    success(res){\r\n                                        !!res.authSetting[scope] ? resolve(2) : resolve(1)\r\n                                    },\r\n                                });\r\n                            }else {\r\n                                resolve(1);\r\n                            }\r\n                        }\r\n                    })\r\n                    : resolve(0);\r\n            }\r\n        })\r\n    });\r\n}\r\n\r\n// 业务代码中的调用\r\n  bindGetLocation(e) {\r\n        let that = this;\r\n        wx.getLocation({\r\n            type: 'wgs84',\r\n            success(res) {\r\n                console.log('success', res);\r\n            },\r\n            fail(err) {\r\n                console.warn('fail', err);\r\n            }\r\n        });\r\n  }\r\n\r\n复制代码可以看到现在已实现的功能已经达到了我们最开始的预期，即因授权报错作为了wx.getLocation默认携带的功能，我们在业务代码里再也不需要处理任何再次授权的逻辑\r\n也意味着wx.getLocation这个api不论在任何页面，组件，出现频次如何，**我们都不需要关心它的授权逻辑（**效果本来想贴gif图的，后面发现有图点大，具体效果去git仓库跑一下demo吧）\r\n\r\n让我们再优化一波\r\n上面所述大致是整个原理的一个思路，但是应用到实际项目中还需要考虑到整体的扩展性和维护成本，那么就让我们再来优化一波\r\n代码包结构：本质上只要在app.js这个启动文件内，引用./x-wxx/index文件对原有的wx对象进行覆盖即可\r\n\r\n**简单的代码逻辑： **\r\n// 大致流程：\r\n\r\n//app.js\r\nwx = require('./x-wxx/index');\t\t\t\t\t\t// 入口处引入文件\r\n\r\n// x-wxx/index \r\nconst apiExtend = require('./lib/api-extend')；\r\nmodule.exports = (function (wxx) {\t\t\t\t    // 对原有方法进行扩展\r\n    wxx = {...wxx};\r\n    for (let key in wxx) {\r\n        !!apiExtend[key] && (()=> {\r\n\r\n            // 缓存原有函数\r\n            let originFunc = wxx[key];\r\n\r\n            // 装饰扩展的函数\r\n            wxx[key] = (...args) => apiExtend[key](...args, originFunc);\r\n        })();\r\n    }\r\n    return wxx;\r\n})(wx);\r\n\r\n// lib/api-extend\r\nconst Func = require('./Func');\r\n(function (exports) {\t\t\t\t\t\t\t\t// 需要扩展的api（类似于config）\r\n    // 获取权限\r\n    exports.authorize = function (opts, done) {\r\n        // 当调用为\"确认授权方法时\"直接执行，避免死循环\r\n        if (opts.$callee === 'isCheckAuthApiSetting') {\r\n            console.log('optsopts', opts);\r\n            done(opts);\r\n            return;\r\n        }\r\n        Func.isCheckAuthApiSetting(opts.scope, () => done(opts));\r\n    };\r\n\r\n    // 选择地址\r\n    exports.chooseAddress = function (opts, done) {\r\n        Func.isCheckAuthApiSetting('scope.address', () => done(opts));\r\n    };\r\n\r\n    // 获取位置信息\r\n    exports.getLocation = function (opts, done) {\r\n        Func.isCheckAuthApiSetting('scope.userLocation', () => done(opts));\r\n    };\r\n\r\n    // 保存到相册\r\n    exports.saveImageToPhotosAlbum = function (opts, done) {\r\n        Func.isCheckAuthApiSetting('scope.writePhotosAlbum', () => done(opts));\r\n    }\r\n\r\n    // ...more\r\n})(module.exports);\r\n复制代码\r\n更多的玩法\r\n可以看到我们无论后续扩展任何的微信api，都只需要在lib/api-extend.js 配置即可，这里不仅仅局限于授权，也可以做一些日志，传参的调整，例如：\r\n // 读取本地缓存(同步)\r\nexports.getStorageSync = (key, done) => {\r\n        let storage = null;\r\n        try {\r\n            storage = done(key);\r\n        } catch (e) {\r\n            wx.$logger.error('getStorageSync', {msg: e.type});\r\n        }\r\n        return storage;\r\n};\r\n复制代码这样是不是很方便呢，至于Func.isCheckAuthApiSetting这个方法具体实现，为了节省文章行数请自行去git仓库里查看吧\r\n\r\n关于音频授权\r\n录音授权略为特殊，以wx.getRecorderManager为例，它并不能直接调起录音授权，所以并不能直接用上述的这种方法，不过我们可以曲线救国，达到类似的效果，还记得我们对于wx.authorize的包装么，本质上我们是可以直接使用它来进行授权的，比如将它用在我们已经封装好的录音管理器的start方法进行校验\r\nwx.authorize({\r\n   scope: 'scope.record'\r\n});\r\n复制代码实际上，为方便统一管理，Func.isCheckAuthApiSetting方法其实都是使用wx.authorize来实现授权的\r\nexports.isCheckAuthApiSetting = async function(type, cb) {\r\n\r\n        // 简单的类型校验\r\n        if(!type && typeof type !== 'string') return;\r\n\r\n        // 声明\r\n        let err, result;\r\n\r\n        // 获取本地配置项\r\n        [err, result] = await to(getSetting());         // 这里可以做一层缓存，检查缓存的状态，如果已授权可以不必再次走下面的流程，直接return出去即可\r\n        if (err) {\r\n            return cb('fail');\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n        }\r\n\r\n        // 当授权成功时，直接执行\r\n        if (result.authSetting[type]) {\r\n            return cb('success');\r\n        }\r\n\r\n        // 调用获取权限\r\n        [err, result] = await to(authorize({scope: type, $callee: 'isCheckAuthApiSetting'}));\r\n        if (!err) {\r\n            return cb('success');\r\n        }\r\n}\r\n复制代码\r\n关于用户授权\r\n用户授权极为特殊，因为微信将wx.getUserInfo升级了一版，没有办法直接唤起了，详见《公告》，所以需要单独处理，关于这里会拆出单独的一篇文章来写一些有趣的玩法\r\n\r\n\r\n\r\n总结\r\n最后稍微总结下，通过上述的方案，我们解决了最开始目标的同时，也为wx这个对象上的方法提供了统一的装饰接口（lib/api-extend文件），便于后续其他行为的操作比如埋点，日志，参数校验\r\n还是那么一句话吧，小程序不管和web开发有多少不同，本质上都是在js境上进行开发的，希望小程序的社区环境更加活跃，带来更多有趣的东西"}
{"title": "微信小程序底层架构 ", "author": "Rolan", "pub_time": "2019-7-12 00:47", "content": "从技术的发展角度来看，微信小程序是从微信中的 webView 和 JS-SDK 进化到了今天的形态。那么，小程序和普通的 h5 页面到底有什么区别呢？运行环境：小程序基于浏览器内核重构的内置解析器，而 h5 的宿主环境是浏览器。所以小程序中没有 DOM 和 BOM 的相关 API ， jQuery 和一些 NPM 包都不能在小程序中使用；系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等；渲染机制：小程序的逻辑层和渲染层是分开的，而 h5 页面 UI 渲染跟 JavaScript 的脚本执行都在一个单线程中，互斥。所以 h5 页面中长时间的脚本运行可能会导致页面失去响应。其实，小程序开发过程中我们面对的是 iOS 和 Android 微信客户端和辅助开发的小程序开发者工具。根据官方文档，这三大运行环境也是有所区别的：运行环境逻辑层渲染层iOSJavaScriptCoreWKWebViewAndroidX5 JSCoreX5浏览器小程序开发者工具NWJSChrome WebView所以微信小程序介于 web 端和原生 App 之间，能够丰富调用功能接口，同时又跨平台。2. 小程序架构2.1 双线程模型小程序的渲染层和逻辑层分别由2个线程管理：渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。逻辑层：采用 JsCore 线程运行JS脚本。视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。（页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面）双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。2.2 组件系统我们知道小程序是有自己的组件的，这些基本组件就是基于 Exparser 框架。 Exparser 基于 WebComponents 的 ShadowDOM 模型，但是不依赖浏览器的原生支持，而且可在 纯 JS 环境中运行。小程序中，所有节点树相关的操作都依赖于 Exparser ，包括 WXML 到页面最终节点树的构建、 CreateSelectorQuery 调用和自定义组件特性等。现在微信小程序也支持自定义组件了，用法和组件间通信类似于 Vue 。2.3 原生组件在内置组件中，有一些组件并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染。比如说 Map 组件。它渲染的层级比在 WebView 层渲染的普通组件要高。引入原生组件的优点是：Web\r\nWebView\r\nsetData\r\n2.4 运行机制2.4.1 启动热启动：：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。2.4.2 销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。2.5 更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用 wx.getUpdateManager 做个检查更新的功能：checkNewVersion() {\r\n    const updateManager = wx.getUpdateManager();\r\n    updateManager.onCheckForUpdate((res) => {\r\n      console.log('hasUpdate', res.hasUpdate);\r\n      // 请求完新版本信息的回调\r\n      if (res.hasUpdate) {\r\n        updateManager.onUpdateReady(() => {\r\n          this.setData({\r\n            hasNewVersion: true\r\n          });\r\n        });\r\n      }\r\n    });\r\n  }\r\n复制代码微信小程序的基础底层架构大概就这么多，有机会再看看源码思考解析吧。"}
{"title": "mpvue-doc(关于小程序开发的一些想法) ", "author": "Rolan", "pub_time": "2019-7-15 00:05", "content": "对于初学者,最好的入门方式就是通读官方文档,不建议记api,用的时候可以快速找到就好小程序官方文档mpvue官方文档微信开发者工具不推荐使用原生开发的几点理由开发效率低频繁setData有性能消耗问题3.wx.request存在并发量限制问题(最大并发量不能超过10)关于尺寸不支持vue-router原生和mpvue官方不支持,这里是一个在mpvue基础上改造来的框架,支持vue-router类语法(对mpvue做了扩展) 猛撮这里 .组件支持自定义类继承语法<!-- index.vue -->\r\nimport BasePlatePage from '@/utils/basePlatePage'\r\nexport defalut new BasePlatePage({\r\n\tdata(){},\r\n\tmethods:{},\r\n\t...\r\n})\r\n复制代码类继承方式扩展了组件能力,可以阻塞生命周期方法(一般是onLoad),来实现一些预备逻辑,例如授权按需引入不支持运行环境判断但是有变通的办法小程序中__wxConfig.envVersion可以用来区分小程序体验版，开发板，正式版.\r\n\t\t\tenvVersion 类型为字符串\r\n\t\t\tenvVersion: 'develop',    //开发版\r\n\t\t\tenvVersion: 'trial',          //体验版\r\n\t\t\tenvVersion: 'release',     //正式版\r\n\t\t\t这样我们就可以变通的来实现小程序中动态切换域名,避免手动注释切换的方式.\r\n\t\t\t\r\n\t\t\t<!-- request.js -->\r\n\t\t\tlet envVersion = __wxConfig.envVersion || 'develop';\r\n\t\t\tconst url = envVersion === 'develop' ?  Store.state.testUrl ? Store.state.baseUrl\r\n\r\n复制代码通用分包加载主流方式1.创建目录pages 目录同级创建分包目录 moduleA->ma1.vue2.配置<!-- pages.json -->\r\n{\r\n\t\"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n\t\t{\r\n\t\t\t\"path\": \"pages/index/index\",\r\n\t\t\t\"style\": {\r\n\t\t\t\t\"navigationBarTitleText\": \"uni-app\"\r\n\t\t\t}\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"path\": \"pages/index/todoList\",\r\n\t\t\t\"style\": {\r\n\t\t\t\t\"navigationBarTitleText\": \"todolist\"\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t],\r\n\t\"subPackages\": [{\r\n\t\t\"root\": \"moduleA\",\r\n\t\t\"pages\": [{\r\n\t\t\t\"path\": \"ma1\",\r\n\t\t\t\"style\": {\r\n\t\t\t\t\"navigationBarTitleText\": \"ma1\"\r\n\t\t\t}\r\n\t\t}]\r\n\t}],\r\n\t\"globalStyle\": {\r\n\t\t\"navigationBarTextStyle\": \"black\",\r\n\t\t\"navigationBarTitleText\": \"uni-app\",\r\n\t\t\"navigationBarBackgroundColor\": \"#F8F8F8\",\r\n\t\t\"backgroundColor\": \"#F8F8F8\"\r\n\t}\r\n}\r\n复制代码mpvue-quickstart 框架下分包的使用方式生命周期方法mpvue支持vue所有生命周期方法和小程序所有生命周期方法页面跳转传参,只能在在onLoad方法以及之后方法中获取,onLoad中为事件参数e,onLoad之后方法通过this. mp.query<!--index.vue  -->\r\nexport default {\r\n  onLoad(e) {\r\n   console.log(e,'onLoad') //e:上个页面传递的参数对象{a: 1,b:2}\r\n   \r\n  },\r\n  onShow() {\r\n\t  console.log('onShow')\r\n  },\r\n\t  \r\n  onReady() {\r\n     console.log('onReady')\r\n  },\r\n\r\n  created () {\r\n    console.log(this.$root.$mp.query,'created') //获取不到参数,并且会报错,原因是页面传递的参数最早是从onLoad中获取\r\n  },\r\n  mounted() {\r\n    console.log(this.$root.$mp.query,'mounted') //可以获取到页面传递的参数\r\n  }\r\n}\r\n\r\n打印顺序依次为 created,onLoad,onShow,onReady,mounted\r\n复制代码模板语法支持情况扫码进入指定页面1.前端给后台指定页面路径,后台进行配置,生成二维码 2.前端在onLoad中使用decodeURIComponent方法解析获取onLoad(params) {\r\n\tif (params && params.scene) {\r\n\t\tthis.id = decodeURIComponent(params.scene).split('=')[1];  //扫码进入获取二维码携带的参数\r\n\t} else {\r\n\t\tthis.id = this.$route.query.id //普通路由跳转,携带的参数\r\n\t}\r\n}\r\n复制代码转发1.点击右上角\"转发\"按钮转发 2.页面内发起转发<!-- share.vue -->\r\n<template>\r\n<div>\r\n\t  <button class=\"share-btn\" open-type=\"share\">分享一下</button>\r\n</div>\r\n</template>\r\nexport default {\r\n\tdata() {\r\n\t\treturn {\r\n\t\t\tshareImageURL: \"https:xxx\" //图片地址\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\t\r\n\t},\r\n\t//该方法为转发的核心方法,必须要有,否则不会触发转发\r\n onShareAppMessage(from){\r\n\t if (res.from === 'button') {\r\n      // 来自页面内转发按钮\r\n      console.log(res.target)\r\n    }\r\n\t\treturn {\r\n\t\t\ttitle : '小程序购物' , //转发标题,默认小程序名称\r\n\t\t\tpath : '/pages/share' , //转发路径,默认当前页面 path ，必须是以 / 开头的完整路径\r\n\t\t\timageUrl : this.shareImageURL //自定义图片路径,支持网路路径和本地路径,png,jpg格式,默认使用截图\r\n\t\t}\r\n\t},\r\n}\r\n复制代码request请求wx.request小程序原生请求api,没啥说的,具体可以看wx.requestwx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  data: {\r\n    x: '',\r\n    y: ''\r\n  },\r\n  header: {\r\n    'content-type': 'application/json' // 默认值\r\n  },\r\n  success (res) {  //接口请求成功的回调函数\r\n    console.log(res.data)\r\n  },\r\n  fail(res) { //接口请求失败的回调函数\r\n\t  console.log(res)\r\n},\r\ncomplete(res) { //接口调用结束的回调,无论成功,失败都会执行\r\n\tconsole.log(res)\r\n)\r\n复制代码fly.io官方描述:一个支持所有JavaScript运行环境的基于Promise的、支持请求转发、强大的http请求库。可以让您在多个端上尽可能大限度的实现代码复用。<!-- 栗子 -->\r\n//token\r\nimport auth from './auth'\r\nimport Store from '../store'\r\n\r\nconst Fly = require('flyio/dist/npm/wx')\r\nconst fly = new Fly\r\nconst serviceURL = Store.state.domain;\r\n\r\nconst baseConfig = {\r\n\tmethod : 'post' ,\r\n\ttimeout : 30000 ,\r\n\tparseJson : true ,\r\n\twithCredentials:false\r\n}\r\n\r\nfly.config = baseConfig;\r\n\r\n//请求拦截\r\nfly.interceptors.request.use((config)=>{\r\n    //请求头\r\n\tlet token = auth.getToken();\r\n    config.baseURL = serviceURL;\r\n    config.headers['token'] = token;\r\n\treturn config\r\n})\r\n\r\n//响应拦截器\r\nfly.interceptors.response.use(response => {\r\n\t// 特殊提示\r\n\tif(Number(response.data.error) === 1){\r\n\t\t//console.error(response)\r\n\t\twx.showModal({\r\n\t\t\ttitle: '出错啦',\r\n\t\t\tcontent: response.data['error_reason'] ,\r\n\t\t\tshowCancel: false\r\n\t\t})\r\n\t\treturn { fail : true }\r\n\t}\r\n\r\n\t// 出错了\r\n\tif (Number(response.data.error) !== 0) {\r\n\t\tconsole.error(fly.config)\r\n\t\tconsole.error(response)\r\n\t\twx.hideLoading();\r\n\t\twx.showModal({\r\n\t\t\ttitle: '温馨提示',\r\n\t\t\tcontent: response.data['error_reason'] ,\r\n\t\t\tshowCancel: false\r\n\t\t})\r\n\t\treturn { fail : true }\r\n\t}\r\n\r\n\treturn response.data && response.data.data || { success: true };\r\n},error=>{\r\n\twx.showModal({\r\n\t\ttitle: '出错啦',\r\n\t\tcontent: '服务器开小差了~',\r\n\t\tshowCancel: false\r\n\t})\r\n\t// 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n\treturn error;\r\n})\r\n\r\nexport default fly\r\n复制代码下拉刷新1.app.json文件进行enablePullDownRefresh属性配置2.当前页面书写onPullDownRefresh方法(下拉刷新操作会自动触发该方法)<!--app.json  -->\r\n{\r\n  \"pages\": [\r\n    {\r\n      \"path\": \"pages/index\",\r\n      \"config\" : {\r\n        \"enablePullDownRefresh\": true, //当前页面是否允许下拉刷新\r\n        \"navigationBarTitleText\": \"首页\"\r\n    }\r\n    },\r\n    {\r\n      \"path\": \"pages/counter\"\r\n    },\r\n    {\r\n      \"path\": \"packageA/logs\",\r\n      \"subPackage\": true\r\n    }\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat222\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n  }\r\n}\r\n<!-- index.vue -->\r\nexport default {\r\n\tdata() {\r\n\t\treturn {}\r\n\t},\r\n\tmethods: {},\r\n\tonPullDownRefresh: function() {\r\n\t // Do something when pull down.\r\n\t  setTimeout(() => {\r\n            wx.stopPullDownRefresh();  //停止当前页面下拉刷新,这句代码必须写,否则会出现下拉后不返回的现象\r\n        }, 1500);\r\n  },\r\n\t\t\r\n}\r\n\t\r\n复制代码上拉加载这个方法一般不需要app.json文件中配置,但是有的手机上会出现触底后方法不触发的现象,因此,为了解决这个问题,然后在app.json里面设置下触发距离<!--app.json  -->\r\n{\r\n  \"pages\": [\r\n    {\r\n      \"path\": \"pages/index\",\r\n      \"config\" : {\r\n        \"enablePullDownRefresh\": true, //当前页面是否允许下拉刷新\r\n        \"navigationBarTitleText\": \"首页\",\r\n\t\t\"onReachBottomDistance\": 50 //设置触发距离,在触发距离内滑动期间，本事件只会被触发一次。\r\n    }\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat222\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n  }\r\n}\r\n<!-- index.vue -->\r\nexport default {\r\n\tdata() {\r\n\t\treturn {}\r\n\t},\r\n\tmethods: {},\r\n\t  onReachBottom: function() {\r\n        // Do something when page reach bottom.\r\n    },\r\n\t\t\r\n}\r\n复制代码scroll-viewscroll-view 是一个比较消耗性能的组件,遇到顶部带有navBar切换有长列表(分页加载)的页面首先考虑使用定位+页面滚动方式,实在不行再考虑使用该方法部分原生组件的层级问题小程序中部分原生组件,例如video,map等存在层级最高且无法通过z-index降低的问题,可以放一张图片进行占位,然后点击图片跳转到一个新页面播放视频或者展示地图cover-view和cover-image 覆盖层"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序组建通信 ", "author": "Rolan", "pub_time": "2019-4-22 00:22", "content": "子组件传递父组件需要用到triggerEvent方法，当子组件（自定义组件）点击button的时候调用triggerEvent方法传递一些数据，首先第一个属性为自定义名称（myevent）对应父组件（bind:myevent）名字是个标识必须相同，第二个参数就是要传递的数据，第三个参数是一些配置具体参考（https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html）。父组件bind:myevent=\"onMyEvent\"事件绑定，通过e.detail.count来获取数据。//父组件，引用component-tag-name\r\n<component-tag-name bind:myevent=\"onMyEvent\" />\r\n\r\n//index.js\r\nComponent({\r\n    onMyEvent(e) {\r\n        e.detail.count // 自定义组件触发事件时提供的detail对象，结果为1\r\n    }\r\n})//子组件\r\n<button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n\r\n//index.js\r\nComponent({\r\n  properties: {},\r\n  methods: {\r\n    onTap() {\r\n      const myEventDetail = {count:1} // detail对象，提供给事件监听函数\r\n      const myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    }\r\n  }\r\n})"}
{"title": "[UI组件] 来做一个可配置的滑块进度条吧 ", "author": "Rolan", "pub_time": "2019-5-7 00:32", "content": "在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, 宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。Component({\r\n    /**\r\n     * 组件的属性列表\r\n     */\r\n    properties: {\r\n        // 滑块大小\r\n        blockSize: {\r\n            type: Number,\r\n            value: 32,\r\n        },\r\n\r\n        // 滑块宽度\r\n        blockBorderWidth: {\r\n            type: Number,\r\n            value: 3\r\n        },\r\n\r\n        // 滑轨高度\r\n        height: {\r\n            type: Number,\r\n            value: 2\r\n        },\r\n\r\n        // 滑轨进度\r\n        step: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n\r\n        // 进度值小数位\r\n        digits: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n    },\r\n});<view id=\"slider-wrap\" class=\"slider-wrap\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view  class=\"silder-bg-inner\"></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>.slider-wrap {\r\n    position: relative;\r\n    display: flex;\r\n    align-items: center;\r\n    width: 100%;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner,\r\n.silder-block {\r\n    position: absolute;\r\n    left: 0;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner {\r\n    width: 100%;\r\n    height: 2rpx;\r\n    flex: 1;\r\n}\r\n\r\n.silder-bg {\r\n    overflow: hidden;\r\n    background-color: #eeeeee;\r\n    border-radius: 8rpx;\r\n    z-index: 0;\r\n}\r\n\r\n.silder-bg-inner {\r\n    height: 100%;\r\n    background-color: #66a6ff;\r\n    /* border-radius: 8rpx; */\r\n    z-index: 1;\r\n    border-bottom-left-radius: 8rpx;\r\n    border-top-left-radius: 8rpx;\r\n}\r\n\r\n.silder-block {\r\n    width: 32rpx;\r\n    height: 32rpx;\r\n    background-color: #ffffff;\r\n    border: solid 3rpx #66a6ff;\r\n    z-index: 2;\r\n    border-radius: 50%;\r\n    box-sizing: border-box;\r\n}\r\n点击行为事件滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条如下图所示：((191 - 36) / 301) * 100 ≈ 52<view class=\"slider-wrap\" bindtap=\"tappingSlider\">\r\n    <!-- ...other -->\r\n</view>Component({\r\n    // ...\r\n\r\n    /**\r\n     * 组件的初始数据\r\n     */\r\n    data: {\r\n        containerInfo: null,\r\n        percentage: 0,\r\n    },\r\n\r\n    ready() {\r\n        // 取到滑块进度条的位置信息\r\n        wx.createSelectorQuery().in(this)\r\n            .select('.slider-wrap')\r\n            .boundingClientRect((rect) => {\r\n                if (!rect) return;\r\n\r\n                this.data.container = rect;\r\n                this._initBloackPos();\r\n            }).exec()\r\n    },\r\n\r\n    // 点击进度条\r\n    tappingSlider(evt) {\r\n        const { containerInfo } = this.data;\r\n        if (!containerInfo) return;\r\n\r\n        const { clientX } = evt.changedTouches[0];\r\n        const { digits, _maxDistance } = this.data;\r\n\r\n        // 需要做边界处理\r\n        const perc = this._computeOffset(clientX, containerInfo.left, 100);\r\n        const percentage = this._boundaryHandler(perc);\r\n\r\n        this.setData({ percentage });\r\n        this.triggerEvent('change', {\r\n              value: percentage.toFixed(digits) * 1\r\n          });\r\n    },\r\n\r\n    /**\r\n     * 计算相对容器的偏移距离\r\n     *\r\n     * @param { Number } x - X 坐标\r\n     * @param { Number } offset - 偏移量\r\n     * @param { Number } maxVal - 在 maxVal 范围内求百分比\r\n     */\r\n    _computeOffset(x, offset, maxVal) {\r\n        const { width } = this.data.containerInfo;\r\n\r\n        // 底层保证一定精度\r\n        return (((x - offset) / width) * maxVal).toFixed(4) * 1;\r\n    },\r\n\r\n    /**\r\n     * 边界处理\r\n     * @param { Number } num - 待处理的最值\r\n     * @param { Number } maxNum - num 最大值\r\n     * @param { Number } minNum - num 最小值\r\n     */\r\n    _boundaryHandler(num, maxNum = 100, minNum = 0) {\r\n        return num > maxNum ? maxNum : (num < minNum ? minNum : num);\r\n    },\r\n});<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{percentage}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ 当我们点击到百分百时，滑块超出原先设定的容器宽度。超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量：Component({\r\n    // ...\r\n    data: {\r\n        // other data...\r\n\r\n        _blockOffset: 0,\r\n        _maxDistance: 100,\r\n    },\r\n\r\n    methods: {\r\n        // 点击进度条\r\n        tappingSlider(evt) {\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n\r\n})<!-- other code -->\r\n<view\r\n    class=\"silder-block\"\r\n    style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n></view>如此，该事件就完成啦~滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块 -> 拖动滑块 -> 释放滑块这三个步骤。因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, 随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可：Component({\r\n    methods: {\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = this.data._blockOffset;\r\n            this.data.originPercentage = this.data.percentage;\r\n\r\n            this.data._startTouchX = evt.changedTouches[0].clientX;\r\n        },\r\n\r\n        // 滑块移动\r\n        onTouchMove(evt) {\r\n            const { moving, containerInfo } = this.data;\r\n            if (!moving || !containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const {\r\n                digits,\r\n                originPos,\r\n                originPercentage,\r\n                _startTouchX,\r\n                _maxDistance\r\n            } = this.data;\r\n\r\n            // 计算偏移量\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, _startTouchX, maxVal);\r\n            }\r\n\r\n            // 实际百分比\r\n            const perc = originPercentage + computeOffset(100);\r\n            const percentage = this._boundaryHandler(perc);\r\n\r\n            // 滑块偏移度\r\n            const offset = originPos + computeOffset(_maxDistance);\r\n            const _blockOffset = this._boundaryHandler(offset, _maxDistance);\r\n\r\n            this.setData({ percentage, _blockOffset });\r\n            this.triggerEvent('change', {\r\n                value: percentage.toFixed(digits) * 1\r\n            });\r\n        },\r\n\r\n        onTouchEnd(evt) {\r\n            this.data.moving = false;\r\n        },\r\n    }\r\n})<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n        bindtouchstart=\"onTouchStart\"\r\n        bindtouchend=\"onTouchEnd\"\r\n    ></view>\r\n</view>总结以上就是滑块进度条组件的实现~ 实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 API 的差异罢了~微信代码片段, 可以直接拿来就用。2019/05/04 更新：后面又重新看了一遍，发现该组件还是有可优化的空间：操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动:<view class=\"slider-wrap\"\r\n    bindtouchstart=\"onTouchStart\"\r\n    bindtouchmove=\"onTouchMove\"\r\n    bindtouchend=\"onTouchEnd\"\r\n>\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>Component({\r\n    // other options ...\r\n\r\n    methods: {\r\n        // other method ...\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = _blockOffset;\r\n            this.data.originPercentage = percentage;\r\n\r\n            this.data._startTouchX = clientX;\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n});微信代码片段 v0.0.2"}
{"title": "小程序绑定用户方案 优化 ", "author": "Rolan", "pub_time": "2019-5-15 00:16", "content": "在做过一系列小程序之后，对小程序的登陆鉴权的流程也有一定的理解，类似于 B 端小程序自不必说，要用户信息手机号地址可以一把梭，做一个引导页面进行判断然后要求用户给与绑定，用户自然不会多说什么，毕竟这是企业级别应用。但是当涉及到 C 端小程序时候。想让用户进行绑定，就势必要给与用户便利。这里我列出一些我觉得较为不错的小程序应用方案以供参考。预先绑定类该类小程序在使用之前就需要绑定用户信息。常见于线下门店类功能性小程序。线下操作时有大量的优惠活动来支持小程序的流量。功能介绍例如 便利蜂。之前在上海经常使用，价格和优惠都非常不错，这类小程序属于线下功能类小程序，内部有抽奖，付款等一系列功能。该小程序第一次打开就先用户直接要求用户绑定信息和地址，考虑到线下门店都会有一定的店员辅助。所以该小程序的绑定操作实际上用户都是可以接受的。图片如下所示。技术要点技术1： 使用自定义导航栏让头部可以配置全局配置\"window\": {\r\n  \"navigationStyle\": \"custom\"\r\n}如果微信 app 的版本在 7.0.0之上，我们就可以使用页面级别的配置了。{\r\n  \"usingComponents\": {},\r\n  \"navigationStyle\": \"custom\"\r\n}该配置默认时default，当使用custom时候可以自定义导航，可以在头部配置 loading。第二种这个需要 app 版本，所以如果是想简化，反而在全局下定义，再使用微信官方的组件 avigation-bar 即可。技术2：使用小程序骨架屏骨架屏方案在后端不能很快给与前端数据时候采用这种方案，亦或者前端可以使用 Service Worker 把上次缓存数据返回到前端，等到从后端获取数据之后刷新页面也是一种方案，但是因为这是第一次打开小程序，所以采用骨架屏是一个很好的方法。采用 小程序骨架屏 组件，如果不需要骨架屏动画效果，可以试试直接加载图片作为骨架屏。惰性绑定类该类小程序在展示时无需绑定用户信息，但是当用户进行操作时在询问绑定。常用于线上商城等一系列无需专人引导的用户项目。功能介绍基本上线上大部分 c 端小程序都采用此做法，功能上倒是没什么可以介绍的，但是实践上却有不同做法。实践方式方式 1: 页面跳转 (京东购物)在每个需要绑定的按钮上添加跳转逻辑，如果当前小程序没有绑定，可以跳转到另外一个页面上确认授权。方式2: 按钮控制 (华为商城+)在每个需要绑定按钮上添加 open-type='getuserinfo'，后续可以根据状态变化，切换掉按钮(也可以不切换，因为第二次绑定数据不会跳出组件)。方式3: 遮罩层拦截 (抽奖助手)在需要绑定的页面添加一个 透明模态框，增加以整个页面大小的button。用fixed布局，还可以向下滚动。无论在当前页面点击任何地方都会出现需要绑定选项。组件代码：// wxml\r\n<view style=\"z-index: {{zIndex}}\" class=\"mask\">\r\n  <button open-type=\"{{ openType }}\"\r\n          bindtap=\"onClick\"\r\n          bindgetuserinfo=\"bindGetUserInfo\"\r\n          bindgetphonenumber=\"bindGetPhoneNumber\"\r\n          bindopensetting=\"bindOpenSetting\"\r\n          binderror=\"bindError\"\r\n          class=\"mask\"/>\r\n</view>\r\n\r\n// wxss\r\n.mask{\r\n  position: fixed;\r\n  top: 0;\r\n  bottom:0;\r\n  left:0;\r\n  right:0;\r\n  background-color: inherit;\r\n  opacity: 0;\r\n}然后在绑定后令 mask 消失。该方案初看起来不是那么的合适，但是仔细想想却也没什么问题，因为用户99%可能点击所需求的按钮，就算点击到按钮之间的空隙之处跳出要求绑定也没有什么问题。上面方式实际上都没有太大的问题，需要在不同场景下做最合适的选择。结语人机交互功能是决定计算机系统“友善性”的一个重要因素。读书学习时候要先把书读厚，再把书读薄，做程序也是一样，如何把系统做的复杂而更加复杂，如何让用户的体验简单而更为简单都不是那么容易的一件事。"}
{"title": "微信小程序-渐入渐出动画效果实现 ", "author": "Rolan", "pub_time": "2019-5-28 00:01", "content": "在做小程序列表展示的时候，接到了一个需求。需要在列表展示的时候加上动画效果。设计视频效果如下图：需要在进入列表页的时候，依次展示每一条卡片，在展示完成后需要隐藏掉当天之前的卡片。实现思路实现该动画效果，首先需要给每个卡片添加一个css动画。因为每个卡片的显示是有时间间隔的，以及考虑到展示完成后的隐藏效果，所以动画效果需要用js动态去添加。在看了微信开发文档后，发现微信小程序提供了Animation的一个动画对象，具体看了里面的参数后发现，是可以实现需求上的效果的。具体使用如下api:wx.createAnimation(Object object) 创建一个animation对象。最后通过动画实例的export方法导出动画数据传递给组件的 animation 属性。里面有如下参数：duration（动画持续时间，单位 ms）,timingFunction（动画的国度效果）,delay（动画延迟）创建的animation对象，本次实现过程中需要用到如下属性：Animation.export() 可以导出动画队列，export 方法每次调用后会清掉之前的动画操作。Animation.step(Object object) 表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。比如一组动画结束了，就以step()结尾Animation.translateY(number translation) 在 Y 轴平移的距离，单位为 pxAnimation.opacity(number value) 透明度 0-1的取值范围看到上面这些属性，合理使用的话，那么实现需求提到动画效果那是稳稳的。实现步骤封装一个方法，用来创建动画，并方便调用/**\r\n * 动画实现\r\n * @method animationShow\r\n * @param {that} 当前卡片\r\n * @param {opacity} 透明度\r\n * @param {delay} 延迟\r\n * @param {isUp} 移动方向\r\n */\r\n  animationShow: function (that,opacity, delay, isUp) {\r\n    let animation = wx.createAnimation({\r\n      duration: 1000,\r\n      timingFunction: 'ease',\r\n      delay: delay\r\n    });\r\n    <!--考虑到还需要隐藏掉当天之前的卡片，做如下判断来赋予不同的动画效果-->\r\n    if (isUp == 'down') {\r\n      animation.translateY(0).opacity(opacity).step().translateY(-80).step();\r\n    } else if (isUp == 'up') {\r\n      animation.translateY(0).opacity(opacity).step().translateY(-140).opacity(0).step()\r\n    } else {\r\n      animation.translateY(0).opacity(opacity).step()\r\n    }\r\n    let params = ''\r\n    params = animation.export()\r\n    return params\r\n  }, \r\n复制代码初始化每个卡片的样式首先每个卡片的位置相对于自身往Y轴平移80像素，并且把透明度设置为0。这样就可以进入页面的时候再往下平移并且让卡片逐渐显示。\r\n.init{\r\n  opacity: 0;\r\n  transform: translateY(-80px)\r\n}\r\n复制代码处理数据循环处理每一条数据，通过调用封装的方法，来获得该卡片应该拥有的动画属性for (let i = 0; i < transData.length; i++) {\r\n    if (i == 0) {\r\n      transData[i].animation = that.app.slideupshow(that, 1, 0, 'up')\r\n    } else {\r\n      transData[i].animation = that.app.slideupshow(that, 1, (i + 1) * 10, 'down')\r\n    }\r\n  }\r\n复制代码跟设计视频中的动画风格基本保持一致，美滋滋。"}
{"title": "微信小程序性能,行为收集探针实现 ", "author": "Rolan", "pub_time": "2019-6-3 09:52", "content": "​小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。​网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的运行限制基于安全考虑，小程序中不支持动态执行 JS 代码，即：不支持使用 eval 执行 JS 代码 不支持使用 new Function 创建函数​网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。小程序运行机制小程序启动小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。 小程序没有重启的概念。前台/后台状态当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有直接销毁，而是进入了后台状态；当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。小程序销毁需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）小程序会被微信主动销毁。 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。 在 iOS 上，当微信客户端在一定时间间隔内（目前是 5 秒）连续收到两次及以上系统内存告警时，会主动进行小程序的销毁，并提示用户 「该小程序可能导致微信响应变慢被终止」。 建议小程序在必要时使用 wx.onMemoryWarning 监听内存告警事件，进行必要的内存清理。小程序更新机制未启动时更新开发者在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。启动时更新小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。小程序探针开发难点与重点无法直接拦截/监听请求微信请求统一通过微信API完成 ，请求模块已被微信方封装，且小程序的运行环境不是浏览器对象，不像web应用那样重写封装很自如。三种运行环境的监控兼容性保证Android 上，js运行环境是 X5 内核iOS 上，js 运行环境是 JavaScriptCore开发工具上， j s运行环境是 nwjs（chrome内核）用户行为无法直接监听小程序逻辑层运行时无法获取DOM和BOM,无法像传统网页开发一样使用DOM事件API,无法全局监听事件.sdk需轻量小程序包大小有限制,单包最大为2M,分包情况下,不能超过8M,所以sdk需轻量数据收集量大，尽量减少性能损耗需要设计缓存池,制定上报策略不影响业务（基本需求）探针缓存池与上报策略探针收集到的数据主要分为两种,一种是基本数据,还有一种是事件特性数据.特性数据在下面关键事件中将会提到基础数据基本数据是每条上报日志都包含的数据。其中一部分,在初始化探针后就获取到，并且不会改变.这部分数据,业务相关的由用户配置,其余数据由探针内部生成或者调用wx.getSystemInfoSync API获取另一部分，随着用户行为，比如页面切换、登陆,或者环境变化,如网络变化时,将会改变.network数据通过 wx.getNetworkType 与 wx.onNetworkStatusChange获取 title部分在下面的关键事件有讲到事件特性数据![]( user-gold-cdn.xitu.io/2019/5/30/1…上报策略探针内部将会缓存对应日志,防止小程序Storage清空时,遗失数据.数据上报只要上报,就将缓存的日志清空,防止上报失败导致缓存的日志越积越多探针关键事件捕获关键事件类型改写App config对于App类主要改写config上的\"onShow\", \"onHide\", \"onError\", 'onLaunch'这几个生命周期缓存钩子函数给config上的方法挂上钩子,对config中未配置对应生命周期,加上默认生命周期回调对config包含了\"onShow\", \"onHide\", \"onError\",'onLaunch'生命周期函数,执行完原方法后再调用钩子函数启动事件(start)小程序启动,获取小程序启动场景值.重写App的config,通过onLaunch触发. 获取小程序启动场景值scene,页面路径path,页面search,通过页面路径与 __wxConfig对象获取页面title.退出到后台(pause)小程序切换到后台,重写App的config,通过onHide触发切回前台(resume)小程序从后台唤醒,获取切回小程序场景值scene.重写App的config,通过onShow触发(第一次触发onShow除外)异常捕获由于小程序的全局监听方法wx.onError只有2.1.2及以上才支持,为了兼容,需要重写App的config,通过onError触发.改写Page config这一部分与改写App config大同小异,主要看事件的获取页面停留(page_stay)onHide与onUnload时触发,获取用户在当前页面停留的时间.对于分享转发页面导致onHide触发的场景,不进行页面停留上报.页面切换(page)每次切换页面(onShow)时触发,获取当前页面路径,参数,title页面初次渲染时长页面首次打开或销毁后首次打开,页面渲染所花费的时间,重写Page的config,通过onReady触发.页面分享(share)用户分享转发页面时触发,通过重写Page的config,onShareAppMessage触发.由于页面分享会触发当前页面的onShow,onHide生命周期,为了数据准确,通过设置变量isPause来甄别.用户行为捕获由于用户行为总是与事件相关,对于事件,小程序无法直接监听dom事件,这里采取的方案是对App、Page、Component、Behavior的config进行改写,判断,判断config上的属性是否为函数,并且函数的形参是否为事件源,如果是事件源,说明该函数与用户行为现关联对于Component、Behavior只需对其config.method上的方法进行hook通过形参是否具有currentTarget属性判断当前是否为事件函数对于不存在自定义事件属性的点击事件,认定为点击事件,对于存在的,认定为自定义事件点击事件(click)由于小程序的逻辑层与渲染层是分开的,逻辑层运行在JSCore中,没有完整的浏览器对象,缺少dom与bom相关api,无法在body上设置全局的点击事件监听方法.为了实现事件的监听,探针通过改写Page 、Component和Behavior的config,对config上的所有属性进行区分,判断当前属性是否为函数,并且该函数触发时,形参上是否具有currentTargey属性来区分形参是否为事件对象,以此监听页面事件.对于tap与longpress事件,探针认定为点击事件.类型触发条件tap手指触摸后马上离开longpress手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发自定义事件(log)直接在事件函数内调用探针暴露的自定义事件上报方法会导致业务代码与探针耦合度过高.探针结合事件的监听通过在绑定了事件的小程序标签上添加自定义属性,来实现自定义事件的上报.由于事件触发时的事件源经微信内部封装过,自定义属性的获取目前只支持数据属性data-xxx的形式获取,所以在非手动调用时,可以在触发点击事件的小程序标签上增加data-event 与 data-log来添加低耦合的自定义事件代码.改写wx对象实现api事件捕获api事件(api)覆写wx对象,对wx.request方法的config进行重写,获取api(数据接口地址)、api_method(数据接口请求方式)、api_status(数据接口响应状态码)、api_response_time(数据接口响应时间(ms))、api_response_content_length (数据接口响应内容长度(byte))小程序的api基本都挂载在全局对象wx上,直接修改wx上面的属性,将会报错,直接赋值失败(小程序内部对此做出了限制)thirdScriptError \r\n sdk uncaught third Error \r\n Cannot set property request of #<Object> which has only a getter \r\n TypeError: Cannot set property request of #<Object> which has only a getter\r\n复制代码替代方案使用Object.getOwnPropertyDescriptors获取到wx对象的属性描述符,将微信对象重新赋值为空对象,循环属性描述符,判断当前描述符的键是否为request,并进行改造request属性描述符,其他情况使用Object.defineProperty方法定义属性由于for in循环获取不到Symbol类型的键,为了兼容wx对象将来引入Symbol作为wx对象键的情景,使用Object.getOwnPropertySymbols方法获取到属性描述符中的Symbol,再重新定义属性这一块代码太多了,不好截图,直接上代码吧// 重写wx.request\r\n  rewriteWxRequest() {\r\n    const that = this;\r\n    \r\n    // return \r\n    // 重写wx对象start\r\n    const descriptorObj = Object.getOwnPropertyDescriptors(wx);\r\n    let oldWx = this.oldWx = wx;\r\n    wx = {};\r\n    for (let i in descriptorObj) {\r\n      if (i === 'request') {\r\n        const desObj = descriptorObj[i];\r\n        let oldGet = desObj.get;\r\n        desObj.get = function(...args){\r\n          let oldRequest = oldGet.apply(this, args);\r\n          return function(params){\r\n            const {\r\n              url,\r\n              method = 'GET',\r\n              success = function(){},\r\n      \r\n            } = params;\r\n            // 检查API请求是否在忽略的url中\r\n            const ignoreUrls = that.conf.api_ignore_urls;\r\n            if (url && isIgnoreApi(url, ignoreUrls)) {\r\n              return oldRequest.call(this, params);\r\n            }\r\n            // 处理自定义 api url trim func\r\n            let apiTrimUrl = null;\r\n            if (that.conf.api_property_cb) {\r\n              try {\r\n                apiTrimUrl = that.conf.api_property_cb(url) || null;\r\n              } catch (e) {\r\n                apiTrimUrl = null;\r\n              }\r\n            }\r\n\r\n            const timeStamp = Date.now();\r\n            const apiData = {\r\n              api: apiTrimUrl || cutAPIUrl(url),\r\n              api_method: method.toUpperCase(),\r\n              api_status: undefined,\r\n              api_response_time: 0,\r\n              api_response_content_length: 0,\r\n            }\r\n            return oldRequest.call(this, {\r\n              ...params,\r\n              success (res) { // 成功回调\r\n                try {\r\n                  const {\r\n                    data,\r\n                    statusCode\r\n                  } = res\r\n                  apiData.api_status = statusCode;\r\n                  apiData.api_response_time = Date.now() - timeStamp;\r\n                  if (data) {\r\n                    let AB = {};\r\n                    if(typeof ArrayBuffer !== undefined) {\r\n                      AB = ArrayBuffer;\r\n                    }\r\n                    if (data instanceof AB && data.byteLength !== undefined) {\r\n                      apiData.api_response_content_length = data.byteLength;\r\n                    } else {\r\n                      if (typeof data === 'string') {\r\n                        apiData.api_response_content_length = data.length || 0;\r\n                      } else {\r\n                        apiData.api_response_content_length = JSON.stringify(data).length || 0;\r\n                      }\r\n                    }\r\n                  } else {\r\n                    apiData.api_response_content_length = 0;\r\n                  }\r\n                  that.reportApi(apiData)\r\n                } catch (e) {\r\n                  that.consoleErr(e);\r\n                }\r\n                success.call(this, res);\r\n              },\r\n            })\r\n          }\r\n        }\r\n        Object.defineProperty(wx, i, desObj)\r\n      } else {\r\n        Object.defineProperty(wx, i, descriptorObj[i])\r\n      }\r\n    }\r\n    // 对微信将来引入Symbol的情况进行兼容,防止丢失以Symbol为键的情况\r\n    if (Object.getOwnPropertySymbols && typeof Object.getOwnPropertySymbols === 'function') {\r\n      Object.getOwnPropertySymbols(descriptorObj).forEach(val => {\r\n        Object.defineProperty(wx, val, descriptorObj[val])\r\n      })\r\n    }\r\n    // 重写wx对象end\r\n  }\r\n复制代码待优化错误异常无法定位到源码目前只支持原生框架和mpvue框架,并且不能适用微信第三方插件自定义事件无法像web探针,在任意标签上添加"}
{"title": "微信小程序常用样式汇总 ", "author": "Rolan", "pub_time": "2019-6-17 00:13", "content": "小程序特点：用完即走、低频使用、性能要求低，不支持webview；以iphone6尺寸（750*1334）为视觉稿进行设计；iphone6下1px=1rpx=0.5pt     iphone6 plux下1px=0.6rpx；使用rpx，小程序会自动在不同的分辨率下进行转换，而使用px为单位不会；1.设置全局字体样式app.wxss：text{\r\nfont-family:MicroSoft yahei;\r\n}2.设置弹性盒子模型：.container{\r\n/*弹性模型*/\r\ndisplay:flex;\r\n/*垂直方向 列方向 排布*/\r\nflex-direction:column;\r\n/*居中*/\r\nalign-items:center;\r\n/*要从整体解决排布的问题是最好的方案*/\r\n}3.设置页面全屏样式及背景色：page{\r\nheight:100%;\r\nbackground:#b3d4db;\r\n}4.全局设置导航条颜色app.json：\"window\": {\r\n\"navigationBarBackgroundColor\": \"#405f80\"\r\n}5.页面设置导航条颜色和标题*.json:{\r\n\"navigationBarBackgroundColor\": \"#405f80\",\r\n\"navigationBarTitleText\":\"文与字\"\r\n}6.设置字体属性：.user-name{\r\nfont-size:32rpx;\r\nfont-weight:bold;\r\n}7.创建圆角矩形边框：.moto-container{\r\nborder:1px solid #405f80;\r\nwidth:200rpx;\r\nheight:80rpx;\r\nborder-radius:5rpx;\r\ntext-align:center;\r\n}8.外边距设置：margin-top:20rpx;\r\nmargin-bottom:40rpx;9.内边距设置：padding-bottom:20rpx;10.上、下边线设置：border-bottom:1px solid #ededed;\r\nborder-top:1px solid #ededed;11.文字间距设置：letter-spacing:2rpx;12.垂直居中（此元素放置在父元素的中部）：vertical-align: middle; 13.设置子元素Image样式：.circle-img image{\r\n    width:90rpx;\r\n    height: 90rpx\r\n}14.最底层垂直居中横线样式：.horizon{\r\n    width:660rpx;\r\n    height: 2rpx;\r\n    background-color: #e5e5e5;\r\n    vertical-align: middle;\r\n    position:relative;\r\n    top:46rpx;\r\n    margin: 0 auto;\r\n    z-index: -99\r\n}15.图片居中覆盖:.audio{\r\n    width:102rpx;\r\n    height:110rpx;\r\n    position: absolute;\r\n    left: 50%;\r\n    margin-left: -51rpx;//经典水平居中方式\r\n    top:180rpx;\r\n    margin-top: 20rpx;\r\n    opacity:0.6;//透明度\r\n}"}
{"title": "微信小程序组件化开发框架WePY ", "author": "Rolan", "pub_time": "2019-6-24 00:48", "content": "compilers： compilers为1.3.1版本之后的功能，如果需要使用其它语法，请先配置compilers，然后再安装相应的compilers。目前支持wepy-compiler-less， wepy-compiler-postcss，wepy-compiler-sass、wepy-compiler-babel、wepy-compiler-pug，其他compiler持续开发中......\r\nplugins： plugins为1.1.6版本之后的功能，目前支持js压缩wepy-plugin-ugliyjs、图片压缩wepy-plugin-imagemin，其他plugin持续开发中......\r\nlang决定了其代码编译过程，src决定是否外联代码\r\n<style lang=\"less\" src=\"page1.less\"></style>\r\n<template lang=\"wxml\" src=\"page1.wxml\"></template>\r\n<script>\r\n    // some code\r\n</script>\r\n\r\n<script>\r\nimport wepy from 'wepy';\r\nexport default class extends wepy.app {\r\n    config = {\r\n        \"pages\":[\r\n            \"pages/index/index\"\r\n        ],\r\n        \"window\":{\r\n            \"backgroundTextStyle\": \"light\",\r\n            \"navigationBarBackgroundColor\": \"#fff\",\r\n            \"navigationBarTitleText\": \"WeChat\",\r\n            \"navigationBarTextStyle\": \"black\"\r\n        }\r\n    };\r\n    onLaunch() {\r\n        console.log(this);\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n/** less **/\r\n</style>\r\n\r\n<script>\r\nimport wepy from 'wepy';\r\nimport Counter from '../components/counter';\r\n\r\nexport default class Page extends wepy.page {\r\n    config = {};\r\n    components = {counter1: Counter};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {};\r\n    onLoad() {};\r\n    // Other properties\r\n}\r\n</script>\r\n\r\n<template lang=\"wxml\">\r\n    <view>\r\n    </view>\r\n    <counter1></counter1>\r\n</template>\r\n\r\n<style lang=\"less\">\r\n/** less **/\r\n</style>\r\n\r\n<template lang=\"wxml\">\r\n    <view>  </view>\r\n</template>\r\n\r\n<script>\r\nimport wepy from 'wepy';\r\nexport default class Com extends wepy.component {\r\n    components = {};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {};\r\n    // Other properties\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n/** less **/\r\n</style>\r\n\r\nimport wepy from 'wepy';\r\n\r\n// 声明一个App小程序实例\r\nexport default class MyAPP extends wepy.app {\r\n}\r\n\r\n// 声明一个Page页面实例\r\nexport default class IndexPage extends wepy.page {\r\n}\r\n\r\n// 声明一个Component组件实例\r\nexport default class MyComponent extends wepy.component {\r\n}\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyAPP extends wepy.app {\r\n    customData = {};\r\n\r\n    customFunction ()　{ }\r\n\r\n    onLaunch () {}\r\n\r\n    onShow () {}\r\n\r\n    config = {}  // 对应 app.json 文件\r\n\r\n    globalData = {}\r\n}\r\n\r\n在Page页面实例中，可以通过this.$parent来访问App实例。\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyPage extends wepy.page {\r\n// export default class MyComponent extends wepy.component {\r\n    customData = {}  // 自定义数据\r\n\r\n    customFunction ()　{}  //自定义方法\r\n\r\n    onLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\n    onShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\n    config = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\n    data = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\n    components = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\n    mixins = [];  // 声明页面所引用的Mixin实例\r\n\r\n    computed = {};  // 声明计算属性（详见后文介绍）\r\n\r\n    watch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\n    methods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\n    events = {};  // 声明组件之间的事件处理函数\r\n}\r\n\r\n// 错误示例\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyComponent extends wepy.component {\r\n    methods = {\r\n        bindtap () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n\r\n        bindinput () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n\r\n        //错误：普通自定义方法不能放在methods对象中\r\n        customFunction () {\r\n            return 'sth.';\r\n        }\r\n    };\r\n\r\n}\r\n\r\n// 正确示例\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class MyComponent extends wepy.component {\r\n    methods = {\r\n        bindtap () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n\r\n        bindinput () {\r\n            let rst = this.commonFunc();\r\n            // doSomething\r\n        },\r\n    }\r\n\r\n    //正确：普通自定义方法在methods对象外声明，与methods平级\r\n    customFunction () {\r\n        return 'sth.';\r\n    }\r\n\r\n}\r\n\r\n/**\r\nproject\r\n└── src\r\n    ├── components\r\n    |   └── child.wpy\r\n    ├── pages\r\n    |   ├── index.wpy    index 页面配置、结构、样式、逻辑\r\n    |   └── log.wpy      log 页面配置、结构、样式、逻辑\r\n    └──app.wpy           小程序配置项（全局公共配置、公共样式、声明钩子等）\r\n**/\r\n\r\n// index.wpy\r\n\r\n<template>\r\n    <!-- 以`<script>`脚本部分中所声明的组件ID为名命名自定义标签，从而在`<template>`模板部分中插入组件 -->\r\n    <child></child>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    //引入组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        //声明组件，分配组件id为child\r\n        components = {\r\n            child: Child\r\n        };\r\n    }\r\n</script>\r\n\r\n\r\n<template>\r\n    <view class=\"child1\">\r\n        <child></child>\r\n    </view>\r\n\r\n    <view class=\"child2\">\r\n        <anotherchild></anotherchild>\r\n    </view>\r\n</template>\r\n\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            //为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题\r\n            child: Child,\r\n            anotherchild: Child\r\n        };\r\n    }\r\n</script>\r\n\r\n/**\r\nproject\r\n└── src\r\n    ├── components\r\n    |   └── child.wpy\r\n    ├── pages\r\n    |   ├── index.wpy    index 页面配置、结构、样式、逻辑\r\n    |   └── log.wpy      log 页面配置、结构、样式、逻辑\r\n    └──app.wpy           小程序配置项（全局样式配置、声明钩子等）\r\n**/\r\n\r\n// index.wpy\r\n\r\n<template>\r\n    <!-- 注意，使用for属性，而不是使用wx:for属性 -->\r\n    <repeat for=\"{{list}}\" key=\"index\" index=\"index\" item=\"item\">\r\n        <!-- 插入<script>脚本部分所声明的child组件，同时传入item -->\r\n        <child :item=\"item\"></child>\r\n    </repeat>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    // 引入child组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            // 声明页面中要使用到的Child组件的ID为child\r\n            child: Child\r\n        }\r\n\r\n        data = {\r\n            list: [{id: 1, title: 'title1'}, {id: 2, title: 'title2'}]\r\n        }\r\n    }\r\n</script>\r\n\r\n\r\n  data = {\r\n      a: 1\r\n  }\r\n\r\n  // 计算属性aPlus，在脚本中可通过this.aPlus来引用，在模板中可通过{{ aPlus }}来插值\r\n  computed = {\r\n      aPlus () {\r\n          return this.a + 1\r\n      }\r\n  }\r\n\r\n通过监听器watcher能够监听到任何属性的更新。监听器在watch对象中声明，类型为函数，函数名与需要被监听的data对象中的属性同名，每当被监听的属性改变一次，监听器函数就会被自动调用执行一次。\r\n data = {\r\n      num: 1\r\n  }\r\n\r\n  // 监听器函数名必须跟需要被监听的data对象中的属性num同名，\r\n  // 其参数中的newValue为属性改变后的新值，oldValue为改变前的旧值\r\n  watch = {\r\n      num (newValue, oldValue) {\r\n          console.log(`num value: ${oldValue} -> ${newValue}`)\r\n      }\r\n  }\r\n\r\n  // 每当被监听的属性num改变一次，对应的同名监听器函数num()就被自动调用执行一次\r\n  onLoad () {\r\n      setInterval(() => {\r\n          this.num++;\r\n          this.$apply();\r\n      }, 1000)\r\n  }\r\n\r\n\r\nprops = {\r\n    fromShopCar: Number\r\n  }\r\n\r\nprops传值\r\n静态传值为父组件向子组件传递常量数据，因此只能传递String字符串类型。\r\n在父组件template模板部分的组件标签中，使用子组件props对象中所声明的属性名作为其属性名来接收父组件传递的值。\r\n<child title=\"mytitle\"></child>\r\n\r\n// child.wpy\r\nprops = {\r\n    title: String\r\n};\r\n\r\nonLoad () {\r\n    console.log(this.title); // mytitle\r\n}\r\n\r\n\r\n// parent.wpy\r\n\r\n<child :title=\"parentTitle\" :syncTitle.sync=\"parentTitle\" :twoWayTitle=\"parentTitle\"></child>\r\n\r\ndata = {\r\n    parentTitle: 'p-title'\r\n};\r\n\r\n\r\n// child.wpy\r\n\r\nprops = {\r\n    // 静态传值\r\n    title: String,\r\n\r\n    // 父向子单向动态传值\r\n    syncTitle: {\r\n        type: String,\r\n        default: 'null'\r\n    },\r\n\r\n    twoWayTitle: {\r\n        type: String,\r\n        default: 'nothing',\r\n        twoWay: true\r\n    }\r\n};\r\n\r\nonLoad () {\r\n    console.log(this.title); // p-title\r\n    console.log(this.syncTitle); // p-title\r\n    console.log(this.twoWayTitle); // p-title\r\n\r\n    this.title = 'c-title';\r\n    console.log(this.$parent.parentTitle); // p-title.\r\n    this.twoWayTitle = 'two-way-title';\r\n    this.$apply();\r\n    console.log(this.$parent.parentTitle); // two-way-title.  --- twoWay为true时，子组件props中的属性值改变时，会同时改变父组件对应的值\r\n    this.$parent.parentTitle = 'p-title-changed';\r\n    this.$parent.$apply();\r\n    console.log(this.title); // 'c-title';\r\n    console.log(this.syncTitle); // 'p-title-changed' --- 有.sync修饰符的props属性值，当在父组件中改变时，会同时改变子组件对应的值。\r\n}\r\n\r\nwepy.component基类提供emit、$invoke三个方法用于组件之间的通信和交互\r\nimport wepy from 'wepy'\r\n\r\nexport default class Com extends wepy.component {\r\n    components = {};\r\n\r\n    data = {};\r\n\r\n    methods = {};\r\n\r\n    // events对象中所声明的函数为用于监听组件之间的通信与交互事件的事件处理函数\r\n    events = {\r\n        'some-event': (p1, p2, p3, $event) => {\r\n               console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`);\r\n        }\r\n    };\r\n    // Other properties\r\n}\r\n\r\n@表示事件修饰符，customEvent 表示事件名称，.user表示事件后缀。\r\n目前总共有三种事件后缀：\r\n.default: 绑定小程序冒泡型事件，如bindtap，.default后缀可省略不写；\r\n.stop: 绑定小程序捕获型事件，如catchtap；\r\n.user: 绑定用户自定义组件事件，通过$emit触发。注意，如果用了自定义事件，则events中对应的监听函数不会再执行。\r\n// index.wpy\r\n\r\n<template>\r\n    <child @childFn.user=\"parentFn\"></child>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy'\r\n    import Child from '../components/child'\r\n\r\n    export default class Index extends wepy.page {\r\n        components = {\r\n            child: Child\r\n        }\r\n\r\n        methods = {\r\n            parentFn (num, evt) {\r\n                console.log('parent received emit event, number is: ' + num)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n\r\n// child.wpy\r\n\r\n<template>\r\n    <view @tap=\"tap\">Click me</view>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy'\r\n\r\n    export default class Child extends wepy.component {\r\n        methods = {\r\n            tap () {\r\n                console.log('child is clicked')\r\n                this.$emit('childFn', 100)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\nslot 组件内容分发插槽\r\n在Panel组件中有以下模板：\r\n<view class=\"panel\">\r\n    <slot name=\"title\">默认标题</slot>\r\n    <slot name=\"content\">默认内容</slot>\r\n</view>\r\n在父组件中使用Panel子组件时，可以这样使用：\r\n\r\n<panel>\r\n    <view slot=\"title\">新的标题</view>\r\n    <view slot=\"content\">\r\n        <text>新的内容</text>\r\n    </view>\r\n</panel>\r\n\r\n\r\n// mixins/test.js\r\nimport wepy from 'wepy';\r\n\r\nexport default class TestMixin extends wepy.mixin {\r\n    data = {\r\n        foo: 'foo defined by page',\r\n        bar: 'bar defined by testMix'\r\n    };\r\n    methods = {\r\n    tap () {\r\n      console.log('mix tap');\r\n    }\r\n  }\r\n}\r\n\r\n// pages/index.wpy\r\nimport wepy from 'wepy';\r\nimport TestMixin from './mixins/test';\r\n\r\nexport default class Index extends wepy.page {\r\n    data = {\r\n        foo: 'foo defined by index'\r\n    };\r\n    mixins = [TestMixin ];\r\n    onShow() {\r\n        console.log(this.foo); // foo defined by index\r\n        console.log(this.bar); // bar defined by testMix\r\n    }\r\n}\r\n\r\n// mixins/test.js\r\nimport wepy from 'wepy';\r\n\r\nexport default class TestMixin extends wepy.mixin {\r\n    methods = {\r\n        tap () {\r\n            console.log('mixin tap');\r\n        }\r\n    };\r\n    onShow() {\r\n        console.log('mixin onshow');\r\n    }\r\n}\r\n\r\n// pages/index.wpy\r\nimport wepy from 'wepy';\r\nimport TestMixin from './mixins/test';\r\n\r\nexport default class Index extends wepy.page {\r\n\r\n    mixins = [TestMixin];\r\n    methods = {\r\n        tap () {\r\n            console.log('index tap');\r\n        }\r\n    };\r\n    onShow() {\r\n        console.log('index onshow');\r\n    }\r\n}\r\n\r\n\r\n// index onshow\r\n// mixin onshow\r\n// ----- when tap\r\n// index tap\r\n// mixin tap\r\n\r\n\r\nimport wepy from 'wepy';\r\n\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        // this is not allowed before super()\r\n        super();\r\n        // 拦截request请求\r\n        this.intercept('request', {\r\n            // 发出请求时的回调函数\r\n            config (p) {\r\n                // 对所有request请求中的OBJECT参数对象统一附加时间戳属性\r\n                p.timestamp = +new Date();\r\n                console.log('config request: ', p);\r\n                // 必须返回OBJECT参数对象，否则无法发送请求到服务端\r\n                return p;\r\n            },\r\n\r\n            // 请求成功后的回调函数\r\n            success (p) {\r\n                // 可以在这里对收到的响应数据对象进行加工处理\r\n                console.log('request success: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            //请求失败后的回调函数\r\n            fail (p) {\r\n                console.log('request fail: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            // 请求完成时的回调函数(请求成功或失败都会被执行)\r\n            complete (p) {\r\n                console.log('request complete: ', p);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nWePY脏数据检查流程\r\n// 原生代码:\r\n\r\nwx.request({\r\n    url: 'xxx',\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n});\r\n\r\n// WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节\r\nwepy.request('xxxx').then((d) => console.log(d));\r\n\r\n// async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKI\r\nasync function request () {\r\n   let d = await wepy.request('xxxxx');\r\n   console.log(d);\r\n}\r\n\r\n// 原生的事件传参方式:\r\n\r\n<view data-id=\"{{index}}\" data-title=\"wepy\" data-other=\"otherparams\" bindtap=\"tapName\"> Click me! </view>\r\n\r\nPage({\r\n    tapName: function (event) {\r\n        console.log(event.currentTarget.dataset.id)// output: 1\r\n        console.log(event.currentTarget.dataset.title)// output: wepy\r\n        console.log(event.currentTarget.dataset.other)// output: otherparams\r\n    }\r\n});\r\n\r\n// WePY 1.1.8以后的版本，只允许传string。\r\n\r\n<view @tap=\"tapName({{index}}, 'wepy', 'otherparams')\"> Click me! </view>\r\n\r\nmethods: {\r\n    tapName (id, title, other, event) {\r\n        console.log(id, title, other)// output: 1, wepy, otherparams\r\n    }\r\n}\r\n\r\n// 原生代码:\r\n\r\n<view> {{ message }} </view>\r\n\r\nonLoad: function () {\r\n    this.setData({message: 'hello world'});\r\n}\r\n\r\n\r\n// WePY\r\n<view> {{ message }} </view>\r\n\r\nonLoad () {\r\n    this.message = 'hello world';\r\n}\r\n\r\n// 原生代码:\r\n\r\n<!-- item.wxml -->\r\n<template name=\"item\">\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- index.wxml -->\r\n<import src=\"item.wxml\"/>\r\n<template is=\"item\" data=\"{{text: 'forbar'}}\"/>\r\n\r\n<!-- index.js -->\r\nvar item = require('item.js')\r\n\r\n// WePY\r\n<!-- /components/item.wpy -->\r\n <text>{{text}}</text>\r\n\r\n<!-- index.wpy -->\r\n<template>\r\n    <com></com>\r\n</template>\r\n<script>\r\n    import wepy from 'wepy';\r\n    import Item from '../components/item';\r\n    export default class Index extends wepy.page {\r\n        components = { com: Item }\r\n    }\r\n</script>\r\n\r\n\r\n请点赞！因为你的鼓励是我写作的最大动力！"}
{"title": "微信小程序--wx.request封装和使用 ", "author": "Rolan", "pub_time": "2019-7-3 00:31", "content": "微信小程序基础熟悉\tweb 开发的朋友可能对\taxios 情有独钟。wx.request 的二次封装api 的集中管理和使用2、配置\tbaseUrl一般情况下，项目中的\tbaseUrl 域名前缀、登录的\tcode 、\t用户信息 等都是配置在\tapp.js中//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.login({\r\n      success: res => {\r\n        if (res.code) {\r\n          this.globalData.loginCode = res.code   // 获取的code码，以进一步换取用户信息\r\n          // res: {\r\n          //   code: \"061Zltjh1sXj6s0z96hh1Z1njh1Zltj5\"\r\n          //   errMsg: \"login:ok\"\r\n          // }\r\n        } else {\r\n          console.log('登录失败！' + res.errMsg)\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    userInfo: null,\r\n    loginCode: null,\r\n    baseUrl: 'https://...'\r\n  }\r\n})\r\n复制代码3、封装\twx.request在小程序目录下建立\tutils 文件夹，并在文件夹下创建\trequest.js 文件// request.js\r\nconst request = (options) => {\r\n  return new Promise((resolve, reject) => {\r\n    const { data, method } = options\r\n    if(data && method !== 'get') {\r\n      options.data = JSON.stringify(data)\r\n    }\r\n    wx.request({\r\n      header: { 'Content-Type': 'application/json' },\r\n      ...options,\r\n      success: function(res) {\r\n        if(res.data.code === 2000) {\r\n          resolve(res.data)\r\n        } else {\r\n          reject(res.data)\r\n        }\r\n      },\r\n      fail: function(res) {\r\n        reject(res.data)\r\n      }\r\n    })\r\n  })\r\n}\r\nexport default request\r\n复制代码4、\tapi 的集中管理和使用在小程序目录下建立\tapi 文件夹，并在文件夹下创建\tuser.js 文件（文件名推荐按模块命名）用过\taxios 的朋友接下来应该会感觉很熟悉// user.js\r\nimport request from '../utils/request.js'\r\n// baseUrl也可拼接在request.js中，当有多个鉴权模块，放在这里更灵活\r\nconst baseUrl = getApp().globalData.baseUrl\r\n\r\nexport function apiLogin(data) {\r\n  return request({\r\n    url: `${baseUrl}/user/login`,\r\n    method: 'post',\r\n    data\r\n  })\r\n}\r\n\r\nexport function apiGetUserInfo() {\r\n  return request({\r\n    url: `${baseUrl}/user/userInfo`,\r\n    method: 'get'\r\n  })\r\n}\r\n\r\nexport function apiModifyUserPassword(data) {\r\n  return request({\r\n    url: `${baseUrl}/user/modifyPassword`,\r\n    method: 'put',\r\n    data\r\n  })\r\n}\r\n\r\nexport function apiLogout() {\r\n  return request({\r\n    url: `${baseUrl}/user/logout`,\r\n    method: 'delete'\r\n  })\r\n}\r\n复制代码在页面中使用// pages/login/login.js\r\nimport { apiLogin } from '../../api/user.js'\r\nPage({\r\n  onLoad: function (options) {\r\n    this.login()\r\n  },\r\n  login() {\r\n    apiLogin({\r\n      // api params\r\n    }).then(res => {\r\n      // handle success\r\n    }).catch(error => {\r\n      // handle error\r\n    })\r\n  }\r\n})\r\n复制代码5、尾言由于涉及到\tES6 语法，需要在本地设置中开启\tES6 转\tES5小程序开发过程中应注意\tthis 指向性问题。感谢浏览，若有不足之处请指正，欢迎留言探讨。"}
{"title": "当微信小程序遇上 TensorFlow：本地缓存模型 ", "author": "Rolan", "pub_time": "2019-7-3 10:08", "content": "从明天开始，我开始休年假，准备去云南逛一逛，估计这段时间又无法更新公众号，还请大家谅解。在《 当微信小程序遇上TensorFlow - tensorflow.js篇 》一文中，我介绍了在微信小程序中使用TensorFlow.js，有朋友可能注意到，小程序每次都需要从网络加载模型。虽然tensorflow.js官方声称利用了浏览器的缓存技术，并不会每次都从网络下载。但在微信小程序中，使用的是wx.request接口下载文件，测试下来发现，似乎没有缓存机制。虽然小程序号称即用即走，但每次都需要从网络下载模型，完全体现不出端推断的优点，况且深度学习模型通常也不小，通常有好几M。那我们能否将模型存储到本地呢？查阅tfjs的文档，在浏览器中，提供了几种本地存储的方式：将模型保存到浏览器的local storage，后续可以从local storage加载将模型保存到浏览器的IndexDB，然后从IndexDB加载将模型通过下载方式保存到本地，然后可以通过文件上载方式加载模型微信小程序支持两种形式的本地存储：数据缓存和本地文件。为此，我参考了 browser_files.ts 的实现，实现了微信小程序平台下的本地文件存储 mp_files.ts 。具体代码可以参考：https://github.com/mogoweb/wechat-tfjs-core实现上并没什么特别的难度，但是栽在微信小程序的坑里，爬了好几天才找到原因。具体说来就是 FileSystemManager.readFile(Object object) 这个接口，不要想当然的认为将 encoding 设为 binary ，就会返回 ArrayBuffer 类型数据，文档对 encoding 参数的说明是：指定读取文件的字符编码，如果不传 encoding，则以 ArrayBuffer 格式读取文件的二进制内容所以为了以二进制字节读取文件内容，千万不要传 encoding 参数，否则永远返回的是 string 类型数据。至于模型保存，可以参考如下代码，为此我为小程序定义了一个 mp:// 前缀：const save_model = async model => {\r\n\r\n  const saveResult = await model.save('mp://' + wx.env.USER_DATA_PATH + '/mymodel');\r\n  console.log(saveResult);\r\n}加载模型，文件路径请指定正确的json和权重文件，无需加上 mp:// 前缀：const load_model = async () => {\r\n\r\n  let model_files = [wx.env.USER_DATA_PATH + '/mymodel.json', wx.env.USER_DATA_PATH + '/mymodel.weights.bin'];\r\n  var model = await tf.loadLayersModel(tf.io.mpFiles(model_files));\r\n  return model;\r\n}示例代码可以参考：https://github.com/mogoweb/wechat-tfjs-examples需要注意的是， 微信小程序对于本地文件总大小有10M的限制 ，所以这种方法只适合比较小的模型，如果那种几十M的深度学习模型，还是尽量部署到服务器。毕竟小程序的初衷就是小巧、轻便，如果过重，就背离了小程序的设计理念。"}
{"title": "微信小程序打怪之定时发送模板消息(node版) 方二山 ", "author": "Rolan", "pub_time": "2019-7-4 00:23", "content": "背景描述小程序答题签到功能，为了促进日活，需要每天定时向当日未签到的用户推送消息提醒签到。读本篇之前最好已经了解微信关于发送模板消息的相关文档:模板消息指南模板消息服务接口说明: 作者也是第一次写小程序的定时模板消息功能，作为一个纯种前端攻城狮，可能在建表操作数据库等后端代码上有不严谨或不合理的地方，欢迎大佬们拍砖指正(轻拍)。本文以提供解决思路为主，仅供学习交流，如有不合理的地方还请留言哦。 实现思路官方限制微信小程序推送模板消息下发条件:支付 当用户在小程序内完成过支付行为，可允许开发者向用户在 7天 内推送有限条数的模板消息 （1次支付可下发3条，多次支付下发条数独立，互相不影响）提交表单 当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在 7天 内推送有限条数的模板消息 （1次提交表单可下发1条，多次提交下发条数独立，相互不影响）根据官方的规则，显然用户1次触发7天内推送1条通知是明显不够用的，比如签到功能，只有用户在前一天签到情况下才能获取一次推送消息的机会，然后用于第二天向该用户发送签到提醒。倘若用户忘记了签到，系统便失去了提醒用户的权限，导致和用户断开了联系。如何突破限制？既然用户1次提及表单可以下发1条消息通知，且多次提交下发条数独立且互不影响。 那我们可以合理利用规则，将页面绑定点击事件的按钮都用form表单 report-submit=true 包裹 buttonform-type=submit 伪装起来，收集formId，将formId存入数据库中，然后通过定时任务再去向用户发送模板消息。开发步骤后台配置消息模板微信公众平台->功能->模板消息->我的模板中添加模板消息，如下:其中模板ID和关键词需要在发送模板消息的时候用到。数据库设计建表之前，思考一下都需要存哪些数据?根据微信的发送消息接口templateMessage.send可知，要给用户发送一条消息需要将touser(即用户的openid),form_id需要存入数据库。 另外获取用户form_id时的expire(过期时间)也需要存下来，另外还需要知道form_id是否使用以及过期的状态需要存一下。于是表的结构为:表: wx_save_form_idsqlCREATE TABLE `wx_save_form_id` (\r\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\r\n  `open_id` char(100) NOT NULL DEFAULT '',\r\n  `user_id` int(11) NOT NULL,\r\n  `form_id` char(100) NOT NULL DEFAULT '',\r\n  `expire` bigint(20) NOT NULL COMMENT 'form_id过期时间(时间戳)',\r\n  `status` int(1) DEFAULT '0' COMMENT '0 未推送 1已推送 2 过期',\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=114 DEFAULT CHARSET=utf8;表建好了，来捋一捋逻辑:用户提交表单，将open_id,user_id(根据自身需求存此字段),form_id，expire 以及status=0插入到wx_save_form_id表中开启定时任务(比如每天10:00执行)，到固定时间查询表wx_save_form_id，拿到status=0的数据，然后再调微信的templateMessage.send接口给对应的用户发送提示信息发送完的用户将status字段更新为1，下次查询的时候讲筛选掉已发送的状态。想想是不是漏掉点什么?一条form_id的过期时间是7天，那如果过期了怎么去将状态改完已过期呢？一个解决办法是，再开一个定时任务(比如20min执行一次)，去查询哪条form_id已经过期，然后再更改状态。如果数据只存在wx_save_form_id一张表中感觉效率会很低，不方便，也不合理。于是想到再去建立一张表:表: wx_message_push_statussqlCREATE TABLE `wx_message_push_status` (\r\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) NOT NULL,\r\n  `count` int(11) NOT NULL DEFAULT '1' COMMENT '可推送消息次数',\r\n  `last_date` bigint(20) NOT NULL DEFAULT '0' COMMENT '最后一次推送消息时间',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `user_id` (`user_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;其中 user_id(根据自身需求，也可以是open_id) 用户id, count 可向用户推送消息的次数 last_date 上一次推送消息的时间，用来判断当天是否再推送再重新捋一捋逻辑:用户提交表单，将open_id,user_id(根据自身需求存此字段),form_id，expire 以及status=0插入到wx_save_form_id表中，同时将wx_message_push_status表中的count自身+1开启定时任务(比如每天10:00执行)，到固定时间查询表wx_message_push_status，通过筛选条件 count>0且last_date不为当天，拿到可以推送消息的user_id再去查询wx_save_form_id表查询条件user_id=上面拿到的，status=0, expire >= 当前时间戳，然后再调微信的templateMessage.send接口给对应的用户发送提示信息发送完的用户将status字段更新为1，下次查询的时候讲筛选掉已发送的状态。开启另一个定时任务(比如间隔20分钟执行一次)，先去查询wx_save_form_id,筛选条件status=0且exprie<当前时间戳(即未发送，且过期的数据)将筛选到的数据status改为2，且查询wx_message_push_status表对应的user_id，将count自身减1。完美结束。理清开发逻辑，就准备动手写码代码实现前端页面页面的 form 组件，属性 report-submit 为 true 时，可以声明为需要发送模板消息，此时点击按钮提交表单可以获取 formIddemo.wxml<form report-submit=\"true\" bindsubmit=\"uploadFormId\">\r\n    <button form-type=\"submit\" hover-class=\"none\" >提交</button>\r\n</form>可以将页面中的绑定事件都用form组件来伪装，换取更多的formId。注: 获取form_id必须在真机上获取，模拟器会报the formId is a mock one;demo.jsPage({\r\n    ...\r\n    uploadFormId(e){\r\n        //上传form_id 发模板消息\r\n        wx.request({\r\n            url: 'xx/xx/uploadFormId',\r\n            data: {\r\n                form_id: e.detail.formId\r\n            }\r\n        });\r\n    }\r\n    ...\r\n})服务端接口server.js //node中间层 去调底层接口async updateFormIdAction(){\r\n    /*\r\n     *我们的userId和openId是存在server端，不需从前端传回。\r\n     *不必纠结接口的实现语法，和自身框架有关。\r\n     */\r\n    const {ctx} = this;\r\n    const user = ctx.user;\r\n    const userId = user ? user.userId : '';\r\n    const loginSession = ctx.loginSession;\r\n    const body = ctx.request.body;\r\n\r\n    let openId = loginSession.getData().miniProgram_openId || '';\r\n\r\n    const result = await this.callService('nodeMarket.saveUserFormId', openId, userId, body.form_id);\r\n    return this.json(result);\r\n}底层接口以及定时任务service.js //Node 操作数据库接口const request = require('request');\r\n\r\n/*\r\n * 根据用户userId openId 保存用户的formId\r\n * 存储formId的表 wx_save_form_id\r\n */\r\nasync saveUserFormIdAction(){\r\n    const http = this.http;\r\n    const req = http.req;\r\n    const body = req.body;\r\n\r\n    //7天后过期时间戳\r\n    let expire = new Date().getTime() + (7 * 24 * 60 * 60 *1000); \r\n    const sql = `INSERT INTO wx_save_form_id (open_id, user_id, form_id, expire) VALUES(${body.openId}, ${body.userId}, ${body.formId}, ${expire}) `;\r\n    //自行封装好的mysql实例 \r\n    let tmpResult = await mysqlClient.query(sql);\r\n    let result = tmpResult.results;\r\n    if (! result || result.affectedRows !== 1) {\r\n        ...\r\n    }\r\n\r\n    await this._updateMessagePushStatusByUserId(body.userId);\r\n    return this.json({\r\n        status: 0,\r\n        message: '成功'\r\n    });\r\n}\r\n\r\n// 更新用户可推送消息次数\r\n_updateMessagePushStatusByUserId(user_id){\r\n    const http = this.http;\r\n    try{\r\n        const selectSql = `SELECT user_id, count from wx_message_push_status WHERE user_id = ${user_id}`;\r\n        let temp = await mysqlClient.query(sql);\r\n        let result = temp.results;\r\n        if(result.length){\r\n            //有该user_id的记录 则更新数据\r\n            const updateSql = `UPDATE wx_message_push_status SET count = count + 1 WHERE user_id = ${user_id}`;\r\n            await mysqlClient.query(sql);\r\n            ...\r\n        }else {\r\n            //无记录 则插入新的记录\r\n            const insertSql = `INSERT INTO wx_message_push_status user_id VALUES $(user_id)`;\r\n            await mysqlClient.query(sql);\r\n            ...\r\n        }\r\n    }catch(err){\r\n        ...\r\n    }\r\n}\r\n\r\n//发送消息的定时任务\r\nasync sendMessageTaskAction(){\r\n    const http = this.http;\r\n    const Today = utils.getCurrentDateInt(); //当天日期 返回YYYYMMDD格式 具体实现忽略\r\n    //筛选count>0 且当天没有推送过的user_id\r\n    const selectCanPushSql = `select user_id from wx_message_push_status WHERE count > 0 AND last_date != ${Today}`;\r\n    let temp = await mysqlClient.query(selectCanPushSql);\r\n    let selectCanPush = temp.results;\r\n\r\n    if(selectCanPush.length){\r\n        selectCanPush.forEach(async (record)=>{\r\n            try{\r\n                let user_id = record.user_id;\r\n                //筛选出 status = 0, 且formId未过期 且 过期时间最近的数据\r\n                const currentTime = new Date().getTime();\r\n                const getFormIdSql = `select open_id, user_id, form_id from wx_save_form_id WHERE user_id = ${user_id} AND status = 0 AND expire >= ${currentTime} AND form_id != 'the formId is a mock one' ORDER BY expire ASC`;\r\n                let getFormIdTemp = await mysqlClient.query(getFormIdSql);\r\n                //获取可用的form_id列表\r\n                let getUserFormIds = getFormIdTemp.results;\r\n                //取出第一条可用的formId记录 发送消息\r\n                const { open_id, form_id } = getUserFormIds[0];\r\n                let sendStatus = await this._sendMessageToUser(open_id, form_id);\r\n                /*\r\n                 *发送完消息之后\r\n                 * 无论成功失败 将这条form_id置为已使用 最后推送时间为当天\r\n                 * 将可发消息次数减1\r\n                 */\r\n                let updateCountSql = `UPDATE wx_message_push_status SET count = count - 1, last_date = ${Today} WHERE count >0 AND user_id = ${user_id}; ` ;\r\n                await mysqlClient.query(updateCountSql);\r\n\r\n                let updateStatusSql = `UPDATE wx_save_form_id SET status = 1 WHERE user_id = ${user_id} AND open_id = ${open_id} AND form_id = ${form_id}`;\r\n                await mysqlClient.query(updateStatusSql);\r\n                ...\r\n            }catch(err){\r\n                ...\r\n            }\r\n        });\r\n    }\r\n    this.json({\r\n        status: 0\r\n    });\r\n}\r\n\r\n//发送模板消息\r\n_sendMessageToUser(open_id, form_id){\r\n    let accessToken = await this._getAccessToken();//获取token方法省略\r\n    const oDate = new Date();\r\n    const time = oDate.getFullYear() + '.' + (oDate.getMonth()+1) + '.' + oDate.getDate();\r\n    if(accessToken){\r\n        const url = `https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=${accessToken}`;\r\n        request({\r\n            url,\r\n            method: 'POST',\r\n            data: {\r\n                access_token,\r\n                touser: open_id,\r\n                form_id,\r\n                page: 'pages/xxx/xxx',\r\n                template_id: '你的模板ID',\r\n                data: {\r\n                    keyword1: {\r\n                        value: \"日领积分\"\r\n                    },\r\n                    keyword2: {\r\n                        value: '已经连续答题N天，连续答题7天有惊喜，加油～'\r\n                    },\r\n                    keyword3: {\r\n                        value: \"叮！该签到啦~锲而不舍,金石可镂。\"\r\n                    },\r\n                    keyword4: {\r\n                        value: time\r\n                    }\r\n                }\r\n            }\r\n        },(res)=>{\r\n            ...\r\n        })\r\n    }\r\n}\r\n\r\n/*\r\n * 检查wx_save_form_id表中的 expire字段是否过期，如果过期则将status 置为2 并且\r\n * 对应的 wx_message_push_status表中的count字段减1\r\n */\r\n async amendExpireTaskAction(){\r\n    let now = new Date().getTime();\r\n    try {\r\n        //筛选已经过期且未使用的记录\r\n        const expiredSql = `select * from wx_save_form_id WHERE status = 0 AND expire < ${now}`;\r\n        let expiredTemp = await mysqlClient.query(expiredSql);\r\n        let expired = expiredTemp.results;\r\n        if (expired.length){\r\n            expired.forEach(async (record)=>{\r\n                //将过期的记录状态更新我为2\r\n                const updateStatusSql = `UPDATE wx_save_form_id SET status = 2 WHERE open_id = '${record.open_id}' AND user_id = ${record.user_id} AND form_id = '${record.form_id}' `;\r\n                await mysqlClient.query(updateStatusSql);\r\n\r\n                //将推送次数减1\r\n                let updateCountSql = `UPDATE wx_message_push_status SET count = count - 1 WHERE count >0 AND user_id = ${record.user_id}; ` ;\r\n                await mysqlClient.query(updateCountSql);\r\n            });\r\n        }\r\n\r\n    }catch (e) {\r\n    }\r\n    this.json({\r\n        status: 0\r\n    });\r\n }执行定时任务发送消息呼~ 完整代码码完了。 大概思路是这样的，操作数据库没有考虑性能问题，如果数据量大会出现的问题，也没有考虑事务，索引等操作(主要是不会T_T),读者可以自行优化。最后需要开两个定时任务分别执行sendMessageTask接口和amendExpireTask接口，我们的定时任务也是找的开源的node框架，具体实现不陈述。最终效果:参考文献突破微信小程序模板消息限制，实现无限制主动推送人人贷大前端技术博客中心最后广而告之。 欢迎访问人人贷大前端技术博客中心里面有关nodejs react reactNative 小程序 前端工程化等相关的技术文章陆续更新中,欢迎访问和吐槽~上一篇: 小程序打怪之在线客服自动回复功能(node版)上上一篇: 微信小程序踩坑指南"}
{"title": "基于小程序技术栈的微信客户端跨平台实践 ", "author": "Rolan", "pub_time": "2019-7-4 00:41", "content": "https://gmtc2019.geekbang.org/presentation/1711一、前言小程序自诞生以来，经过两年多的发展，成为了微信开发者生态中最具有生命力的一环，为外部开发者开辟了全新的想象空间。然而，小程序带来的改变绝不仅限于微信之外，小程序技术栈的确立，又对微信客户端的研发产生了怎样的影响？二、微信客户端的跨平台实践微信客户端团队，早在 2012 年的时候就已经开始使用跨平台技术进行研发，从最初为了应对多平台客户端代码逻辑不统一的问题，到后续面向业务和 UI 开发，一直在尝试研发跨平台的解决方案。最早的跨平台组件是基于 C99 开发的 mmnet，在 2012 年 10 月份的时候为了解决多平台客户端出现的一系列不一致问题而打造的基础网络组件，后续经过不断的迭代优化，尤其是在应对弱网络做了深度的优化，并且加入了安全、容灾等各种网络策略。 mmnet 的通用部分逻辑代码于 2016 年以 mars 的名字在 github 开源，在业界获得了广泛的认可，完成了一个内部实验的跨平台组件到最终升华为所有人可用的开源项目 。同样在 github 受到欢迎的还有相似思路完成的 wcdb、mmkv 等跨平台组件。在完成基础组件的跨平台之后，随之而来的是面向业务和 UI 开发的跨平台尝试 。为了面对内部快速变化的创新业务，微信客户端团队不得不去寻求在多端上快速迭代的开发模式。在业务开发的过程中，能否可以做到像使用基础跨平台组件那样，只写一次代码就能在多端上得到体验一致的 UI 功能界面呢？在尝试了不同的方案之后，我们将目光放到了小程序上。 在微信小程序快速发展的两年内，各内部业务团队开始基于小程序去做创新业务的开发。借助微信小程序框架，这些业务可以获得相比于纯原生客户端开发周期短、上线快的优势，同时可以满足较强的运营需求。这种基于微信小程序的业务开发模式在内部逐渐的受到认可。我们认为好的跨平台开发模式必须要达到以下的 四个目标 ：减少平台差异性 ：应该最大限度减少不同平台上开发的差异性，尽可能减少各平台特有的开发负担；提高研发效率 ：从研发效率的角度看，在提高人效比的同时，应该尽可能提升开发人员在开发过程中的效率，包括编码、调试、运行、测试等多个环节；原生的性能和体验 ：从最终的研发产物看，应该有和分平台原生技术开发一样的性能表现和用户体验，让用户无法感知出差距；易学的可控技术栈 ：跨平台的技术栈应该具有较好的学习曲线，能够让更多原生开发的同学快速学习并掌握，且无论从技术还是商业角度看，都应该是可控、安全的技术栈。三、小程序与微信客户端 微信小程序采用了以前端技术栈为主的方案，框架上面抹平了许多平台差异性，同时业务也可以随时动态部署更新，而体验和性能也比较接近原生。随着小程序生态的发展，还出现了更多丰富的插件扩展机制、自定义组件机制和第三方开发框架。同时，小程序作为微信团队内部自主研发的框架，小程序已经是一个非常优秀的跨平台框架，满足一般的业务开发是没有问题的。然而，当我们以“小程序技术栈作为客户端跨平台开发技术”这一命题展开，关注其中的一些细节时，也发现了问题。附近的餐厅就是微信团队内部基于小程序开发的一个类似原生体验的业务。通过小程序实现了一次开发运行在 iOS、Android 两个客户端上的功能。整个开发的过程都主要以微信小程序的开发工具和开发标准为主，配合客户端实现部分额外增补能力，在基本功能完成之后我们也发现了一些在 Android 平台上出现的问题，这里举两个比较典型的例子。第一个是字体一致性体验问题。微信小程序使用 WebView 渲染，与原生客户端的是两套不同的视图渲染体系，在 Android 平台上出现了无法跟随系统字体保持一致的问题，体验上会有较为明显的割裂感。第二个在大量的图片和视频混排的场景下，会出现一些掉帧现象，在 Android 中低端机上较为明显。如下图所示，在图片滑动等连续过程中，会偶尔出现 LAG 的情况。并且受目前小程序框架所限，视频、图片的全屏显示效果也不够理想。正是因为 微信小程序框架在面对复杂业务的场景下还会存在一些体验和性能不尽人意的地方，在性能和体验上虽然 接近原生，但仍不能达到原生体验效果 ，我们决定针对这些细节尝试进行一步步的优化。先来看看小程序目前的系统架构。四、基于小程序技术栈的跨平台开发微信小程序的系统架构相信今天大部分的读者都比较熟悉了，总体来讲分为两部分：View 视图端通过小程序的框架将用户采用 WXML 和 WXSS 描述的UI信息处理成 H5 元素，最终交给 WebView 去渲染；App Service 端运行用户编写的 JavaScript 逻辑，并且可以调用具有微信开放能力的 JSAPI。逻辑和视图分离，通过事件和数据彼此之间建立联系。回到我们上面的问题， 在中低端机和稍复杂的业务上，受制于 Web 庞大而复杂的体系，要达到原生视图体系这样简单设计的体验，难度很高。 那么是否能够使用平台原生的视图渲染体系来解决问题呢？1. 基于原生渲染优化原理上我们可以将用户描述的 UI，转换成系统原生的组件，行业里面早有实践，受到 ReactNative 这类框架的启发，我们将小程序的视图端进行了一些改造，在 Android 平台上我们 dump 出小程序框架中 Virtual DOM 的信息和所有的 CSS 样式，在 Java 层逐一的去解析映射成原生的组件。但原生体系并不能完全的表达过于复杂的 CSS 样式，因此前期只支持了部分的 WXSS 特性。2. LV-CPP我们初步方案当中有太多的实现一开始是用 Java 去做的，考虑平台兼容问题，为了方便移植到其他平台以及可以更低成本的更换渲染模块，我们就将原来解析 DOM 和 CSS 样式的实现单独抽离了出来，形成一个独立的跨平台模块。最终选择了 C++ 实现的 LV-CPP 模块， 由 LV-CPP 去做跨平台的小程序 UI 体系处理器，完成 DOM 和 CSS 的解析、布局计算， 同时执行 JS 的功能由 V8 或者 JSCore 来完成。当 WXML/WXSS 描述的 UI 发生改变时，小程序前端公共库（WXA Framework）通过内部计算，将 Virtual DOM 树 Diff 的结果 以操作指令的形式提交到 LV-CPP。 LV-CPP 接收指令后，更新相应的节点，进行 CSS 的匹配、CSS 属性的转换以及布局的计算，计算好之后再调用 Native View 进行界面的渲染。CSS 匹配上，目前支持了 ID 选择器(#id)、标签选择器(button)、类选择器(.class)、组合选择器(A,B、A B、A>B、A+B、A~B)。为了提高性能，其中组合选择器的匹配使用了 WebKit 的逆序解析方案。之所以在 LV-CPP 中进行 CSS 属性的转换以及布局计算，目的是为了尽量抹平以后即使使用不同的渲染模块所带来的属性和布局上的差异。最典型的是颜色的转换。CSS 中颜色有各种表示方法，最常见的有：十六进制颜色，如：#0000ffRGB 颜色，如：rgb(0,0,255)RGBA 颜色，如：rgba(255,0,0,0.5)HSL 颜色，如：hsl(120,65%,75%)HSLA 颜色，如：hsla(120,65%,75%,0.3)颜色名，如：black这些不同种类的颜色表示方式，经过 LV-CPP 计算后输出的全部是十进制的颜色值，再交由渲染模块进行渲染。采用原生组件的方案确实在体验和性能方面能够带来不错的提升，在 Pixel 2 XL 的机器上我们测出，帧率方面比 WebView 提升了 27.5%，内存也可以下降 14%~23%。但随着我们要将该方案推广到各平台的时候，我们意识到需要在各个平台去做适配是一个巨大工作量的事情，而且后续的维护成本也将无法预测。基于 Web 的渲染满足不了性能和体验的要求，基于原生渲染又会带来高维护成本问题，我们需要一个跨平台的渲染方案来解决。 在研究各种可能的方案的时候，Flutter 再次走进了我们的视野。3. FlutterFlutter 是 Google 为跨平台打造的高性能应用框架，受到了很多同行的关注，但如果按照我们设定的微信跨平台开发的目标来看，Flutter 并不完全符合，使用 Dart 开发会对现有开发同学造成额外的学习成本，所以一开始我们并没有将 Flutter 作为客户端跨平台开发的候选。但 当我们的问题重新设定为“寻找一个跨平台的高性能渲染框架”时，Flutter 就逐渐体现出了各项优势 。从一些经典的 Benchmarks 案例中看到，Flutter 具有非常不错的性能水平。这组数据是我们在 ARM 平台测出的 Java，Dart JIT 和 Dart AOT 的对比数据，数值越高表示性能越好。同时另一个有意思的情况是，随着 Flutter 版本的提升，性能表现会越来越好，也说明 Flutter 的开发人员在不断地优化性能表现。而且从 Benchmarks Game 上能获取到和 JavaScript 的一些对比数据，从中大概能得出一个结论：Dart 的语言性能是超过 JavaScript，和 Java 有得一拼的。可以看下官方对 Flutter 的介绍：快速开发：Flutter 的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。富有表现力，漂亮的用户界面：自带的 Material Design 和 Cupertino（iOS风格）widget、丰富的 motion API、平滑而自然的滑动效果。响应式框架：使用 Flutter 的现代、响应式框架，和一系列基础 widget，轻松构建您的用户界面。访问本地功能和 SDK：Flutter 可以复用现有的 Java、Swift 或 ObjC代码，访问 iOS 和 Android 上的原生系统功能和系统 SDK。统一的应用开发体验：Flutter 拥有丰富的工具和库，可以帮助开发者轻松地同时在 iOS 和 Android 系统中实现想法和创意。原生性能：Flutter 包含了许多核心的 widget，如滚动、导航、图标和字体等，这些都可以在 iOS 和 Android 上达到原生应用一样的性能。在一系列的评估基础上，我们觉得可以使用 Flutter 去尝试一下。于是我们提出了 基于 Flutter 的小程序框架渲染优化方案 。4. 基于 Flutter 渲染优化我们把渲染部分由原来的平台原生组件替换成了 Flutter 的 Widgets，依然只支持精简后的 WXML 和 WXSS。在这个架构下，我们就将 Layout 层的 LV-CPP 专门的作为小程序的 UI 体系处理器，将 UI 信息布局计算好再提交给抽象的后端去渲染，LV-CPP 作为小程序的框架和渲染器的中间层，集中的在 C++ 层去处理与 Web 相关的复杂特性。渲染端就可以基于特定的协议和接口专注将元素转化为 UI 组件，最终绘制出来。通过结合 Flutter 和 LV-CPP，我们把实现代码收敛在 C++ 和 Dart 上，进一步简化了基于小程序技术栈实现跨平台业务开发的框架维护成本。然而，真正实现的过程中我们还得做更多的思考和优化。5. 通信难题小程序的框架是使用 JavaScript 再加上一些平台注入的接口来实现的，它们是运行在 JS Engine 的环境当中。而 Layout 层是采用 C++ 来实现，如何去解决 JavaScript 和 C++ 的互相通信问题呢？LV-CPP 在 C++ 层计算好布局之后，又如何将这些信息传递给渲染后端 Flutter 的 Dart 环境中呢？要想保障框架的性能，那么我们就必须要去解决两个问题。a. JS 的通信基于 Android WebView 的体系下可以在 Java 层通过 WebView 提供的接口注入一个 JavaScriptInterface，JS 就可以得到一个扩展的 API，调用的时候经过 V8 最终反射到 Java 上面。在 iOS 上面也是类似的实现， 这种方式第一是会带来平台相关性的实现；第二是调用路径较长。所以在这个问题上，我们最终使用了 JS Binding 的方案，将原先依赖平台的实现直接下沉到 C++，去实现 JS 对象的扩展，既可以解决跨平台的问题也能带来性能的提升。b. Flutter 的通信Flutter 官方提供了一种 Platform Channel 的方案，用于 Dart 和平台之间相互通信。主要的原理就是将传递的数据编码成消息的形式，跨线程发送到平台接口层，处理之后再将返回的数据通过同样的方式原路返回。基于消息和跨线程的处理使得这种方式的通信效率并不高，我们在骁龙845的机器上测了一组数据，一秒内通过 Platform Channel 只能大概完成四千次左右的相互调用。所以我们对 Flutter Engine 进行了一些改造，增加了一个 dart2cpp 的模块，暴露出部分的 C++ 接口，使得外部的动态库可以基于这些接口通过 DartVM 调用到 dart 的接口。在 Dart 的运行环境中 C++ 和 Dart 之间就可以像调用自身的接口一样调用彼此的接口。而且 在 AOT 模式下 Dart 会被编译成机器码，所以 C++ 和 Dart 的调用会非常的高效。 不需要将数据编码成消息和跨线程一系列的复杂流程，而是直接在内存栈上操作数据 。dart2cpp 相比于 Platform Channel 的方案提升多少呢，同样的测试案例，一秒内通过 dart2cpp 可以完成三十多万次的相互调用，可以说是极大的提升了通信效率。c. dart2cpp 实现原理DartVM 提供了一种机制，可以在 Dart 的代码中使用 native 关键字来表示调用的是一个 C/C++ 的接口。// Dart 示例代码bool systemSrand(int seed) native \"SystemSrand\";但这个 C/C++ 接口必须要先注册到 DartVM 当中，不然就无法查找到符号。DART_EXPORT Dart_HandleDart_SetNativeResolver(Dart_Handle library,Dart_NativeEntryResolver resolver,Dart_NativeEntrySymbol symbol);注册可以通过 Dart_SetNativeResolver 来完成，在 Dart 的运行过程中会通过注册的 Dart_NativeEntryResolver  根据函数信息来查找到 C/C++ 的函数地址。通过以上的两步就可以在 Dart 直接调用一个扩展的 C/C++ 函数，但是还没完，Dart 的内存模型和 C/C++ 的是有区别的，Dart 调到 C/C++ 的过程中传递的参数和函数返回值都使用了一个 Dart_NativeArguments 来描述，可以通过 Dart_GetNativeArgument/Dart_SetReturnValue   这两个接口来从 Dart_NativeArguments   上获取参数和设置返回值。// C++ 示例代码void SystemSrand(Dart_NativeArguments arguments) {Dart_EnterScope();bool success = false;Dart_Handle seed_object = HandleError(Dart_GetNativeArgument(arguments, 0));if (Dart_IsInteger(seed_object)) {bool fits;HandleError(Dart_IntegerFitsIntoInt64(seed_object, &fits));if (fits) {int64_t seed;HandleError(Dart_IntegerToInt64(seed_object, &seed));srand(static_cast<unsigned>(seed));success = true;}}Dart_SetReturnValue(arguments, HandleError(Dart_NewBoolean(success)));Dart_ExitScope();}d. cpp2dart 实现原理以上介绍了 Dart 调用 C/C++ 接口的实现原理，那么在 C/C++ 如何的调用 Dart 的接口呢，别急，在 DartVM 中依然可以找到解决办法。DART_EXPORT DART_WARN_UNUSED_RESULT Dart_HandleDart_Invoke(Dart_Handle target,Dart_Handle name,int number_of_arguments,Dart_Handle* arguments);可以在 dart_api.h 中找到一系列 API ，这些 API 就可以在 C/C++ 层操作到 Dart 的接口甚至是变量。有了这些基础的 API 就基本上可以做到 Dart 和 C/C++ 之间相互调用，但你可能还需要知道一些 DartVM 的执行机制，才能让你的代码正常的 work。上面的 C/C++ 的示例代码中，使用了 Dart_EnterScope/Dart_ExitScope 这么两个 API，事实上在 C/C++ 持有的 Dart 对象都是用 Dart_Handle 句柄来描述的，我们在函数内创建的很多变量都是局部变量，在离开作用域之后应该释放内存，那么 Scope 的概念就相当告诉 DartVM 当前创建的都是局部变量，在 ExitScope 之后应该回收这里用到的内存。当然还有一个重要的概念是 Isolate，Dart 的代码是运行在一个独立的 Isolate 当中的，在 Flutter 的体系当中，这个主 Isolate 一般是寄生在 UI Runner 的线程中，在 C/C++ 去调用 Dart 的接口必须要在 Isolate 的环境当中，不然就会出现各种异常。这里就涉及到非常多细节以及繁琐的 API 调用的问题，对一般的开发者开讲他只是要去调用一个外部的接口而已，可能不了解这些具体的技术细节，因此我们才开发了 dart2cpp 这么一套东西，使得开发者能够正常的写 Dart 和 C/C++ 的代码，不需要去关注数据如何的传递、Scope 以及 Isolate 这些细节。而且我们也不希望最终业务的动态库和 Flutter Engine 的动态库是绑定在一起的，它们可以是相互独立的动态库，在需要用到的时候，只需要通过 Dart 的接口去加载这个动态库，然后动态库将自己的信息注册到 Flutter Engine 当中，就可以做到 Dart 和外部动态库之间的 C/C++ 相互调用。e. js2dart这两套解决方案呢，其实它的想象空间绝非仅此，既然 JS 可以和 C++ 相互调用，C++ 又可以和 Dart 相互调用，他们结合在一起其实就可以间接的打通 JavaScript 和 Dart。虽然 JavaScript 和 Dart 有各自的执行环境和机制，但 通过 C++ 的桥梁，依然可以构建一个高效的通道 ，中间可以通过引用和一些转换(类似 JNI)来完成大多数的调用操作和数据传递。另外，Flutter 在动态部署（Hot Patch）方面虽然没有提供官方的支持，但是在借助于 js2dart 下能够做的事情就很多了，但这并不在本文的讨论范围。至此不同语言环境中的调用通信问题有了比较高效的解决方案 。6. Flutter 渲染优化后的小程序整体架构来看一下到目前为止小程序的整体架构调整。App Service 端依然保持原有的结构，处理用户编写的 JavaScript 逻辑；而视图端（PageView）则重新划分为四个层级，除了原有的 UI DSL 描述（WXML/WXSS）、小程序前端公共库（WXA Framework）外，还有由 LV-CPP 为主的 UI 布局处理层（Layout+）和 Flutter 实现的渲染层（Renderer）。使用简化的 WXML/WXSS 描述的 UI 信息，经过小程序前端公共库处理成 DOM 描述，通过 JS Binding 接口传递给 LV-CPP去解析 CSS 和 DOM 节点（Layout+）。LV-CPP 在完成布局计算之后将元素信息通过 dart2cpp 的接口发送到 Flutter 端，Flutter Framework 层直接将布局计算好的元素描述成渲染节点，交给 Flutter Engine 去绘制。整体上来讲我们把代码收敛在 Java Script，C++ 和 Dart 上，所以在跨平台方面会极大减少额外的负担。对小程序的开发者也不会带来任何的改变，面向开发者的依然是原有的小程序技术体系。7. 从 RN-like 到 Flutter 渲染从最初的 RN-like 方案再到基于 Flutter 方案的研究，本质上都只是在不断的解决我们遇到的问题，对比 Web 的方案体验和性能也都有提升，而且在平台维护方面也得到解决。汇总 Flutter 渲染解决的问题，基本上看是能够满足我们在性能和体验上的诉求的：字体不一致问题 ：通过自定义 Flutter Engine 实现跟随系统原生视图字体；视频、地图等同层渲染 ：Flutter 官方提供了一种机制，通过 Texture Widgets 的方式将 Native 平台渲染的 Texture 同步到 Flutter 的渲染体系中来，保证同一时刻界面上仅存在一种视图体系；文本输入框性能提升 ：相比 WebView 在低端机上有可见的性能指标提升；减少重复资源投入， 多平台维护 ：基本上只需要维护 Dart 和 C++ 代码，平台相关代码可以最小化。当然， 目前阶段在性能上还存在很大的进步空间 ，相比 RN-like 方案的各项性能指标并未达到最佳，仍需要充分的发挥 Flutter 的特性，提高这套框架整体的可用性。注： 由于开发阶段方案变化较快，此处对比数据并未在同样的设备下测定，仅以相对 WebView 渲染提升为例做为说明。五、总结与展望回顾一下上下文，微信在客户端跨平台开发方案的探索从最早期的打造高质量、开源化的基础组件，到现在尝试探索大前端技术栈的业务跨平台开发方案，始终是 从提升研发团队效能和最终产品用户体验两个角度出发，去思考如何能够不断地提高移动研发技术水平 。 如果把我们的视线重新拉回来这一根本出发点，今天我们所分享的渲染方案也并不一定是小程序技术栈作为跨平台开发的唯一优化方案选择 。WebView 渲染真的无法有突破性提升？跨平台开发只有大前端技术选择？随着大前端技术不断的发展和深入，相信未来一定会继续出现新的技术方案去解决现有研发流程中的问题，也欢迎大家继续关注我们的最新进展。Q & A在 GMTC 2019 大会分享结束后，我们陆续收到了很多同学提出的疑问，这里也统一整理了一些具有代表性的问题统一回答。Q1. 小程序在产品上是否会有什么改变？是否会放弃 WebView 渲染转向 Flutter 渲染？A1. 微信小程序是一个独立的生态和产品，使用 WebView 渲染具有极大的灵活性和前端兼容性，不会放弃 WebView 渲染。目前我们的尝试仅限于微信客户端内部部分场景使用，对微信小程序的外部开发者不会有任何影响。Q2. 使用 Flutter 渲染的这套方案在遇到复杂 CSS 属性的时候表现如何？A2. 过于复杂的 CSS 属性，我们不会支持。当前在 LV-CPP 上支持的 CSS 是一个比较小的子集（我们内部称之为 “WXSS-LITE”），从性能和复杂度角度去看，也不会支持完整 CSS 属性。针对内部开发的业务来说，会根据性能、支持的复杂度和必要性等方面综合决定是否纳入 WXSS-LITE 支持范围，即也有可能大幅限制内部开发同学能够使用的 CSS 属性。Q3. js2dart 模块是否支持传递对象和自定义数据，是否考虑开源或者开放出来供大家使用？A3. JS 和 Dart 都有各自的执行机制和对象模型，所以是无法直接的传递对象的，事实上也不需要，但是可以借助于引用或者其他的数据结构来解决对象映射的问题，以及自定义的数据结构也可以在一定的协议之上来完成，甚至可以基于共享内存的方案来传递大块的数据都没有问题。 开放使用方面，我们也在考虑，但具体的方式还在讨论中，希望我们的解决方案能够为广大的开发者带来更广阔的想象空间。Q4. iOS 端接入会带来包大小的变化，以及无法 Hot Patch，你们对 iOS 的接入是怎么做的？A4. 我们最初是从 Android 平台去切入的，iOS 的接入会晚一点，根据我们实际的调研情况来看呢，iOS 的同学对开发工具、包大小、动态性等都比较关注，后续我们也准备在这些方面去做一些研究，和 iOS 的同学一起来探讨出一些解决方案，也希望大家积极的拥抱新技术，在社区当中分享自己的解决方案。但无论怎么讲，我们使用新技术的目的是为了解决我们遇到的问题，只要是对我们有益的技术，我们一定会持续的跟进。"}
{"title": "如何两步完成一个抽奖小程序 ", "author": "Rolan", "pub_time": "2019-7-4 00:49", "content": "前言\r\n这是一个简单的抽奖+闹钟小程序，起源于本人不想去上课又觉得心里有愧(大学生懂得都懂)，干脆做一个抽奖系统，让系统帮我决定是否去上课\r\n\r\n作者是一名在校大学生兼前端小白，刚开始学习前端，这个小程序算是一个巩固练手项目吧，若文章中有错误的地方欢迎指正\r\n\r\n描述\r\n我的想法是把页面分为首页和闹钟页，首页实现点击按钮随机抽取一个选项 根据所选中的选项弹出相应的提示框，若选中的选项为时间，则跳转到闹钟页，闹钟页开始倒计时，时间到了之后播放闹铃并弹出提示框，下面让我们开始吧\r\n第一步\r\n页面\r\n页面方面比较简单，首页就是把九张图片以九宫格的形式放置，这里直接贴上代码\r\nindex.html\r\n<view class=\"container\">\r\n  <view class='frame_view'>\r\n    <view class='frame_row'>\r\n      <image class='frame_item' style='opacity:{{color[0]}}' src='{{images[0]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[1]}}' src='{{images[1]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[2]}}' src='{{images[2]}}'></image>\r\n    </view>\r\n    <view class='frame_row'>\r\n      <image class='frame_item' style='opacity:{{color[7]}}' src='{{images[7]}}'></image>\r\n      <image class='frame_item' src='{{btnconfirm}}' bindtap='{{clickLuck}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[3]}}' src='{{images[3]}}'></image>\r\n    </view>\r\n    <view class='frame_row'>\r\n      <image class='frame_item' style='opacity:{{color[6]}}' src='{{images[6]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[5]}}' src='{{images[5]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[4]}}' src='{{images[4]}}'></image>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码这时我们的页面应该是这样的\r\n\r\n\r\n闪电代表的是立即去上课， 微笑代表的是不去上课，Iconfont里找的图属实有点抽象 \r\n\r\n\r\n值得注意的是这里把图片的透明度和地址都放在了一个数组里，方便后面实现轮播的功能，初始数据为\r\n\r\ndata: {\r\n    color: [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5],\r\n    images: ['/images/likequ.png', '/images/fiveminutes.png', '/images/thirtyminutes.png', '/images/likequ.png', '/images/onehour.png', '/images/fiveminutes.png', '/images/likequ.png', '/images/buqu.png'],\r\n    btnconfirm: '/images/dianjichoujiang.png',\r\n    clickLuck: 'clickLuck',\r\n    luckPosition: 0\r\n  },\r\n复制代码第二步\r\n开始抽奖\r\n\r\n在此之前先在app.js中定义全局变量\r\n\r\nglobalData: {\r\n  number: 0,\r\n  numbers: 0,\r\n  remainTime: 0\r\n}\r\n复制代码点击开始抽奖之后设置按钮为不可点击，并生成一个1-7的随机数，根据生成的随机数改变图片的透明度实现抽中效果，之后把全局变量传给闹钟页面\r\nindex.js\r\nclickLuck() {\r\n    let self = this\r\n    self.setData({\r\n      btnconfirm: '/images/bunengdianji.png',\r\n      clickLuck: '',\r\n      luckPosition: parseInt(Math.random()*8)\r\n    })\r\n\r\n    clearInterval(interval)\r\n    let index = 0\r\n    interval = setInterval(() => {\r\n      if (index > 7) {\r\n        index = 0\r\n        self.data.color[7] = 0.5\r\n      } else if (index !=0) {\r\n        self.data.color[index-1] = 0.5\r\n      }\r\n      self.data.color[index] = 1\r\n      self.setData({\r\n        color: self.data.color\r\n      })\r\n      index++\r\n    },intime)\r\n    setTimeout(() => {\r\n      self.stop(self.data.luckPosition)\r\n    },2000)\r\n  },\r\n  stop(which) {\r\n    let self = this\r\n    clearInterval(interval)\r\n    let current = -1\r\n    let color = self.data.color\r\n    for(let i=0;i<color.length;i++) {\r\n      if(color[i] == 1) {\r\n        current = i\r\n      }\r\n    }\r\n    let index = current + 1\r\n    self.stopLuck(which, index, intime, 10)\r\n  },\r\n  stopLuck(which, index, time, splittime) {\r\n    let self = this\r\n    let color = self.data.color\r\n    setTimeout(() => {\r\n      if(index > 7) {\r\n        index = 0\r\n        color[7] = 0.5\r\n      } else if (index != 0) {\r\n        color[index - 1] = 0.5\r\n      }\r\n      color[index] = 1\r\n      self.setData({\r\n        color\r\n      })\r\n      if (time < 400 || index != which) {\r\n        splittime++\r\n        time +=splittime\r\n        index++\r\n        self.stopLuck(which, index, time, splittime)\r\n      } else {\r\n        setTimeout(() => {\r\n          if (which == 0 || which == 3 || which == 6) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '别偷懒，立刻去上课',\r\n              showCancel: false,\r\n              success(res) {\r\n                self.setData({\r\n                  btnconfirm: '/images/dianjichoujiang.png',\r\n                  clickLuck: 'clickLuck'\r\n                })\r\n                self.loadAnimation()\r\n              }\r\n            })\r\n          } else if (which == 1 || which == 5) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '五分钟后再去上课，点击确定开始计时',\r\n              showCancel: false,\r\n              success(res) {\r\n                wx.switchTab({\r\n                  url:\"/pages/clock/clock\",\r\n                  success: function(res) {\r\n                    getApp().globalData.number = 1;\r\n                    getApp().globalData.numbers = 1;\r\n                    getApp().globalData.remainTime = 300000;\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } else if (which == 2) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '三十分钟后再去上课，点击确定开始计时',\r\n              showCancel: false,\r\n              success(res) {\r\n                wx.switchTab({\r\n                  url:\"/pages/clock/clock\",\r\n                  success: function(res) {\r\n                    getApp().globalData.number = 2;\r\n                    getApp().globalData.numbers = 2;\r\n                    getApp().globalData.remainTime = 1800000;\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } else if (which == 4) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '一小时后再去上课，点击确定开始计时',\r\n              showCancel: false,\r\n              success(res) {\r\n                wx.switchTab({\r\n                  url:\"/pages/clock/clock\",\r\n                  success: function(res) {\r\n                    getApp().globalData.number = 3;\r\n                    getApp().globalData.numbers = 3;\r\n                    getApp().globalData.remainTime = 3600000;\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } else {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '今天有点累，就不去上课了吧',\r\n              showCancel: false,\r\n              success(res) {\r\n                self.setData({\r\n                  btnconfirm: '/images/dianjichoujiang.png',\r\n                  clickLuck: 'clickLuck',\r\n                })\r\n                self.loadAnimation()\r\n              }\r\n            })\r\n          }\r\n        },1000)\r\n      }\r\n    },time)\r\n  },\r\n复制代码现在一个简单的抽奖功能已经完成了，让我们看下效果\r\n\r\n轮播\r\n\r\n接下来让我们实现一下轮播的效果，就像小时候玩的老虎机一样，当没有人在玩的时候，它会自动转动\r\nloadAnimation() {\r\n    let self = this\r\n    let index = 0\r\n    interval = setInterval(() => {\r\n      if (index > 7) {\r\n        index = 0\r\n        self.data.color[7] = 0.5\r\n      } else if (index !=0) {\r\n        self.data.color[index-1] = 0.5\r\n      }\r\n      self.data.color[index] = 1\r\n      self.setData({\r\n        color: self.data.color\r\n      })\r\n      index++\r\n    },100)\r\n  }\r\n复制代码把它放入onLoad生命周期中，这样抽奖页面就完成了\r\n闹钟页面\r\nclock.html\r\n<view class=\"container\">\r\n\t\t<view class=\"clock\">\r\n\t\t\t<view>{{listData[0].countDown}}</view>\r\n\t\t</view>\r\n\t\t<view wx:if=\"{{number == 0}}\">\r\n\t\t\t<botton class=\"btn\" loading=\"{{loading}}\" disabled=\"{{disabled}}\" bindtap=\"primary\">点击抽奖</botton>\r\n\t\t</view>\r\n\t\t<view wx:if=\"{{number != 0}}\">\r\n\t\t\t<botton class=\"btn\" loading=\"{{loading}}\" disabled=\"{{disabled}}\" bindtap=\"primary_fq\">放弃计时</botton>\r\n\t\t</view>\r\n</view>\r\n复制代码初始数据为\r\ndata: {\r\n    number: 0,\r\n    numbers: 0,\r\n    listData: [\r\n      {\r\n        id: 0,\r\n        remainTime: 0\r\n      }\r\n    ]\r\n  },\r\n复制代码倒计时\r\n这里的思路是根据首页传回来的数据用定时器对数组进行减少处理\r\nsetCountDown () {\r\n    let time = 1000;\r\n    let { listData } = this.data;\r\n    let list = listData.map((e) =>{\r\n      if (e.remainTime <= 0) {\r\n          e.remainTime = 0;\r\n      }\r\n      let formatTime = this.getFormat(e.remainTime);\r\n      e.remainTime -= time;\r\n      e.countDown = `${formatTime.mm}:${formatTime.ss}`;\r\n      if (e.remainTime == 0) {\r\n        wx.playBackgroundAudio({\r\n          dataUrl: '/images/naozhong.mp3',\r\n          title: '闹钟',\r\n          coverImgUrl: ''\r\n        })\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '时间到啦!',\r\n          showCancel: false,\r\n          success(res) {\r\n            wx.pauseBackgroundAudio()\r\n          }\r\n        })\r\n      }\r\n      return e;\r\n    })\r\n    this.setData({\r\n        listData: list\r\n    });\r\n    setTimeout(this.setCountDown, time);\r\n  },\r\n复制代码\r\ngetFormat()是一个格式化时间的函数\r\n\r\ngetFormat (msec) {\r\n    let ss = parseInt(msec / 1000);\r\n    let ms = parseInt(msec % 1000);\r\n    let mm = 0;\r\n    let hh = 0;\r\n    if (ss > 60) {\r\n      mm = parseInt(ss / 60);\r\n      ss = parseInt(ss % 60);\r\n      if (mm > 60) {\r\n        hh = parseInt(mm / 60);\r\n        mm = parseInt(mm % 60);\r\n      }\r\n    }\r\n    ss = ss > 9 ? ss : `0${ss}`;\r\n    mm = mm > 9 ? mm : `0${mm}`;\r\n    hh = hh > 9 ? hh : `0${hh}`;\r\n    return { ms, ss, mm, hh };\r\n  }\r\n})\r\n复制代码完整效果图\r\n\r\n当时间到了的时候\r\n\r\n总结\r\n这只是我临时兴起的一个小项目，如果你觉得还不错，不妨给个赞鼓励下，您的鼓励是我前进的动力。\r\n最后奉上源码。"}
{"title": "我的第一个小程序：小程序与SEO ", "author": "Rolan", "pub_time": "2019-7-5 00:02", "content": "在之前的文章里，我曾提到小程序是C/S程序，而SEO的基本要求是B/S程序，需要网页做SSR(服务端渲染)，这样才能让爬虫通过简单的HTTP请求获得网页内容，然后根据内容生成索引，最终通过搜索引擎向用户呈现搜索结果，那么在小程序里如何做SEO呢？今天我们就来聊一聊微信小程序里的SEO。从技术角度看，SEO本质上是让用户在搜索引擎中输入关键词直接触达网站更多的次级页面，通常这些次级页面被称为Search Landing Page(简称SLP)。我们先来看看小程序的页面在微信App中的逻辑结构图：从上图我们可以看到，整个微信App是一颗树:evergreen_tree:，而每个小程序是其中的一个树干，小程序中的内页就是这颗树的叶子，那么想要直接触达这片叶子的路径就是：微信 > 小程序 > MiniApp > page\r\n复制代码这点与我们在规划Web站点SEO时基本一样。有了路径接下来就是检查该路径下是否存在内容，此时就需要渲染该路径所对应的小程序页面。尽管小程序是C/S程序，即客户端渲染，但是它寄身在微信App内，所使用的渲染引擎和脚本解释引擎均由微信提供，所以实现对小程序内页的渲染与爬取对微信来说并不是问题。通过对小程序内页的爬取和渲染，再针对爬取结果建立搜索索引，最后通过微信搜索将这些内容呈现给用户，俨然一个微信搜索王国就诞生了。举个栗子，通过下面的链接就可直接触达我小程序的内页：// 小程序链接如下： pages/detail/detail.html?id=5d0f58995d5cfb047c5676bc 到这里，已经基本讲完微信小程序搜索的实现。接下来我们看看微信里对搜索爬虫的相关规范：打开小程序的源代码，我们发现在代码的根目录下有这样的一个文件：// 文件：sitemap.json\r\n{\r\n  \"desc\": \"风清洋\",\r\n  \"rules\": [{\r\n  \"action\": \"allow\",\r\n  \"page\": \"*\"\r\n  }]\r\n}\r\n复制代码在这个文件里定义了微信搜索的爬虫协议，下面引用微信官方的文档来说明一下该文件的意义：微信现已开放小程序内搜索，开发者可以通过 sitemap.json 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。 爬虫访问小程序内页面时，会携带特定的 user-agent：mpcrawler 及场景值：1129。需要注意的是，若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。关于微信小程序的爬虫说明，官方文档只有这一篇，十分地简单，而做过SEO的同学可能会产生诸多疑问，比如：站点地图如何提交页面死链如何处理站内链接如何建设站外链接如何获得页面内容如何语义化是否存在索引沙盒如何防止作弊...诸般疑问，从目前微信官方提供的文档还没有看到更多说明，我猜测微信还没有想好怎么做，毕竟它不是做搜索起家，很多基础设施还不完善，只能多一些耐心等待微信去解决了。在一个新的市场刚刚建立的时候，有很多新机会诞生，以前熟悉网站SEO的人肯定明白我的意思。当然作为SEO小白，专心做好内容和服务也可以在这块新的市场中分到属于你的一片蛋糕。最后，小程序SEO的裁判只有微信自己，别人无法参与竞争，赏善罚恶只能期望微信的高风亮节。参考文档： developers.weixin.qq.com/miniprogram…"}
{"title": "微信小程序自动化测试实践总结 ", "author": "Rolan", "pub_time": "2019-7-5 00:42", "content": "本文作者：IMWeb IMWeb团队 原文出处：IMWeb社区 未经同意，禁止转载一、缘起-为什么要进行小程序自动化测试微信小程序生态日益完善，很多小程序项目页面越来越多，结构越来越复杂，业务逻辑也更加多样。以腾讯课堂小程序为例，目前腾讯课堂小程序部分页面结构和不同业务场景下的表现如下图所示：可以看到在核心功能上主要页面对于不同业务场景有众多不同的表现，因此在开发与发布的过程中需要手动验证大量测试用例以保证小程序按预期表现运行，善于利用工具的程序员当然会想：这种重复的工作能不能交给程序自动进行呢？web开发中对于这类测试问题已经有了很多自动化解决方案比如Selenium、Puppeteer，思路大体相同，都是让浏览器按照指定顺序自动在页面上完成点击、输入等操作，再将操作后的页面表现与想要得到的结果进行比较得到测试结论（断言）。那小程序中有没有一种方案能够按照这种思路实现自动化操作并提供页面信息用于断言呢？为了微信底层安全考虑，小程序环境一直比较封闭，留给开发者操作的余地很小，自动化操作基本无法实现，但5月底出现了miniprogram-automator工具，给了小程序开发者希望。二、缘遇-初试miniprogram-automator基于miniprogram-automator的文档描述简单总结一下，当通过命令打开开发版微信开发者工具的自动化接口并连接自动化接口后，此工具可提供以下能力：MiniProgram：获取小程序信息（页面堆栈、系统信息、页面内容），控制小程序（跳转页面、切换tab、调用方法）Page：获取页面信息（路径、元素、数据、结构），控制页面（设置渲染数据、调用方法）Element：获取元素信息（属性、样式、内容、位置），操控元素（点击、长按、调用方法）所以小程序自动化控制的实现依赖于开发版小程序开发者工具以及miniprogram-automator工具。小程序开发者工具命令行用来打开指定自动化操作服务端口。（开发者工具版本需高于v1.02.1906042）。miniprogram-automator工具用来操作开发者工具中运行的小程序并获取所需的信息。对于测试需求可以结合jest框架进行测试用例的组织和断言。不多废话，看完文档用一下：Ø 调用开发者工具命令行打开项目与指定自动化操作服务端口PS D:\\programs\\内测\\微信web开发者工具> ./cli.bat --auto D:\\weApp\\testMiniprogram --auto-port 9420\r\nInitializing...\r\nidePortFile: C:\\Users\\billcui\\AppData\\Local\\微信开发者工具\\User Data\\Default\\.ide\r\nstarting ide...\r\nIDE server has started, listening on http://127.0.0.1:35510\r\ninitialization finished\r\nOpen project with automation enabled success D:\\keminiapp\\weapp-ke\r\n这一行命令需要注意的有：文档要求开发者工具版本号必须高于v1.02.1906042，最好是最新的内测版工具，我是在v1.03.1906062运行成功的；运行这行命令之前需要先打开开发者工具菜单中的设置->安全设置->服务端口；自动化端口是独立于服务端口的(比如终端打印出的35510其实是服务端口)，必须要看到Open project with automation enabled success D:\\keminiapp\\weapp-ke这行提示才算是成功打开了自动化端口(9420)。命令运行成功后，开发者工具会自动打开项目，并弹出提示Ø npm i miniprogram-automator --save-dev安装SDK，创建test.js，代码中引入miniprogram-automator工具，连接自动化操作端口const automator = require('miniprogram-automator');\r\n\r\nconst miniProgram = automator.connect({\r\n  wsEndpoint: 'ws://localhost:9420',\r\n})\r\nØ 利用miniprogram-automator提供的接口操作小程序从首页重启并进行相关操作const automator = require('miniprogram-automator');\r\n\r\nconst miniProgram = automator.connect({\r\n  wsEndpoint: 'ws://localhost:9420',\r\n}).then(async miniProgram => {\r\n  // 从首页重启\r\n  const page = await miniProgram.reLaunch('/pages/index/index');\r\n  // 从页面获取bottom-button组件\r\n  const button = await page.$('bottom-button');\r\n  // 打印出button的wxml信息\r\n  console.log(await button.wxml());\r\n}).catch(e => {\r\n  console.log('catch a error', e);\r\n});\r\nØ 利用miniprogram-automator获取操作后页面相关信息，利用jest进行组织和断言// index.spec.js\r\nconst automator = require('miniprogram-automator');\r\n\r\ndescribe('课堂小程序自动化测试', () => {\r\n  let miniProgram;\r\n  // 运行测试前调用\r\n  beforeAll(async () => {\r\n    miniProgram = await automator.connect({\r\n      wsEndpoint: 'ws://localhost:9420',\r\n    });\r\n  });\r\n  // 运行测试后调用\r\n  afterAll(() => {\r\n    miniProgram.disconnect();\r\n  });\r\n  // 测试内容\r\n  it('nohost检测', async () => {\r\n    const page = await miniProgram.reLaunch('/pages/index/index');\r\n    const nohostButton = await page.$('nohost');\r\n    expect(nohostButton).toBeNull();\r\n  });\r\n});\r\n运行jest index.spec.js， 如果页面中不存在nohost组件则测试通过，结果如图所示：三、缘聚-自动化测试在课堂微信小程序中的应用腾讯课堂微信小程序引入自动化测试主要是为了解决开发、预发布环境、正式环境需要反复多次打开用例课程页面，操作繁琐，耗费大量人力的问题。针对课堂小程序checklist，尽可能利用自动化测试程序完成测试验证，减少手动操作，也可以避免人为检测的遗漏。利用miniprogram-automator工具和jest框架，自动化测试主要能力为按照指定顺序模拟打开指定页面、点击、滚动等操作和设置page的data渲染数据，然后对特定的页面结构、数据、组件属性等信息进行断言，判断是否符合预期。下面以腾讯课堂微信小程序的课程详情页为例来详细说明在实际项目中如何实现自动化测试：课程详情页的UI主要分为视频部分，详情部分以及底部的购买按钮，未购买课程时付费课程详情页表现如下：假如对于未购买的无优惠活动的付费课程详情页的测试目标如下：按钮应显示“立即购买”，点击购买按钮可跳转到支付页点击试学按钮可正常播放试学视频未购买课程时点击课程视频无法播放实现这个测试，在x.spec.js文件中首先需要要按照上文的步骤引入miniprogram-automator，在beforeAll中连接已经打开自动化端口的微信小程序项目。（这里不再重复代码，见上一章）下面直接看测试内容的代码。按钮显示和点击跳转支付页测试   // 打开页面，通过url传参\r\n   const page = await miniProgram.reLaunch(`/pages/course/course?cid=${commonPayCid}`);\r\n   // 获取按钮组件信息\r\n   const basicApplyButton = await page.$('.basic--buy');\r\n   // 判断按钮显示内容\r\n   expect(await basicApplyButton.wxml()).toContain('立即购买'); \r\n   // 模拟点击按钮\r\n   await basicApplyButton.tap();\r\n   // 等待页面跳转\r\n   await page.waitFor(1500);\r\n   // 获取当前页面路径\r\n   const currentPage = await miniProgram.currentPage();\r\n   // 判断跳转后路径是否正确\r\n   expect(currentPage.path).toContain('pages/order/order');\r\n   // 跳转回来\r\n   await miniProgram.navigateBack();\r\n目前miniprogram-automator提供了两种方法获取到页面中的组件：page.$和page.$经过实验发现两者的selector支持通过组件名和类名选择组件，但对于自定义组件内部的结构，就不能直接这样拿到了。课程详情页的底部按钮其实是一个自定义组件，并且还嵌套了子自定义组件，我们看一下底部按钮的wxml结构:红色框框就是想要获取的目标，尝试一下直接通过page.$('.bottom-btn')或page.$('.buy')返回的都是undefined，那怎么获取呢？我们先来看看botton-button内部是什么样子的。const basicApplyButton = await page.$('bottom-button');\r\nconsole.log(await basicApplyButton.wxml());\r\n获取bottom-button并打印它的wxml字符串看一下：// 输出实际上是字符串，为了方便显示格式化了一下\r\n<view class=\"bottom-button--bottom-button-space\" wx:nodeid=\"17\">\r\n    <view class=\"bottom-button--bottom-button-wrapper\" wx:nodeid=\"261\">\r\n        <basic is=\"components/discount-button/components/basic/basic\" wx:nodeid=\"262\">\r\n            <view wx:nodeid=\"263\">\r\n                <view class=\"basic--bottom-button-container\" wx:nodeid=\"264\">\r\n                    <view class=\"basic--bottom-btn basic--buy\" wx:nodeid=\"265\">立即购买</view>\r\n                </view>\r\n            </view>\r\n        </basic>\r\n    </view>\r\n</view>\r\n发现了什么！小程序实际运行时，自定义组件内部的类名都加上了组件名前缀，再试试page.$('.basic--buy')发现果然成功获取到了，所以虽然表面上miniprogram-automator只能操作和获取page中的内容，但自定义组件内部的结构实际上也是以某种方式存在于page中的。接下来看一下跳转，可以直接获取到对应组件后调用.tap()方法来模拟点击，这里需要注意的是，由于微信小程序开发者工具中点击打开新页面耗时较长，需要等待页面加载一会，不然接下来获取当前页面路径的时候页面还没跳转过去就拿不到不到新页面路径了。等待的时长可以根据经验给个稍大的比较安全的值。点击试学按钮可正常播放试学视频const player_video = await tapTcplayer(page, '.player-task');\r\nexpect(await player_video.wxml()).toContain('video-current-time'); // 试学\r\n由于微信开发者工具的限制，云点播会降级为tcplayer播放，tcplayer内部的核心组件其实是<video>组件，wxml结构如下：如何判断视频是否成功播放呢？我们先按照上面的方法获取播放成功的video组件的wxml字符串看看   \"<video class=\"component-video-video--player_video\" controls=\"\" danmu-list=\"[]\" initial-time=\"0\" object-fit=\"contain\" poster=\"https://10.url.cn/qqc...\" src=\"http://113.96.98.148/vedu.tc.qq.com/AtmkzyWCuq...\" autoplay=\"\" wx:nodeid=\"446\"><div class=\"video-container\" wx:nodeid=\"447\"><div class=\"video-bar full\" style=\"opacity: 1;\" wx:nodeid=\"457\"><div class=\"video-controls\" wx:nodeid=\"458\"><div class=\"video-control-button pause\" wx:nodeid=\"459\"><div parse-text-content=\"\" class=\"video-current-time\" wx:nodeid=\"460\">00:02<div class=\"video-progress-container\" wx:nodeid=\"462\"><div class=\"video-progress\" wx:nodeid=\"463\"><div style=\"left: -21px;\" class=\"video-ball\" wx:nodeid=\"464\"><div class=\"video-inner\" wx:nodeid=\"465\"><div parse-text-content=\"\" class=\"video-duration\" wx:nodeid=\"466\">06:09<div class=\"video-fullscreen\" wx:nodeid=\"468\"><div style=\"z-index: -9999\" class=\"video-danmu\" wx:nodeid=\"453\"></video>\"\r\n惊了！原生<video>组件内部竟然是<div> ，我们还可以注意到一个关键的class: video-current-time 内部数值为00:02，这不是当前播放进度吗？刚好可以用来判断视频有没有播放成功，就是它了！对比发现播放失败时根本不会出现class为video-current-time的div，所以直接用是否包含video-current-time来判断了。未购买课程时点击课程视频无法播放点击非试看课程时，无法播放视频。由于不播放视频时页面中只显示cover封面图，不attatch<video>组件，所以直接用获取视频组件的结果进行toBeNull()判断即可。结合上面所有的代码如下：async function tapTcplayer(page, className = '.task-item') {\r\n     const taskItem = await page.$(className);\r\n     await taskItem.tap();\r\n     await page.waitFor(3000);\r\n     const playercover = await page.$('.player-cover');\r\n     const player_video = await playercover.$('.component-video-video--player_video');\r\n     return player_video;\r\n   }\r\n   it('付费课程详情页按钮显示、跳转、点播、试学功能测试', async () => {\r\n       const page = await miniProgram.reLaunch(`/pages/course/course?cid=${commonPayCid}`);\r\n       const basicApplyButton = await page.$('.basic--buy');\r\n       expect(await basicApplyButton.wxml()).toContain('立即购买'); // 按钮显示\r\n       await basicApplyButton.tap();\r\n       await page.waitFor(1500);\r\n       const currentPage = await miniProgram.currentPage();\r\n       expect(currentPage.path).toContain('pages/order/order');\r\n       await miniProgram.navigateBack();\r\n       const player_video = await tapTcplayer(page);\r\n       expect(player_video).toBeNull(); // 未报名不能播放视频\r\n       const player_video_new = await tapTcplayer(page, '.player-task');\r\n       expect(await player_video_new.wxml()).toContain('current'); // 试学\r\n     }, 20000);\r\n可以看到实际上先测试了播放课程功能，再测试了试学功能，这是为什么呢？这是一个坑：由于播放课程失败时会有showModel弹窗提示，这个弹窗是不在wxml结构中的，无法用自动化控制工具点击关闭，实际测试中这个弹窗会阻塞下一个测试项的第一步：页面跳转，导致下一个测试项直接打不开页面导致失败，只能等待一段时间再跳转，所以直接把弹窗放在测试试学功能之前，就不会影响下一个测试项了。还有一个需要注意的地方，在项目中，点击播放后5秒不触发进度刷新的方法就会上报视频播放失败，实际测试发现一般3秒即可正常播放，所以只等待3秒，3秒后未成功播放的视为播放失败。最后，jest默认一个测试项的时长不能大于5秒，这项测试既有页面跳转又有视频播放，明显会超出5秒的限制，实际耗时约为15秒左右，所以修改时长限制为20000毫秒。运行测试脚本结果如下：目前实现的测试功能如下：nohost检测首页数据拉取、显示、跳转测试付费课程详情页按钮显示、跳转、点播、试学功能测试优惠券按钮显示、领取功能测试限时优惠按钮显示测试免费课程详情页按钮显示、报名、点播功能测试分类页展示、跳转列表页、跳转详情页测试Checklist中功能测试的完成情况如下：完成度为65%review点自动化测试备注是否去除nohost插件支持首页是否正常显示支持pc首页小程序登陆是否正常暂不信息授权无法自动完成安卓支付能力是否正常暂不webview内部无法获取信息分类页是否正常显示支持是否可以正常登陆暂不信息授权无法自动完成课程表是否正常展示，学习进度/直播状态是否正常显示支持待完善课程详情页是否可以正常展示支持扫码/分享是否正常唤起小程序暂不开发者工具不支持付费课直播是否可以正常播放（上云跟腾讯视频）暂不开发者工具不支持直播免费课直播是否可以正常播放（上云跟腾讯视频）暂不开发者工具不支持直播免费课录播是否可以正常播放（上云跟腾讯视频）部分支持开发者工具降级到tcplayer付费课录播是否可以正常播放（上云跟腾讯视频）部分支持开发者工具降级到tcplayer试学任务是否可以正常播放支持详情页视频是否正常播放支持营销工具相关显示是否正常支持是否能正常完成支付逻辑暂不webview内部无法获取信息类目筛选是否正常支持待完善是否可以正常搜索且列表显示正常支持待完善本地加载耗时是否保持1s内支持四、缘续-遇到的问题与功能限制获取页面中的组件只能采用page.$()或page.$$()方法，经尝试选择器仅支持组件名和类名。无法直接获取自定义组件内部组件元素，需要在类名前增加前缀。实际项目的页面中大量使用自定义组件，对于自定义组件内部的结构判断非常不方便，只能通过wxml()方法将自定义组件内部结构打印出来才能确认内部的子组件的实际情况。且无法调用自定义组件内部的方法。Jest的snapshot功能对于结构相对固定的组件或页面是一种非常好的测试方式，但用起来有坑。在小程序中snapshot的对照内容通常是通过组件的wxml方法打印的字符串，但实际在运行时，wxml方法返回结果可能会不同，组件可能会被自动添加上wx:node-id属性，但有时返回字符串中又不添加，会导致snapshot测试不通过。目前只能在开发者工具环境下测试，导致直播功能无法测试且云点播会自动降级为腾讯视频点播，直播也无法测试。登陆、扫码等功能无法测试，因为自动化控制工具无法扫描和点击授权弹窗。<web-view>组件获取不到任何内部信息，也无法自动化控制。希望这些问题后续能够得到解决~~"}
{"title": "Taro撸一个简版的微信读书小程序 ", "author": "Rolan", "pub_time": "2019-7-5 00:51", "content": "简介：想接触一下Taro玩一下，没事就撸一个微信小程序，一直在用微信读书看书，so就模仿做个简版的微信小程序，虽然无法上线，自己在体验版玩一下数据来源：通过node爬去的在线的读书内容，或者txt下载node解析之后，通过连接云函数存储到微信的云存储下面就简单的介绍一下吧云存储数据库表user 用户表{\r\n    \"_id\":\"3b07eb945d0c9f68054ec00b042158e7\",\r\n    \"uid\":\"e43fb05a2e1fc9741ac84f560cb73bbe\", // 用户的唯一标识（可无）\r\n    \"country\":\"China\",\r\n    \"nickName\":\"姓名\",\r\n    \"status\":0.0,\r\n    \"createTime\":\"2019-06-21 05:12:07\",\r\n    \"gender\":1.0,\r\n    \"openId\":\"oI_Av5bNR627zRPDlKbITtVlaXts\", // 用户的唯一openId\r\n    \"city\":\"Haidian\",\r\n    \"province\":\"Beijing\",\r\n    \"type\":0.0, // 用户类型（备用）\r\n    \"avatarUrl\":\"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIqcBA0Hhm5pTPLnXVTKiark5XLxiaJ7WyyIrUxcG60WfROZmJ2dt7VkUbmMzaOdXcPmAnicoM25vkYA/132\",\r\n    \"language\":\"zh_CN\"\r\n}\r\n复制代码book 书列表{\r\n    _id: \"\", // 书本的唯一标识\r\n    author: '刘慈欣', // 作者\r\n    name: \"三体\", // 书本名称\r\n    cover: \"https://rep.codequn.com/novel/cover/santi2.jpg\", // 封面图\r\n    chapter: \"\",\r\n    introduction:\"《三体》（别名“地球往事”三部曲）是刘慈欣所著长篇科幻小说，讲述了地球人类文明和三体文明的信息交流、生死搏杀以及两个文明在宇宙中的兴衰历程。2015年8月，《三体小说》荣获第73届雨果奖最佳长篇小说奖 。三体小说故事发生之时，文化大革命正在如火如荼地进行，军方探寻外星文明的绝秘计划“红岸工程”取得了突破性进展，在按下发射键的那一刻，历经劫难的叶文洁没有意识到，她彻底改变了人类的命运。\",\r\n    status: 0 // 书本的状态   1：书城可查看\r\n}\r\n复制代码user_book 用户书架{\r\n    _id: \"\",\r\n    book_id: \"\", // 书的_id\r\n    openId: \"\" // 用户openId\r\n}\r\n复制代码book_catalog 书章节{\r\n    _id: \"\", // 章节_id\r\n    book_id: \"\", // 书本_id\r\n    index: 1, // 章节的位置\r\n    title: \"\",// 章节名称\r\n    type: 0 // 判断是章节还是（卷或者部）\r\n}\r\n复制代码book_catalog_info 书章节详情{\r\n    _id: \"\", // 章节详情_id\r\n    book_catalog_id: \"\", // 书本章节_id\r\n    content: \"\", // 章节的内容\r\n    title: \"\",// 章节名称\r\n}\r\n复制代码遇到的问题\r\n\r\n\r\nnode服务上传到云存储数据经常出现bug，或者上传失败的问题，内容字节比较多，很容易出现失败，最后只能分成多次上传更新数据。（备注：先获取token，然后再去链接云函数）\r\n云开发 Server API 文档\r\n\r\n\r\n云函数获取的章节列表需要多次获取，每次最多获取100条数据\r\n\r\n\r\n小程序功能有点少，后面再继续更新吧\r\n技术使用\r\nTaro\r\nColorUi组件库\r\n现在正在撸一个简单的记事本小程序"}
{"title": "小程序与小游戏获取用户信息接口调整，请开发者注意升级。 ... ", "author": "Rolan", "pub_time": "2019-7-5 10:23", "content": "最近在开发小程序的过程中，获取用户信息一直得不到预期的效果，查了一些文档最终发现wx.getUserInfo接口不能弹出授权询问框了。https://developers.weixin.qq....微信相关公告如下为优化用户体验，使用 wx.getUserInfo 接口直接弹出授权框的开发方式将逐步不再支持。从2018年4月30日开始，小程序与小游戏的体验版、开发版调用 wx.getUserInfo 接口，将无法弹出授权询问框，默认调用失败。正式版暂不受影响。开发者可使用以下方式获取或展示用户信息：一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq...."}
{"title": "移动端小程序框架面面观 ", "author": "Rolan", "pub_time": "2019-7-9 00:24", "content": "一 小程序兴起的背景小程序兴起的背景可以分为行业背景和技术背景。1. 行业背景：与移动互联网成熟、流量红利终结伴随的是 App 的巨型化、寡头化，流量成本越来越高昂，这几点其实大家平时也有体会——手机里装了多少 App，其中，多少 App 装了之后基本没使用过，占据用户大部分时间的 App 越来越集中在 3—5 款。这种趋势普通用户都能深刻的感觉到，巨头们的感觉应该更明显。各种独立 App 纷纷小程序化，表面上只是技术实现方式的变化，从深层次讲，其实是在流量越来越贵，流量资源进一步集中下的精细化分发、运营和变现。以前流量从自家过，用稀疏的大网捞一捞就能有不错的收获，现在需要上绝户网挖掘各类垂直需求和长尾需求、尽量将用户更长时间地留在自己的领地。因此，小程序就是在这种行业背景下诞生的。2. 技术背景：从技术层面来看，动态化和跨平台两大特性能显著降低开发成本，提高运营的灵活性，因而在某种程度上成为开发者（公司）天然的追求。对此业界也进行了各种尝试，从早期的轻应用到后来的各种 Hybrid 框架、RN、Weex 等跨平台框架，以及各大公司内部的各种 DIY 私有框架，乃至于 PWA，算得上百花齐放，蔚为壮观。然而，业界始终没有在性能体验、稳定性、开发人群规模、开发难度、管控安全等方面找到一个兼顾各方平衡的方案和标准，至少从国内来看，没有一种方案占据绝对优势。既然无法达成一致，那只能做减法，在一定程度上舍弃对一致性的追求，小程序就是这一减法的产物。那么具体怎么减呢？减法 1：减小范围。既然在大范围内达不成一致，那就把范围限制在有限的自留地里；减法 2：限定场景。鉴于通用标准群众基础好，人群基数大，但历史包袱重、贪大求全的情况，可以选择参考其形式，但是只取一个子集，清晰限定自己场景问题的边界，以在利用开发者基数的同时降低开发门槛。小程序总体上就是沿着这种思路诞生的，其在缩小范围、舍弃了一部分通用性之后，在所关注的其他指标上取得了比较好的平衡，下文会具体讲到。二 小程序的技术方案选型关于小程序的技术方案选型，先把结论摆出来：总体上来讲，各家小程序框架的原理大同小异，具体到某个细节方面，根据各家资源禀赋还是各有不同的。这里的总体“类似”是来源于互相借鉴、英雄所见略同，还是历史进程的作用，就不得而知了。当然，对于 BAT 等巨头而言，只要了解了原理，要做出小程序并没有太大的障碍。具体来说，各家小程序框架的原理基本都是，顶层类 Web 语法 DSL（搭配各自的前端框架），底层主要依靠 WebView 渲染，在开发者层面大体上走的还是 Web 技术栈的路子。为了提高性能体验，开发者主要采取了下面几方面的措施：其一，把 JS 剥离，运行在另一个 WebView 或者 JSCore 上，在渲染层（WebView）之外，抽出逻辑层。视图层只负责渲染，逻辑层负责网络和本地数据的读取，并通过小程序框架搭建的通道跨线程将数据发送到渲染层完成界面的绘制，同时逻辑层也负责封装宿主侧的各类能力（宿主方的登陆、支付、AI 及各种传感器接口等）为特定的 API 接口供小程序开发者使用；其二，对于重型组件，直接采用 Native 嵌入渲染；其三，框架对 WebView 的创建和前端 JS 框架的加载都进行了缓存和预加载，并且拦截了小程序的关闭，多数情况下，关闭某个小程序只是将其隐藏在导航栈中，下次重新加载该小程序时能迅速唤起。下图展示了小程序冷启动和热启动的过程：为什么采用这套技术方案呢？上文谈到了小程序诞生的技术背景，从这些内容中可以进一步推导出小程序方案的技术诉求，总结起来，小程序方案的诉求主要有下面几点：1. 体验。性能、用户体验要好，这是首要的；2. 易用。接口要清晰简单，开发者基数要大，群众基础要好，这样才能降低开发门槛，门槛低了，成本自然就低了；3. 安全。平台上规则要能被平台方控制，以保证安全及平台方自身的利益。不同的诉求组合又对应着不同的解决方法：a) 考虑 1+2：抽取传统 WebView 中和排版渲染混在一起的 JS 逻辑，在渲染用的 WebView 之外，JS 逻辑运行在独立的 JSCore（or 另一个隐藏的 WebView 上），这样 JS 的执行不阻碍排版绘制。对于重型组件，直接采用 Native 嵌入渲染，这种做法能明显提高 WebView 的流畅性。同时这种技术方案能够最大程度继承 Web 开发的技术栈，使得开发技术简便（Web 标准可以理解为现阶段各大公司都能妥协、接受的跨平台标准，经过这些年的发展，Web 技术栈人员基数大、工具成熟，标准统一），开发成本低。b) 考虑 2+3：在上述类 Web 方案的基础上套上了一个自定义的前端框架（BAT 各家小程序上层的前端方案各不相同，不过大同小异，没有本质区别），进一步将暴露给开发者的语法精简，并且规范化下来。一方面平台上的开发者能够调用的都是平台方规定好的接口，保证了安全管控；另一方面，平台方可以在其各自的前端框架下，做一些语法糖或者特色功能，提高开发效率；同时，这个隔离层的引入为后续平台方对框架底层的优化，甚至完全更换渲染方式，如采用类似游戏引擎的直接绘制渲染提供了空间（PS：业界已经有团队进行了这方面的尝试。比如支付宝团队支持用 RN 来渲染小程序，微信团队尝试在小程序底层用 Flutter 来渲染，并进行了小范围的试验。底层渲染方式更改后，上层暴露给开发者的 DSL 保持不变，开发者是无感的。鉴于这些不是目前主流的实现方式，且本文目的在于读者对于小程序的技术选型有相对大视角的了解，故不详细展开）。c) 上述 a+b 中描述的方案，同时也能满足第 3 点的要求。这是因为：其一，JS 被分离出去，不能任意操纵原来的 Dom 结构，不能获取各种浏览器对象；其二，开发者所用的框架语法、能力接口（各种端侧能力，如文件、网络、传感器等）都必须是平台方定义好暴露出来的，平台方可以控制权限的获取以决定开发者是否可以调用该接口，有完全的控制能力。总体来讲，通过上述方式，小程序被关在了笼子里，保证了平台方的控制权和安全性。下图展示了小程序整体框架原理：小程序框架暴露给开发者的内容，大体分为两类：组件及接口。组件部分主要包含各类小程序框架提供的 UI 组件，接口部分主要是包含各类宿主端侧开放接口，如登陆、支付、网络、多媒体以及对应各家资源禀赋的一些特色化能力。各家小程序的 Demo 基本上也是按照这个分类来展示的：三 小程序在技术层面的长和短当然，任何一个技术方案在获取其目标收益的同时都有其代价。上述小程序方案的代价主要有以下几点：1. 技术栈迁移的成本从整体上看，尽管小程序一定程度上借鉴了通用的 Web 标准，但毕竟只是借鉴，完全迁移过来有一定的学习成本。目前各家的小程序方案在上层都是搭配自己的前端框架，尽管都参考了流行的前端框架，但毕竟是阉割版的，且思路各有差异。此外，各家暴露给开发者的宿主侧能力接口也有一定的区别。所以小程序在总体上面临着技术栈迁移的问题。2. 数据传输同步的开销渲染层和逻辑层各自运行在完全隔离的环境里，数据和事件的同步需要序列化为文本协议流，在传输大的数据对象时开销是比较可观的。各家的开发文档里也都特意提到不要在逻辑层和渲染层之间频繁传输大量数据，以免影响性能。3. 天生的异步延时性由于小程序的逻辑层和渲染层分别运行在两个独立的环境，所以逻辑层和渲染层之间的通信是异步的，会有一定的延时。除了逻辑层和渲染层之间的通信有延时，各层与宿主客户端之间的交互同样也是有延时的。以逻辑层为例，开发者的代码是运行在逻辑层的线程上，但是客户端原生是运行在宿主线程上的，逻辑层调用相关宿主客户端的接口，实际上也是两个线程间的通信，这就意味着延时。所以小程序框架大部分接口都是异步的，这些异步通信，框架处理了一部分，保证了框架主要部分的基本时序，但是更多地留给了开发者自己处理，这增加了使用的复杂性。4. 审核的不确定性小程序的本质上是巨型 App 的应用商店化。这动了原生系统平台方的奶酪，这里的原生系统平台方既包括 App store、Google play，也包括国内各手机厂商的应用商店及各种第三方渠道，目前正在推广的快应用某种程度上可以视为后者的一种反击。就国内而言，在不同平台、尤其是苹果平台上的审核问题，为小程序的发展带来了较多不确定性。四 集成形态上各家的不同做法关于小程序的集成形态，各家采用了不同的做法，套用军事领域的比方来说就是“航母巨舰 VS 战列舰 + 空潜快”，颇有点强国海军和后起新兴国家海军之间形成对垒的意味。微信和支付宝走的是“航母巨舰”的路子，小程序集成在其体量巨大的国民应用上；百度走的是“战列舰 + 空潜快”的路子，这里的一个关键点是开源，先在自家各大型 App 铺开（战列舰），然后通过开源吸引各中小 App（空潜快）集成，组成小程序的开源联盟。在移动时代，B 家最大的焦虑是各大移动应用对它来说是死硬的黑盒子，其完全无法插足（早期的淘宝屏蔽百度是最早的一种形态），而通过小程序，百度倒是有希望打开一个缺口，因为其完全了解小程序内部的元数据信息，可以做到精准的分发。以前分发网页，对应的有站长联盟，现在分发小程序，对应的有小程序联盟。不过要把开源联盟做起来，仅凭简单的代码框架开源是远远不够的，更重要的是看利益分配机制的设计及整个商业模型的规则，毕竟接入方的流量也是需要成本的。五 小程序的迁移性和标准化严格来讲，小程序技术目前并没有做到通常意义上的标准化，这体现在开发者层面，各家上层语法及暴露的宿主侧 API 都有一定的差异。不过由于各家小程序框架的整体技术方案选型类似，所以这种差别不会给学习造成太大的障碍。而且，对于增强开发者在各不同平台之间迁移的便利性的问题，业内已经出现了一些解决方案。一方面，多数小程序玩家的后来者都提供了搬家迁移工具，能自动处理大多数语法转换类问题；另一方面，也出现了一些小程序通用框架，如 Taro、Mpvue 等，它们提供了类现代前端框架（Vue/React）的语法去开发小程序，并同时支持多个小程序平台。所以，尽管小程序还没有做到完全的标准化，但是已经达到事实上准标准化的程度，开发者在学习并为其中一种平台开发小程序之后，可以很容易的将经验和已有成果迁移到其他小程序平台。六 总结小程序技术可以认为是现阶段巨型 App 容器化、平台化、MiniOS 化的背景下，在总结业界近年来在动态化跨平台框架领域的各种方案的基础上的另一种尝试。目前看来，小程序方案较好地平衡了性能体验、开发成本、平台管控等几方面的关切，满足了巨型 App 需要一种轻量级类 Web App 技术以进行垂直和长尾领域流量分发的要求，这也是国内各大巨头先后入局小程序的主要理由。本文转载自公众号爱奇艺技术产品团队（ID：iQIYI-TP）。原文链接：https://mp.weixin.qq.com/s/uh_miREB1w8FX7mWgph56w"}
{"title": "仿小米Lite微信小程序 ", "author": "Rolan", "pub_time": "2019-7-9 00:36", "content": "事先声明，这是一个高仿小米Lite的微信小程序。我呢现在是一个大三快大四的学生，这个小程序花了我很长时间，把能写的功能基本上都写了。我秉着分享开源的心理，尽量把我写的这个小程序怎么写的，为什么这样写，详细的告诉大家。为什么是尽量？这是因为，我不太会说，可能说的不是很清楚，所以只能尽量.项目预览ok实现的效果就是这样。使用的工具easy-mokeVSCode微信小程序开发者工具( 阿里巴巴矢量图标库 )文件目录├<assets>\r\n│  ├<images>\r\n├<components>\r\n│  ├<goodList>\r\n│  ├<icon>\r\n│  ├<tabbar>\r\n│  ├<userList>\r\n├<pages>\r\n│  ├<cart>\r\n│  ├<category>\r\n│  ├<deleteGoods>\r\n│  ├<find>\r\n│  ├<goodDetails>\r\n│  ├<index>\r\n│  ├<selectGoods>\r\n│  ├<user>\r\n├<utils>\r\n│  └util.js\r\n├<weui>\r\n│  └weui.wxss\r\n├<wxapi>\r\n│  ├Api.js\r\n│  ├main.js\r\n│  └mock.js\r\n\r\n复制代码对于初学者来说，可能拿到设计图就立马写，其实这样很不好，写出来的代码会有很多重复的代码，这样不利于之后的维护。所以应该把一些公用的代码封装，之后直接调用就行了，之后维护起来也更加的方便。API封装我们前端想要获取页面的数据，就需要发送HTTP请求后端提供给我们的API接口，从API接口中获取我们想要的数据。在微信小程序中，微信官方给我们提供了一个方法 wx.request 来请求.一个程序，需要的HTTP请求会很多，如果我们每个请求都去写一个wx.request，这样写出来的代码，看起来会很冗长，他人看我们的代码时也会很累，也不利于我们之后的修改。因此为了代码的整洁，和之后的修改方便。我就把所有的API请求请求封装在wxapi文件目录下。// Api.js\r\nconst banners = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/banners'\r\n\r\nconst navdata = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/navdata'\r\n\r\nconst goodList = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/goodList'\r\n\r\nconst category = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/category'\r\n\r\nconst findData = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/findData'\r\n\r\nconst userData = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/userData'\r\n\r\nconst goodDetail = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/goodDetail'\r\n\r\nconst QQ_MAP_KEY = 'NNFBZ-6DRCP-IRLDU-VEQ4F-TXLP2-PFBEN'\r\n\r\nconst MAPURL = 'https://apis.map.qq.com/ws/geocoder/v1/'\r\n\r\nmodule.exports = {\r\n  banners,\r\n  navdata,\r\n  goodList,\r\n  category,\r\n  findData,\r\n  userData,\r\n  goodDetail,\r\n  QQ_MAP_KEY,\r\n  MAPURL\r\n}\r\n复制代码import * as MOCK from \"./mock\"\r\nimport * as API from \"./Api\"\r\nconst request = (url,mock = true,data) => {\r\n  let _url = url\r\n  return new Promise((resolve, reject) => {\r\n    if (mock) {\r\n      let res = {\r\n        statusCode: 200,\r\n        data: MOCK[_url]\r\n      }\r\n      if (res && res.statusCode === 200 && res.data) {\r\n        resolve(res.data)\r\n      } else {\r\n        reject(res)\r\n      }\r\n    } else {\r\n      wx.request({\r\n        url: url,\r\n        data,\r\n        success(request) {\r\n          resolve(request.data)\r\n        },\r\n        fail(error) {\r\n          reject(error)\r\n        }\r\n      })\r\n    }\r\n  });\r\n}\r\n// showLoading\r\nconst showLoading = () => {\r\n  wx.showLoading({\r\n    title: '数据加载中',\r\n    mask: true,\r\n  });  \r\n}\r\n// 获取地理位置\r\nconst geocoder = (lat, lon) => {\r\n  return request(API.MAPURL,false,{\r\n    location: `${lat},${lon}`,\r\n    key: API.QQ_MAP_KEY,\r\n    get_poi: 0\r\n  })\r\n}\r\nmodule.exports = {\r\n  getBanners: () => {\r\n    // return request('banners')\r\n    return request(API.banners,false)  //首页 banners \r\n  },\r\n  getNavData: () => {\r\n    // return request('navdata')\r\n    return request(API.navdata,false) //首页 navdata \r\n  },\r\n  getGoodList: () => {\r\n    // return request('goodList')\r\n    return request(API.goodList,false)  //首页 商品列表\r\n  },\r\n  getCategroy: () => {\r\n    // return request('category')\r\n    return request(API.category,false)  //分类页面\r\n  },\r\n  getFindData: () => {\r\n    // return request('findData')\r\n    return request(API.findData,false)  //发现 页面\r\n  },\r\n  getUserData: () => {\r\n    // return request('userData')\r\n    return request(API.userData,false)  // 我的 页面\r\n  },\r\n  getGoodDetail: () => {\r\n    // return request('goodDetail')\r\n    return request(API.goodDetail,false)  //商品详情\r\n  },\r\n  showLoading,\r\n  geocoder\r\n}\r\n复制代码看到这里，可能就会有一些疑问，为什么我在每个请求后面都加上了一个false？这是因为，我在写这个微信小程序开始时，没有使用easy-mock来模拟http请求数据。我是把假数据都放在mock.js文件中。然后使用 **return request('banners')**这种方式就可以获取我想要的数据。API封装完了，该怎么调用呢？我就以首页的banners数据为例// index.js \r\nconst WXAPI = require('../../wxapi/main')\r\n\r\nonLoad: function (options) {\r\n    WXAPI.showLoading()\r\n    this.getBanners()\r\n},\r\ngetBanners() {\r\n    WXAPI\r\n    .getBanners()\r\n    .then(res => {\r\n      wx.hideLoading()\r\n      this.setData({\r\n        banners: res.data\r\n      })\r\n    })\r\n},\r\n复制代码记住，如果想要发送HTTP请求数据的页面，都必须加上这一句const WXAPI = require('../../wxapi/main')定义的组件开始准备OK,现在开始写页面。第一步要写的是tabBar部分。tabBar组件看起来是不是有点奇怪，为什么有点透明的感觉？因为这个tabBar组件是我自己写的。一般来将，直接在把tabBar组件写在app.json中，就可以了。但是我觉得不是那么好看，所以就自己撸了一个tabBar组件出来。写完之后查文档才发现，微信小程序官方提供了自定义tabBar组件的方法,有需要的可以查看微信小程序文档写完这个组件后我总解了一下,需要注意的问题.选中了的当前页面，再次点击因该无效。所以我在app.js中存入了一个page属性，来存储当前页面，然后在点击事件goToPage()方法中加入判断去解决。<!--components/tabbar/tabbar.wxml-->\r\n<view class=\"tabbar\">\r\n  <!-- 首页 -->\r\n  <view class=\"shouye {{on === 'index' ? 'on': ''}}\" data-page=\"index\" bindtap=\"goToPage\">\r\n    <icon type=\"shouye\" size=\"42\" class=\"icon\" color=\"{{on === 'index' ? '#f96702': ''}}\"/>\r\n    <text >首页</text>\r\n  </view>\r\n  <!-- 分类 -->\r\n  <view class=\"fenlei {{on === 'category' ? 'on': ''}}\" data-page=\"category\" bindtap=\"goToPage\">\r\n    <icon type=\"classify\" size=\"42\" class=\"icon\" color=\"{{on === 'category' ? '#f96702': ''}}\"/>\r\n    <text >分类</text>\r\n  </view>\r\n  <!-- 发现 -->\r\n  <view class=\"faxian {{on === 'find' ? 'on': ''}}\" data-page=\"find\" bindtap=\"goToPage\">\r\n    <icon type=\"faxian\" size=\"42\" class=\"icon\" color=\"{{on === 'find' ? '#f96702': ''}}\"/>\r\n    <text >发现</text>\r\n  </view>\r\n  <!-- 购物车 -->\r\n  <view class=\"gouwuche {{on === 'cart' ? 'on': ''}}\" data-page=\"cart\" bindtap=\"goToPage\">\r\n    <icon type=\"gouwuche\" size=\"42\" class=\"icon\" color=\"{{on === 'cart' ? '#f96702': ''}}\"/>\r\n    <text >购物车</text>\r\n  </view>\r\n  <!-- 我的 -->\r\n  <view class=\"wode {{on === 'user' ? 'on': ''}}\" data-page=\"user\" bindtap=\"goToPage\">\r\n    <icon type=\"wode\" size=\"42\" class=\"icon\" color=\"{{on === 'user' ? '#f96702': ''}}\"/>\r\n    <text >我的</text>\r\n  </view>\r\n</view>\r\n复制代码// components/tabbar/tabbar.js\r\n// 全局里面存了一个page 表示当前 路由\r\nconst app =  getApp();\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 是否选中\r\n    on:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    // 跳转到相应的页面\r\n    // 加了一个判断\r\n    // 因为如果现在显示的是当前页面就不需要再跳转\r\n    goToPage(e) {\r\n      let page = e.currentTarget.dataset.page || 'user';\r\n      if(app.globalData.page === page) {\r\n        return ;\r\n      }\r\n      wx.redirectTo({\r\n        url: `/pages/${page}/${page}`,\r\n      });\r\n      app.globalData.page = page;\r\n    }\r\n  }\r\n})\r\n复制代码/* components/tabbar/tabbar.wxss */\r\n.tabbar {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  background-color: #ffffff;\r\n  display: flex;\r\n  position: fixed;\r\n  bottom: 0;\r\n  font-size: 26rpx;\r\n  z-index: 99;\r\n}\r\n.shouye,.fenlei,.faxian,.gouwuche,.wode {\r\n  flex: 1;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  text-align: center;\r\n  opacity: 0.5;\r\n}\r\n.icon {\r\n  height: 60rpx;\r\n}\r\n.on {\r\n  color:#f96702;\r\n}\r\n复制代码关于如何使用的问题，只需要在，需要tabBar功能的页面底部加上就可以.比如index页面<tabbar on=\"index\"></tabbar>\r\n复制代码记得在json中引入组件{\r\n  \"usingComponents\": {\r\n    \"goodList\": \"../../components/goodList/goodList\",\r\n    \"tabbar\": \"../../components/tabbar/tabbar\"\r\n  }\r\n}\r\n复制代码icon组件tabBar组件中需要图标，我使用的是阿里的图标库如何使用？先去图标库中找到你所需要的图标，加入购物车。然后添加至项目，自己新建一个就可以了。在然后下载之本地，把其中的CSS文件里面所有的内容都复制到wxss文件中就行了.这个组件很简单，定义出来就可以直接使用，并且修改颜色和大小.<!--components/icon/icon.wxml-->\r\n<text class='iconfont icon-{{type}}' style='color:{{color}}; font-size:{{size}}rpx;'></text>\r\n复制代码properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  },\r\n复制代码goodList组件在首页中存在很多这样的商品列表，一个一个写，这样写出来的代码会导致首页的代码显得很多，并且不好维护，所以我就封装成了一个组件.<!--components/goodList/goodList.wxml-->\r\n<view class=\"goodList-good\">\r\n  <!-- 商品的图片 -->\r\n  <view class=\"goodList-good-img\">\r\n    <image src=\"{{url}}\" mode=\"aspectFill\" />\r\n  </view>\r\n  <!-- 商品详细的信息 -->\r\n  <view class=\"goodList-good_detail\">\r\n    <!-- 名称 -->\r\n    <view class=\"good_detail_name\">\r\n      {{name}}\r\n    </view>\r\n    <!-- 信息 -->\r\n    <view class=\"good_detail_brief\">\r\n      {{brief}}\r\n    </view>\r\n    <!-- 价格 -->\r\n    <view class=\"good_detail_price\">\r\n      <text class=\"price\" >￥{{price}}</text>\r\n      <text class=\"oldPrice\" style=\"display:{{oldPrice == '' ? 'none': 'inline'}};\">￥{{oldPrice}}</text>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码properties: {\r\n    // 图片链接\r\n    url: {  \r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 名称\r\n    name: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 信息\r\n    brief: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 新的价格\r\n    price: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 旧的价格\r\n    oldPrice: {\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n复制代码/* components/goodList/goodList.wxss */\r\n\r\n.goodList-good {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.goodList-good-img {\r\n  width: 100%;\r\n  height: 312rpx;\r\n  position: relative;\r\n}\r\n.goodList-good-img image {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.goodList-good_detail {\r\n  padding: 26rpx 23rpx;\r\n}\r\n.good_detail_name {\r\n  width:100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  display: -webkit-box;\r\n  -webkit-line-clamp: 1;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.good_detail_brief {\r\n  width:100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  display: -webkit-box;\r\n  -webkit-line-clamp: 1;\r\n  -webkit-box-orient: vertical;\r\n  font-size: 25rpx;\r\n  color: #8c8c8c;\r\n}\r\n.good_detail_price {\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: flex-end;\r\n}\r\n.good_detail_price .price {\r\n  color: #a36d4a;\r\n  font-size: 28rpx;\r\n  padding-right: 16rpx;\r\n}\r\n.good_detail_price .oldPrice {\r\n  font-size: 24rpx;\r\n  color: #8c8c8c;\r\n  text-decoration: line-through;\r\n}\r\n复制代码你们会发现，我的边框为什么那么细。0.5px边框如何画初学者，可能会说，0.5px边框，不就是border: 0.5px吗，其实这是错的。浏览器会把任何小于1px的边框都解析成1px,所以你写0.5px其实浏览器会解析成1px,这样就实现不了效果。其实也很简单， 使用伪类去画。例如，goodList组件的右部边框.在index页面的html中,我在包裹goodList的view标签的class中加上了 rightBorder 这个类来表示画出上边框。<view class=\"item topBorder rightBorder\" data-id=\"{{item.id}}\" bindtap=\"goDetails\">\r\n  <goodList url=\"{{item.url}}\"\r\n    name=\"{{item.name}}\"\r\n    brief=\"{{item.brief}}\"\r\n    price=\"{{item.price}}\"\r\n    oldPrice=\"{{item.oldPrice}}\" ></goodList>\r\n</view>\r\n复制代码.rightBorder::after {\r\n  content: '';\r\n  position: absolute;\r\n  height: 200%;\r\n  width: 1rpx;\r\n  right: -1rpx;\r\n  top: 0;\r\n  transform-origin: 0 0;\r\n  border-right: 1rpx solid#e0e0e0;\r\n  transform: scale(.5);\r\n  z-index: 1;\r\n}\r\n复制代码其实画0.5px边框就记住。使用伪类，并且 position: absolute;如果想画上下的边框，就把width设置成200%,,左右就把height设置成200%然后使用transform: scale(.5); 宽高都缩小0.5倍就成了0.5px边框.其它还有一些 细节问题就按照所需写就行。userList组件只是我的页面中的一个列表信息，这个很简单<!--components/userList/userList.wxml-->\r\n<view class=\"main\">\r\n  <image src=\"{{List.img}}\" />\r\n  <view class=\"text\" >\r\n    <text >{{List.text}}</text>\r\n  </view>\r\n  <view class=\"state\" wx:if=\"{{List.state !== ''}}\">\r\n    <text >({{List.state}})</text>\r\n  </view>\r\n</view>\r\n复制代码/* components/userList/userList.wxss */\r\n.main {\r\n  width: 100%;\r\n  height: 120rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  background-color: #fff;\r\n  padding: 40rpx;\r\n  box-sizing: border-box;\r\n}\r\n.main image {\r\n  width: 80rpx;\r\n  height: 80rpx;\r\n}\r\n.main .text {\r\n  font-size: 32rpx;\r\n  padding: 0 10rpx 0 5rpx;\r\n}\r\n.main .state {\r\n  font-size: 26rpx;\r\n  color: #8c8c8c;\r\n}\r\n复制代码properties: {\r\n    List: {\r\n      type: Object\r\n    }\r\n  },\r\n复制代码页面和功能介绍首页搜索部分我这里引入的是weui组件的搜索样式。如何用?下载 WEUI小程序版 ，可以在微信开发者工具中打开。(推荐)把styly文件夹下的weui.wxss 放到自己项目中weui文件夹下在app.wxss中@import \"./weui/weui.wxss\".就可以使用了首页轮播部分这是微信小程序提供的一个组件swiper,微信小程序开发者文档swiper和swiper-item组合起来就可以实现,一些配置信息，请查看官方文档具体代码<swiper indicator-dots=\"{{indicatorDots}}\" indicator-active-color=\"#ffffff\" autoplay=\"{{autoPlay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n    <block wx:for=\"{{banners}}\" wx:key=\"index\">\r\n      <swiper-item>\r\n        <image src=\"{{item.imgurl}}\" mode=\"aspectFill\" class=\"banner-image\" />\r\n      </swiper-item>\r\n    </block>\r\n  </swiper>\r\n复制代码data: {\r\n    banners: [],\r\n    indicatorDots: true,\r\n    autoPlay: true,\r\n    interval: 3000,\r\n    duration: 1000,\r\n    navdata: [],\r\n    goodList: [],\r\n    goodListOne: {},\r\n    name:'',\r\n  },\r\n复制代码一个常用的功能在商城小程序中经常要做一个这样的功能.例如:功能要求:点击左边的商品列表，右边的商品信息会滑动到对应位置.滑动右边的商品信息，左边的商品列表显示的高亮会对应发生变化.功能要求并不难，但是对于初学者而言，可能会有些问题。我就直接说功能该怎么做首先：分析一下，页面结构是左右布局。并且 两边都可以滑动 .所以可以使用微信给我们提供的scroll-view组件.两个组件就可以采用float，分布在左右两边.<!-- miniprogram/pages/category/category.wxml -->\r\n<view class=\"container\">\r\n  <!-- 左边商品的标签信息 -->\r\n  <scroll-view scroll-y scroll-with-animation=\"{{true}}\" class=\"categroy-left\">\r\n    <view wx:for=\"{{categroy}}\" wx:key=\"{{index}}\" data-index=\"{{index}}\" bindtap=\"switchTab\" class=\"cate-list {{curIndex === index ? 'on': ''}}\">\r\n      {{item[0].name}}\r\n    </view>\r\n  </scroll-view>\r\n  <!-- 右边 标签对应的商品信息 -->\r\n  <scroll-view scroll-y scroll-into-view=\"{{toView}}\" scroll-with-animation=\"true\" bindscroll=\"scrollContent\" bindscrolltolower=\"scrollEnd\" class=\"categroy-right\">\r\n    <block wx:for=\"{{categroy}}\" wx:key=\"inedx\">\r\n      <view id=\"right-list\" class=\"right-list\" id=\"{{index}}\">\r\n        <view class=\"right-title\">\r\n          <text>{{item[0].name}}</text>\r\n        </view>\r\n        <view class=\"right-content\">\r\n          <block wx:for=\"{{item}}\" wx:key=\"idex\" wx:for-item=\"product\" wx:for-index=\"idex\">\r\n            <view class=\"list-detail\" wx:if=\"{{idex > 0}}\">\r\n              <image src=\"{{product.picture}}\" />\r\n              <view class=\"detail-name\">\r\n                <text>{{product.desc}}</text>\r\n              </view>\r\n            </view>\r\n          </block>\r\n        </view>\r\n      </view>\r\n    </block>\r\n  </scroll-view>\r\n</view>\r\n<tabbar on=\"category\"></tabbar>\r\n\r\n复制代码/* miniprogram/pages/category/category.wxss */\r\n/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/\r\n::-webkit-scrollbar\r\n{\r\nwidth: 0px;\r\nheight: 0px;\r\nbackground-color: pink;\r\n}\r\n.categroy-left {\r\n  height: 100%;\r\n  width: 150rpx;\r\n  float: left;\r\n  border-right: 1px solid #ebebeb;\r\n  box-sizing: border-box;\r\n  position: fixed;\r\n  font-size: 30rpx;\r\n  padding-bottom: 100rpx;\r\n  box-sizing: border-box;\r\n}\r\n.categroy-left .cate-list {\r\n  height: 90rpx;\r\n  line-height: 90rpx;\r\n  text-align: center;\r\n  border: 2px solid #fff;\r\n}\r\n.categroy-left .cate-list.on {\r\n  color: #ff4800;\r\n  font-size: 34rpx;\r\n}\r\n/* 右边的列表 */\r\n.categroy-right {\r\n  width: 600rpx;\r\n  float: right; \r\n  height: 1334rpx;\r\n  /* height: 100%; */\r\n  padding-bottom: 100rpx;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n}\r\n.right-title {\r\n  width: 100%;\r\n  text-align: center;\r\n  position: relative;  \r\n  padding-top: 30rpx;\r\n  /* font-size: 30rpx; */\r\n  padding-bottom: 30rpx;\r\n}\r\n .right-title text::before, .right-title text::after {\r\n  content: '';\r\n  position: absolute;\r\n  width: 60rpx;\r\n  /* height: 1px; */\r\n  top: 50%;\r\n  border-top: 1px solid #e0e0e0;\r\n  /* transform: scale(.5); */\r\n}\r\n.right-title text::before { \r\n  left: 30%;\r\n}\r\n.right-title text::after {\r\n  right: 30%;\r\n}\r\n.right-list {\r\n  /* height: 100%; */\r\n  background-color: #fff;\r\n}\r\n.right-content {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n}\r\n.right-content .list-detail {\r\n  flex-shrink: 0;\r\n  width: 33.3%;\r\n  height: 100%;\r\n  font-size: 26rpx;\r\n  text-align: center;\r\n  \r\n}\r\n.right-content .list-detail image {\r\n  width: 120rpx;\r\n  height: 120rpx;\r\n  padding: 10rpx;\r\n  /* background-color: pink; */\r\n}\r\n复制代码这个功能的难点就在于js逻辑先贴出data中需要的数据data: {\r\n    categroy:[],    //商品信息\r\n    curIndex: 'A',  //当前的选中的标签\r\n    toView: 'A',    //去到的标签\r\n    // 存入每个list的高度叠加\r\n    heightArr: [],\r\n    // 最后一个list,就是最后一个标签的id\r\n    endActive: 'A'\r\n  },\r\n复制代码点击左边右边滑动这一功能很简单就能实现只需要在右边scroll-view组件中添加事件 scroll-into-view=\"{{toView}}\" ,toView就是商品显示的 id注意，右边每个商品信息，页面渲染时 必须 加上id属性然后左边的scroll-view组件只需添加一个点击事件去修改toView的值就行了// 点击左边标签要修改的信息\r\n  switchTab(e) {\r\n    this.setData({\r\n      curIndex: e.target.dataset.index,\r\n      toView: e.target.dataset.index\r\n    })\r\n  },\r\n复制代码滑动右边左边高亮对应改变首先需要计算出 右边商品每一块占据的高度,并且存入数组中 ,可以放入onReady生命周期中// 计算出右边每个商品占据的高度\r\n  getPageMessage() {\r\n    // console.log(4)\r\n    let self = this\r\n    let heightArr = []\r\n    let h = 0\r\n    const query = wx.createSelectorQuery()\r\n    query.selectAll('.right-list').boundingClientRect()\r\n    query.exec( res => {\r\n      res[0].forEach( item => {\r\n        h += item.height\r\n        heightArr.push(h)\r\n      })\r\n      self.setData({\r\n        heightArr: heightArr\r\n      })\r\n    })\r\n  },\r\n复制代码在右边的scroll-view组件中加上事件。 bindscroll=\"scrollContent ,这是scroll-view提供的事件,在滑动时就会触发.// 页面滑动时触发\r\n  scrollContent(e) {\r\n    const scrollTop = e.detail.scrollTop\r\n    const scrollArr = this.data.heightArr\r\n    const length = scrollArr.length - 1\r\n    let endChar = String.fromCharCode(65 + length)\r\n    let curChar = this.getCurrentIndex(scrollTop)\r\n    if(this.data.endActive != endChar) {\r\n      this.setData({\r\n        curIndex: curChar\r\n      })\r\n    } else {\r\n      this.setData({\r\n        endActive: 'A'\r\n      })\r\n    }\r\n  },\r\n复制代码// 判断curIndex应该是那个\r\n  getCurrentIndex(scrollTop) {\r\n    const scrollArr = this.data.heightArr\r\n    let find = scrollArr.findIndex(item => {\r\n      // 提前10rpx触发效果\r\n      return scrollTop < item - 10\r\n    })\r\n    let curChar = String.fromCharCode(65 + find)\r\n    return curChar\r\n  },\r\n复制代码以上就可以实现所有的功能要求了。但是这样的滑动并不是很完美，右边滑动到最下面，左边高亮却不是最后一个相对完美效果就是这样想要完美一点就要在，右边scroll-view添加一个事件： bindscrolltolower=\"scrollEnd\"// 页面滑动到底部触发\r\n  scrollEnd() {\r\n    const scrollArr = this.data.heightArr\r\n    const length = scrollArr.length - 1\r\n    let endChar = String.fromCharCode(65 + length)\r\n    this.setData({\r\n      curIndex: endChar,\r\n      endActive: endChar\r\n    })\r\n  },\r\n复制代码购物逻辑想要实现这样的效果并不困难。逻辑顺序: 首页点击商品信息 -> 商品详情页面显示对应的商品详情信息 -> 购物车页面显示商品购买的商品信息. -> 修改之后，商品详情页面显示修改的信息。想要实现这样的功能，必须有一个 id 在页面跳转时，传入给跳转的页面，跳转的页面再通过id值获取页面所需的数据例如：首页 -> 商品详情页这是一条商品的列表的信息,通过点击事件 bindtap=\"goDetails\" ，跳到对应的页面.<view class=\"list\">\r\n      <block wx:for=\"{{goodList}}\" wx:key=\"{{item.id}}\">\r\n        <view class=\"item topBorder rightBorder\" data-id=\"{{item.id}}\" bindtap=\"goDetails\">\r\n          <goodList url=\"{{item.url}}\"\r\n            name=\"{{item.name}}\"\r\n            brief=\"{{item.brief}}\"\r\n            price=\"{{item.price}}\"\r\n            oldPrice=\"{{item.oldPrice}}\" ></goodList>\r\n        </view>  \r\n      </block>\r\n    </view>\r\n复制代码goDetails(e) {\r\n    const id = e.currentTarget.dataset.id\r\n    wx.navigateTo({\r\n      url: `/pages/goodDetails/goodDetails?id=${id}`,\r\n    });\r\n  },\r\n复制代码商品详情页:传入的 id值 可以再onLoad生命周期的options参数上获取onLoad: function (options) {\r\n    WXAPI.showLoading()\r\n    // 获取用户的地址信息\r\n    const address = wx.getStorageSync('Address');\r\n    this.setData({\r\n      id: options.id,\r\n      address\r\n    })\r\n    this.getGoodDetail()\r\n  },\r\n复制代码数据的存储逻辑我是把数据直接存在本地缓存中(也可以直接存入到云数据库中)，使用的是 wx.setStorage()在本地存入了两个数据， 一个是所有购买的商品信息，一个是总的商品购买数量// 添加到购物车\r\n  toAddCart() {\r\n    let cartData = wx.getStorageSync('goods') || [];    \r\n    let data = {\r\n      id: this.data.id,\r\n      name: this.data.goodData.name,\r\n      memory: this.data.memory,\r\n      color: this.data.color,\r\n      price: this.data.price,\r\n      num: this.data.selectNum,\r\n      img: this.data.imgSrc,\r\n      select: true\r\n    }\r\n    // wx.removeStorageSync('goods');\r\n    cartData.push(data)\r\n    const allNum =this.getAllNum(cartData)\r\n    wx.setStorage({\r\n      key: 'goods',\r\n      data: cartData,\r\n      success: (res) => {\r\n        console.log(res)\r\n        let pageIndex = getCurrentPages()\r\n        let backIndex = pageIndex.length - 2\r\n        wx.navigateBack({\r\n          delta: backIndex\r\n        })\r\n      },\r\n      fail: () => {},\r\n      complete: () => {}\r\n    });\r\n    // 存储数量到storage\r\n    wx.setStorageSync('allNum', allNum);\r\n    // 写到外面就可以让showToast 显示在前一个页面\r\n    setTimeout(()=>{\r\n      wx.showToast({\r\n        title: '已加入购物车',\r\n        icon: 'success',\r\n        duration: 2000\r\n      });\r\n   },500)\r\n  },\r\n  // 获取所有的数量\r\n  getAllNum(cartData) {\r\n    return cartData.reduce((sum, item) => {\r\n      return sum + (+item.num)\r\n    },0)\r\n  },\r\n复制代码概述的参数切换实现这个功能只需要加一个状态，点击时就修改状态的值，并且修改相关渲染的数据就行。data: {\r\n state: 'details_img', //判断概述 参数\r\n}\r\n复制代码<view class=\"summarize-parameter\">\r\n    <view class=\"title\">\r\n      <view class=\"summarize\" bindtap=\"changeState\">\r\n        <text class=\"{{state === 'details_img'? 'on' : ''}}\">概述</text>\r\n      </view>\r\n      <view class=\"parameter\" bindtap=\"changeState\">\r\n        <text class=\"{{state === 'param_img'? 'on' : ''}}\">参数</text>\r\n      </view>\r\n    </view>\r\n    <view class=\"state\">\r\n      <block wx:for=\"{{state === 'details_img'? details_img : param_img}}\" wx:key=\"index\">\r\n          <image src=\"{{item}}\" mode=\"widthFix\"/>\r\n      </block>\r\n    </view>\r\n  </view>\r\n复制代码// 改变概述和参数\r\n  changeState() {\r\n    let state = this.data.state\r\n    if(state === 'details_img') {\r\n      state = 'param_img'\r\n    } else {\r\n      state = 'details_img'\r\n    }\r\n    this.setData({\r\n      state\r\n    })\r\n  },\r\n复制代码购物数据改变，商品详情数据修改对比一下上面两张图的区别.在购物页面中选的商品数量和具体的商品信息，之后跳转回商品详情页面中,对应的数据会修改<view class=\"sales\" bindtap=\"goSelectGoods\">\r\n      <text class=\"describe\">已选</text>\r\n      <view class=\"detail detail-change\">\r\n        {{default_change.name}}\r\n        {{default_change.memory}}\r\n        {{default_change.color}}\r\n        <text >× {{default_change.num}}</text>\r\n      </view>\r\n      <view class=\"right\"></view>\r\n    </view>\r\n复制代码<view class=\"shopping-img\" bindtap=\"goCart\">\r\n    <icon type=\"gouwuche\" color=\"#e0e0e0\" size=\"40\"/>\r\n    <text wx:if=\"{{allNum != 0}}\">{{allNum}}</text>\r\n  </view>\r\n复制代码上面时两块修改的html结构在购物页面点击确认之后，我默认就把商品添加到购物车中，并且位于数据的最后一条返回商品详情页面时，会重新触发onShow生命周期的函数。所以我只需要，在onShow中触发修改方法就行.// 改变默认的版本数据 default_change\r\n  changeDefauleChange() {\r\n    const goods = wx.getStorageSync('goods') || [];\r\n    if(goods.length === 0) {\r\n      return\r\n    }\r\n    const id = this.data.id\r\n    const default_change = goods[goods.length - 1]\r\n    let memory = default_change.memory.toString()\r\n    memory = memory.substring(0,memory.length - 4)\r\n    default_change.memory = memory\r\n    this.setData({\r\n      default_change\r\n    })\r\n  },\r\n复制代码画一个三角形这一个三角形是使用CSS画出来的，并不是图标。使用CSS画出一个三角形，也不是那么困难。使用的是伪类和border属性.right:before,\r\n.right:after {\r\n  content: '';\r\n  position: absolute;\r\n  top: 35%;\r\n  right: 0;\r\n  border-width: 8px;\r\n  /* transform: translateY(10000rpx); */\r\n  border-color: transparent transparent transparent transparent;\r\n  border-style: solid;\r\n  transform: rotate(90deg);\r\n}\r\n\r\n.right:before {\r\n  border-bottom: 8px #aaaaaa solid;\r\n}\r\n\r\n.right:after {\r\n  right: 1px;\r\n  /*覆盖并错开1px*/\r\n  border-bottom: 8px #fff solid;\r\n}\r\n复制代码修改商品数量可以直接使用微信小程序提供的picker组件，具体配置请查看文档使用腾讯地图获取地理位置先搜索腾讯地图，并且注册开发者信息，申请一个密钥key.// 获取地理位置\r\nconst geocoder = (lat, lon) => {\r\n  return request(API.MAPURL,false,{\r\n    location: `${lat},${lon}`,\r\n    key: API.QQ_MAP_KEY,\r\n    get_poi: 0\r\n  })\r\n}\r\n复制代码然后把密钥复制，因为我封装了所有的API接口。所以使用了 API.QQ_MAP_KEY 代替，这里就填写申请的密钥就行.想要获取用户的经纬度信息，可以使用 wx.getLocation() ，就可以获取用户的经纬度信息了.getLocation() {\r\n    wx.getLocation({\r\n      type: 'gcj02',\r\n      success: this.getAddress,\r\n      fail: () => {\r\n        this.openLocation()\r\n      }\r\n    })\r\n  },\r\n  getAddress(res) {\r\n    let { latitude: lat, longitude: lon} = res\r\n    WXAPI.geocoder(lat, lon)\r\n    .then(res => {\r\n      if(res.status !== 0 || !res.result) {\r\n        return\r\n      } \r\n      let {address_component\r\n      } = res.result\r\n      const Address = {\r\n        city: address_component.city,\r\n        district: address_component.district\r\n      }\r\n      wx.setStorageSync(\"Address\", Address);\r\n    })\r\n  },\r\n复制代码因为我未让用户授权，所以直接把获取的地理位置，保存在本地storage中.获取的地理位置，就可以在商品详情页面的送至显示出来结语做这个项目的过程来说是快乐的，没有使用云函数(页面数据并不多，我觉得不需要就可以写出来了)，所以总共加起来写的时间也很短，不到一个星期就写完了。写完之后的那一刻的成就感也很好。如果你觉得这篇文章有帮到你的地方，不妨给个赞吧！同时也非常希望在下方看到给出的建议！最后奉上 源码 .如果有需要就自取吧!最后，说点题外话，因为我是2020届的毕业生，现在面临实习压力。因为需要话时间去看面试题，所以后面写的一段文章，我只是简要的把重要的功能逻辑写了出来，如果写的不清楚，请见谅。"}
{"title": "小程序稻草人图床神器，前后端开源 ", "author": "Rolan", "pub_time": "2019-7-11 00:09", "content": "源码地址：小程序源码 https://github.com/w77996/mini-straw  \r\n后台源码 https://github.com/w77996/hi-straw  \r\n复制代码体验一下之前乘着换工作的间隙撸的，一方面练习一下小程序，学过之后没怎么应用，一方面写点笔记啥的，项目断断续续做了两个月，只是一个简单的图片上传工具，觉得不错的话记得给个star小程序小程序授权，登录父组件与子组件相互通信小程序分享，意见与建议，客服功能，文件上传flex布局的使用Promise的使用，业务model封装插槽的使用，动画效果项目目录结构mini-straw\r\n    ├── component -- 组件\r\n    |    ├── file -- 文件组件\r\n    |    ├── image-button -- 图片按钮组件\r\n    |    ├── search -- 查找页面组件\r\n    |    ├── tag -- 标签组件\r\n    ├── images -- 图片目录\r\n    |    ├── icon -- icon图片\r\n    |    ├── tab -- tab图片\r\n    ├── model -- 封装的model\r\n    ├── pages -- 页面\r\n    |    ├── about -- 关于页\r\n    |    ├── auth -- 授权页\r\n    |    ├── file -- 文件页\r\n    |    ├── index -- 首页\r\n    |    ├── launch -- 启动页面\r\n    |    ├── my -- 个人中心\r\n    └── utils -- 工具\r\n复制代码后台：技术栈：spring boot + druid + mybatis + jwt微信登录，jwt授权注解及AOP的使用maven多环境打包，docker使用shell脚本自动化部署nginx反向代理及https配置七牛云文件操作项目目录结构hi-straw\r\n├── common -- 公共模块\r\n├── config -- 配置模块\r\n├── controller -- controller接口\r\n├── core -- 核心业务模块\r\n|    ├── annontaion -- 注解\r\n|    ├── aop -- aop实现\r\n|    ├── constant -- 常量\r\n|    ├── filter -- 拦截器\r\n|    ├── jwt -- jwt相关\r\n|    └── result -- 结果返回\r\n├── entity -- 实体类\r\n|    ├── dto -- 数据传输\r\n|    └── vo -- 页面传输\r\n├── exception -- 全局异常\r\n├── mapper -- dao层\r\n├── service -- service层\r\n└── util -- 工具类\r\n\r\n复制代码小程序详解[TOC]mini-straw项目结构mini-straw\r\n    ├── component -- 组件\r\n    |    ├── file -- 文件组件\r\n    |    ├── image-button -- 图片按钮组件\r\n    |    ├── search -- 查找页面组件\r\n    |    ├── tag -- 标签组件\r\n    ├── images -- 图片目录\r\n    |    ├── icon -- icon图片\r\n    |    ├── tab -- tab图片\r\n    ├── model -- 封装的model\r\n    ├── pages -- 页面\r\n    |    ├── about -- 关于页\r\n    |    ├── auth -- 授权页\r\n    |    ├── file -- 文件页\r\n    |    ├── index -- 首页\r\n    |    ├── launch -- 启动页面\r\n    |    ├── my -- 个人中心\r\n    └── utils -- 工具\r\n\r\n复制代码开屏页1.判断网络状态使用 wx.getNetworkType({}) 可获取当前网络状态， networkType 值 wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)//判断网络状态\r\nwx.getNetworkType({\r\n    success: res => {\r\n    if (res.networkType == \"none\") {\r\n        wx.showToast({\r\n            title: '嗷~~网络不可用',\r\n            icon: 'none',\r\n            duration: 2000\r\n        })\r\n        return;\r\n    }\r\n    },\r\n})\r\n复制代码2.判断授权状态使用 wx.getSetting({}) 获取授权状态，在获得 data 后取 data.authSetting['scope.userInfo'] 判断授权状态// 获取授权的状态\r\nwx.getSetting({\r\n    success: data => {\r\n    if (data.authSetting['scope.userInfo']) {\r\n        //已授权，执行登陆\r\n        wx.getUserInfo({\r\n            success: data => {\r\n                    console.log(\"userInfo {}\", data)\r\n                    let userInfo = data.userInfo;\r\n                    wx.setStorageSync('userInfo', userInfo);\r\n                    //执行登陆操作\r\n                    this._userLoginGetCode(userInfo);\r\n            }\r\n        });\r\n        wx.setStorageSync('authorized', true);\r\n    } else {\r\n        console.log(\"未授权\")\r\n        //跳转至授权页\r\n        let timer = setTimeout(() => {\r\n                wx.redirectTo({\r\n                        url: '/pages/auth/auth'\r\n                })\r\n        }, 2000)\r\n\r\n    }\r\n    }\r\n});\r\n复制代码若授权，则调用 wx.getUserInfo({}) 获取微信用户信息，信息获取完成后调用 wx.login({})获取小程序的 code ,通过 code 向后台获取用户openId及token。//后台获取code\r\n_userLoginGetCode(userInfo) {\r\n    console.log(\"发起_userLoginGetCode请求\");\r\n    wx.login({\r\n        success(res) {\r\n        console.log(\"wx.login {}\", res);\r\n        if (res.code) {\r\n            // 发起网络请求\r\n            const code = res.code;\r\n            userInfo.code = code;\r\n            userModel.getTokenByCode(userInfo).then((res) => {\r\n                console.log(\"userModel getUserInfo {}\", res);\r\n                wx.setStorageSync(\"token\", res.data.data.token);\r\n                let timer = setTimeout(() =>\r\n                    wx.switchTab({\r\n                            url: '/pages/index/index',\r\n                    }), 2000)\r\n            });\r\n        } else {\r\n                console.log('登录失败！' + res.errMsg)\r\n        }\r\n        }\r\n    })\r\n},\r\n复制代码3.跳转页面跳转 /pages/auth/auth 页面使用的是 wx.redirectTo({})跳转 /pages/index/index 页面使用的是 wx.switchTab({}) 因为 /pages/index/index 是小程序tab页，使用 wx.redirectTo({}) 无法跳转授权页授权需制定button按钮，加入 open-type='getUserInfo' 属性， bindgetuserinfo 调用自定义方法 onGetUserInfo 。<button class=\"auth-button\" open-type='getUserInfo' bindgetuserinfo=\"onGetUserInfo\">好的</button>\r\n复制代码onGetUserInfo 接受授权状态及授权获取的用户信息，再进行 code 获取，通过 code 向后台获取用户openId及token。onGetUserInfo: function(e) {\r\n    console.log(e)\r\n    const userInfo = e.detail.userInfo;\r\n    if (userInfo) {\r\n            //通过`code`向后台获取用户openId及token。\r\n            this._userLoginGetCode(userInfo);\r\n    }\r\n},\r\n复制代码主页1. 图片按钮插槽组件在 component 目录下的 images-button 组件，做了简单的图片插槽统一，在分享按钮，用户登录按钮，文件上传按钮均可以使用。 plain=\"{{true}}\" 代表button背景透明<button  open-type=\"{{openType}}\" plain=\"{{true}}\" class=\"container\">\r\n  <slot name=\"img\"></slot>\r\n</button>\r\n复制代码options 需要开启插槽功能，添加 multipleSlots: true open-type=\"{{openType}}\" 父组件将参数传入子组件，子组件在 properties 属性中可以获取到父组件传来的openType数据，通过 this.properties.openType 可以获取属性值options: {\r\n    // 开启插槽\r\n    multipleSlots: true\r\n  },\r\n/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    openType: {\r\n      type: String\r\n    }\r\n  },\r\n复制代码index 页面引入组件，需要在 index.json 中添加组件路径{\r\n  \"usingComponents\": {\r\n    \"btn-cmp\": \"/component/image-button/index\"\r\n  }\r\n}\r\n复制代码2. 上传文件主要使用到 wx.chooseImage({}) 进行图片的选择，选择后使用 wx.uploadFile({}) 上传图片至服务器//上传文件\r\nonUpload(event) {\r\nlet _this = this;\r\nwx.chooseImage({\r\n  count: 1, // 默认9\r\n  sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n  success: function(res) {\r\n    // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n    let tempFilePaths = res.tempFilePaths;\r\n    console.log(tempFilePaths)\r\n    wx.uploadFile({\r\n      header: {\r\n        \"Authorization\": \"Bearer \" + wx.getStorageSync(\"token\")\r\n      },\r\n      url: config.apiBaseUrl + '/file/upload',\r\n      filePath: tempFilePaths[0],\r\n      name: 'file',\r\n      success: (res) => {\r\n        wx.showToast({\r\n          title: \"上传成功~\",\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n      },\r\n      fail: (res) => {\r\n        wx.showToast({\r\n          title: res.data.msg,\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n}\r\n复制代码列表页1.search组件的显示和隐藏固定列表页搜索header位置，点击header显示 search 组件，在 search 组件点击取消则隐藏 search 组件，此处设计子组件向父组件传递消息引入search组件\"usingComponents\": {\r\n    ...\r\n    \"search-cmp\": \"/component/search/index\"\r\n  }\r\n复制代码使用searchPage参数判断 search 组件的,默认为false,在点击header时更新searchPage为true,显示 search 组件<view wx:if=\"{{!searchPage}}\" class=\"container\">\r\n  ...\r\n</view>\r\n\r\n<search-cmp  wx:if=\"{{searchPage}}\" ></search-cmp>\r\n复制代码search 页面点击取消，向父组件发送一个 this.triggerEvent('cancel', {}, {}); 事件，在xml中的 search-cmp 添加 cancel 事件的通知绑定#file页面中的search-cmp组件\r\n<search-cmp  wx:if=\"{{searchPage}}\" bind:cancel=\"onCancel\"></search-cmp>\r\n复制代码父组件 file 页面绑定子组件传来的 cancel 事件通知，就调用 onCancel 方法, 在 onCancel方法中获取事件响应，将 searchPage 参数修改为false， search 组件就隐藏起来了//cancel searching page \r\nonCancel(event) {\r\n  console.info(event)\r\n  this.triggerEvent('cancel', {}, {});\r\n \r\n},\r\n复制代码2.文件列表1.获取列表信息传递给file组件在 page 中的file页面，获取到后台传来的fileList数据，引入file组件， file=\"{{item}}\" 将数据传入子组件<view wx:if=\"{{fileList}}\">\r\n  <block wx:for=\"{{fileList}}\" wx:key=\"{{item.id}}\" file=\"{{item}}\">\r\n    <file-cmp file=\"{{item}}\" bind:del=\"onDelete\"></file-cmp>\r\n    <view class=\"line\"></view>\r\n  </block>\r\n</view>\r\n复制代码在 component 中的file组件，在 properties 添加属性 file 来接收父组件传来的数据/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    file: Object\r\n  }\r\n复制代码file组件在xml页面中使用 {{file.fileName}} 即可获取到对象信息，相应的数据也会呈现在页面上3.粘贴板操作<image src=\"images/copy.png\" bindtap=\"onCopy\"></image>\r\n复制代码图片点击响应方法 onCopy ， onCopy 调用 wx.setClipboardData({}) 可以将数据复制到粘贴板onCopy: function (event) {\r\n      console.info(event)\r\n      let _this = this;\r\n      wx.setClipboardData({\r\n        data: _this.properties.file.filePath,\r\n        success: function(res) {\r\n          wx.showToast({\r\n            title: '图片地址复制成功',\r\n          })\r\n        }\r\n      });\r\n\r\n复制代码4.删除操作<image src=\"images/del.png\" bindtap=\"onDelete\"></image>\r\n复制代码子组件将数据传递给父组件，点击删除图片出发 onDelete 方法,通过 this.triggerEvent('del', {fileId}, {}); 将文件ID发送到父组件onDelete: function (event) {\r\n      console.info(event)\r\n      let fileId = this.properties.file.id;\r\n      this.triggerEvent('del', {fileId}, {});\r\n    },\r\n复制代码父组件file页面绑定子组件传来的 del 事件<file-cmp file=\"{{item}}\" bind:del=\"onDelete\"></file-cmp>\r\n复制代码调用 onDelete 出发网络请求去完成删除文件的逻辑,删除成功后重新刷新文件列表//删除图片\r\nonDelete(event) {\r\n    console.info(\"DEL\")\r\n    console.info(event)\r\n    let fileId = event.detail.fileId;\r\n    fileModel.delFileById(fileId).then((res) => {\r\n        console.info(res);\r\n        wx.showToast({\r\n                title: '删除成功',\r\n        })\r\n        this.setData({\r\n                pageNum: 1,\r\n                fileList: []\r\n        });\r\n        this._getFileList();\r\n    })\r\n},\r\n复制代码我的页面1.意见和建议小程序自带用户反馈功能，使用 button 跳转至网页，用户可以填写相关反馈, open-type 设置为 feedback<button class=\"about-btn\" plain=\"true\" open-type=\"feedback\">\r\n    <text class=\"about-btn-text\">反馈建议</text>\r\n</button>\r\n复制代码2.小程序客服小程序的 button 中的 open-type 拥有开放能力,在微信公众平台中启用客服功能，添加客服人员，在代码中添加 button 即可弹出客服聊天界面, open-type 设置为 contact<button class=\"about-btn\" plain=\"true\" open-type=\"contact\" bindcontact=\"handleContact\">\r\n    <text class=\"about-btn-text\">联系客服</text>\r\n</button>\r\n复制代码3.小程序分享此处使用插槽, button 中的 open-type 设置为 share<btn-cmp open-type=\"share\">\r\n    <image slot=\"img\" src=\"images/share.png\" />\r\n</btn-cmp>\r\n复制代码动画小程序动画官方文档开屏动画，设置文字透明度，从0到1，渐渐显示，主要使用到 opacity 去设置组件的透明度，先创建一个动画 animationTip ,持续800ms,然后在 setTimeout(function () {}) 中设置动画出现时间var animationTip = wx.createAnimation({\r\n      //持续时间800ms\r\n      duration: 800,\r\n      timingFunction: 'ease',\r\n    });\r\n    this.animationTip = animationTip;\r\n    animationTip.opacity(0).step()\r\n    this.setData({\r\n      animationTip: animationTip.export()\r\n    })\r\n    setTimeout(function () {\r\n      animationTip.opacity(1).step()\r\n      this.setData({\r\n        animationTip: animationTip.export()\r\n      })\r\n    }.bind(this), 500)\r\n复制代码部署修改 utils 目录下的 config.apiBaseUrl ,改成自己的域名，上传到微信公众号平台，在版本管理中进行发布const config ={\r\n   apiBaseUrl: \"你自己的域名或服务器地址\"\r\n}\r\n复制代码后台功能详解hi-straw项目结构hi-straw\r\n├── common -- 公共模块\r\n├── config -- 配置模块\r\n├── controller -- controller接口\r\n├── core -- 核心业务模块\r\n|    ├── annontaion -- 注解\r\n|    ├── aop -- aop实现\r\n|    ├── constant -- 常量\r\n|    ├── filter -- 拦截器\r\n|    ├── jwt -- jwt相关\r\n|    └── result -- 结果返回\r\n├── entity -- 实体类\r\n|    ├── dto -- 数据传输\r\n|    └── vo -- 页面传输\r\n├── exception -- 全局异常\r\n├── mapper -- dao层\r\n├── service -- service层\r\n└── util -- 工具类\r\n\r\n复制代码数据库设计CREATE TABLE `t_straw_file` (\r\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) UNSIGNED DEFAULT NULL COMMENT '用户ID',\r\n  `file_path` varchar(255) DEFAULT NULL COMMENT '文件路径',\r\n  `file_name` varchar(100) DEFAULT NULL COMMENT '文件名',\r\n  `file_size` varchar(10) DEFAULT NULL COMMENT '文件大小',\r\n  `props` varchar(255) DEFAULT NULL,\r\n  `status` tinyint(5) UNSIGNED DEFAULT '0' COMMENT '0.正常 -1.删除',\r\n  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT'创建时间',\r\n  PRIMARY KEY (`id`),\r\n    KEY `user_id` (`user_id`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8mb4 COMMENT '用户文件列表';\r\n复制代码CREATE TABLE `t_straw_user` (\r\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\r\n  `user_name` varchar(20) DEFAULT NULL COMMENT '用户名',\r\n  `nickname` varchar(20) DEFAULT NULL COMMENT '用户昵称',\r\n  `user_logo` varchar(250) DEFAULT NULL COMMENT '用户logo',\r\n  `phone_num` varchar(20) DEFAULT NULL COMMENT '手机号',\r\n  `open_id` varchar(55) DEFAULT NULL COMMENT '微信openId',\r\n  `union_id` varchar(20) DEFAULT NULL COMMENT '微信union_id',\r\n  `password` varchar(50) DEFAULT NULL COMMENT '密码',\r\n  `uuid` varchar(20) DEFAULT NULL COMMENT '自定义生成的uuid',\r\n  `last_login` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '最后登陆时间',\r\n\t`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  PRIMARY KEY (`id`),\r\n\tUNIQUE KEY `open_id` (`open_id`) USING HASH\r\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COMMENT '用户表';\r\n复制代码CREATE TABLE `t_straw_user_file_info` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) UNSIGNED NOT NULL COMMENT '用户ID',\r\n  `file_size` int(11) UNSIGNED DEFAULT '0' COMMENT '用户文件大小',\r\n  `left_size` int(11) UNSIGNED DEFAULT '5242880' COMMENT '剩余文件大小',\r\n  `total_size` int(11)UNSIGNED DEFAULT '5242880' COMMENT '用户文件空间大小',\r\n  `file_num` int(11) UNSIGNED DEFAULT '0' COMMENT '文件数量',\r\n  `is_vip` tinyint(5) UNSIGNED DEFAULT '0' COMMENT '是否为vip,1.是 0.否',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `user_id` (`user_id`) USING HASH\r\n) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8mb4 COMMENT'用户文件信息';\r\n复制代码CREATE TABLE `t_straw_user_info` (\r\n  `user_id` int(11)  UNSIGNED NOT NULL COMMENT '用户ID',\r\n  `sex` tinyint(5) UNSIGNED DEFAULT NULL COMMENT '性别',\r\n  `location` varchar(55) DEFAULT NULL COMMENT '位置',\r\n  `platform` varchar(55) DEFAULT NULL COMMENT '平台',\r\n  `birthday` datetime DEFAULT NULL COMMENT '生日',\r\n  PRIMARY KEY (`user_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户详细表';\r\n复制代码代码详解前期准备linux服务器及MySql数据库七牛云账号，可以去七牛云官网申请账号HTTPS证书阿里云获取免费证书微信公众平台小程序开发者账号七牛云文件上传代码 com.w77996.straw.util.QiNiuUtil1.七牛云账号申请七牛云官网申请账号，获得 AccessKey , SecretKey ,并设置七牛云图片 bucket/**\r\n     * 七牛accessKey\r\n     */\r\n    @Value(\"${QiNiu.accessKey}\")\r\n    private String accessKey;\r\n    /**\r\n     * 七牛密钥\r\n     */\r\n    @Value(\"${QiNiu.secretKey}\")\r\n    private String secretKey;\r\n    /**\r\n     * 七牛bucket\r\n     */\r\n    @Value(\"${QiNiu.bucket}\")\r\n    private String bucket;\r\n复制代码2.七牛云SDK引入pom.xml 文件引入七牛云仓库<dependency>\r\n        <groupId>com.qiniu</groupId>\r\n        <artifactId>qiniu-java-sdk</artifactId>\r\n        <version>[7.2.0, 7.2.99]</version>\r\n    </dependency>\r\n复制代码2. 七牛云token生成/**\r\n     * 七牛云生成token\r\n     *\r\n     * @param fileName\r\n     * @return\r\n     */\r\n    public QiNiuAuth generateToken(String userId, String fileName) {\r\n        Auth auth = Auth.create(accessKey, secretKey);\r\n        String key = \"upload/file/000/\" + userId + \"/\" + fileName;\r\n        StringMap putPolicy = new StringMap();\r\n        putPolicy.put(\"returnBody\", \"{\\\"key\\\":\\\"$(key)\\\",\\\"hash\\\":\\\"$(etag)\\\",\\\"bucket\\\":\\\"$(bucket)\\\",\\\"fsize\\\":$(fsize)}\");\r\n        long expireSeconds = 3600;\r\n        String upToken = auth.uploadToken(bucket, key, expireSeconds, putPolicy);\r\n        Map<String, String> resultMap = Maps.newHashMapWithExpectedSize(3);\r\n        resultMap.put(\"domain\", \"https://www.w77996.cn\");\r\n        resultMap.put(\"key\", key);\r\n        resultMap.put(\"upToken\", upToken);\r\n        return new QiNiuAuth(\"https://www.w77996.cn\", key, upToken);\r\n    }\r\n复制代码3.上传文件代码编写/**\r\n     * 上传图片\r\n     *\r\n     * @param file\r\n     * @param key\r\n     * @param token\r\n     * @return\r\n     */\r\n    public String uploadImage(MultipartFile file, String key, String token) {\r\n        Configuration cfg = new Configuration(Zone.zone2());\r\n        UploadManager uploadManager = new UploadManager(cfg);\r\n        String filePath = null;\r\n        //生成上传凭证，不指定key的情况下，以文件内容的hash值作为文件名\r\n        Response response = null;\r\n        try {\r\n            byte[] uploadBytes = file.getBytes();\r\n            Auth auth = Auth.create(accessKey, secretKey);\r\n            String upToken = auth.uploadToken(bucket);\r\n            try {\r\n                response = uploadManager.put(uploadBytes, key, upToken);\r\n                //解析上传成功的结果\r\n                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);\r\n                log.info(\"上传结果 {} {}\", putRet.hash, putRet.key);\r\n                filePath = putRet.key;\r\n            } catch (QiniuException ex) {\r\n                try {\r\n                    response = ex.response;\r\n                    log.error(response.bodyString());\r\n                } catch (QiniuException ex2) {\r\n                    //ignore\r\n                    ex.printStackTrace();\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            //ignore\r\n            ex.printStackTrace();\r\n        }\r\n        return filePath;\r\n    }\r\n复制代码4.删除图片/**\r\n     * 删除图片\r\n     *\r\n     * @param key\r\n     */\r\n    public void delete(String key) {\r\n        Configuration cfg = new Configuration(Zone.zone2());\r\n        Auth auth = Auth.create(accessKey, secretKey);\r\n        //实例化一个BucketManager对象\r\n        BucketManager bucketManager = new BucketManager(auth, cfg);\r\n        try {\r\n            //调用delete方法移动文件\r\n            bucketManager.delete(bucket, key);\r\n        } catch (QiniuException e) {\r\n            //捕获异常信息\r\n            throw new GlobalException(ResultCode.ERROR);\r\n        }\r\n    }\r\n复制代码注解+AOP接口限流1. 注解编写代码 com.w77996.straw.core.annotation.Limiter@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\npublic @interface Limiter {\r\n\r\n    /**\r\n     *\r\n     * @return\r\n     */\r\n    String value() default \"\";\r\n\r\n    /**\r\n     * 每秒向桶中放入令牌的数量   默认最大即不做限流\r\n     * @return\r\n     */\r\n    double perSecond() default Double.MAX_VALUE;\r\n\r\n    /**\r\n     * 获取令牌的等待时间  默认0\r\n     * @return\r\n     */\r\n    int timeOut() default 0;\r\n\r\n    /**\r\n     * 超时时间单位\r\n     * @return\r\n     */\r\n    TimeUnit timeOutUnit() default TimeUnit.MILLISECONDS;\r\n}\r\n\r\n复制代码2.AOP实现代码 com.w77996.straw.core.aop.RateLimitAspect@Aspect\r\n@Component\r\n@Slf4j\r\npublic class RateLimitAspect {\r\n\r\n    private RateLimiter rateLimiter = RateLimiter.create(Double.MAX_VALUE);\r\n\r\n    /**\r\n     * 定义切点\r\n     * 1、通过扫包切入\r\n     * 2、带有指定注解切入\r\n     */\r\n    @Pointcut(\"@annotation(com.w77996.straw.core.annotation.Limiter)\")\r\n    public void checkPointcut() {\r\n    }\r\n\r\n    @ResponseBody\r\n    @Around(value = \"checkPointcut()\")\r\n    public Object aroundNotice(ProceedingJoinPoint pjp) throws Throwable {\r\n        log.info(\"拦截到了{}方法...\", pjp.getSignature().getName());\r\n        Signature signature = pjp.getSignature();\r\n        MethodSignature methodSignature = (MethodSignature) signature;\r\n        //获取目标方法\r\n        Method targetMethod = methodSignature.getMethod();\r\n        if (targetMethod.isAnnotationPresent(Limiter.class)) {\r\n            //获取目标方法的@Limiter注解\r\n            Limiter limiter = targetMethod.getAnnotation(Limiter.class);\r\n            rateLimiter.setRate(limiter.perSecond());\r\n            if (!rateLimiter.tryAcquire(limiter.timeOut(), limiter.timeOutUnit())) {\r\n                log.info(\"rateLimiter lock\");\r\n                return Result.error(ResultCode.BUSY);\r\n            }\r\n        }\r\n        return pjp.proceed();\r\n    }\r\n}\r\n复制代码3. 注解使用限定每秒只能调用一次，如果超出，则返回 Result.error(ResultCode.BUSY)@GetMapping(\"/limit\")\r\n    @Limiter(perSecond = 1.0, timeOut = 500)\r\n    public String testLimiter() {\r\n        return \" success\";\r\n    }\r\n复制代码JWT实现1.jwt生成使用JwtUtil生成jwt Token/**\r\n     * 生成jwt\r\n     *\r\n     * @param userId\r\n     * @return\r\n     */\r\n    public static String createJWT(String userId) {\r\n        String token = JwtHelper.createJWT(userId, Constant.JWT_CLIENT_ID,\r\n                Constant.JWT_NAME, Constant.JWT_EXPIRES_SECOND, Constant.JWT_BASE64_SECRET);\r\n        return token;\r\n    }\r\n复制代码2.token解析成userId将userId放入token中，在请求接口时可以通过请求Header获取Bearer {token}进行解码，从而获取userId。/**\r\n     * 通过token获取用户信息\r\n     *\r\n     * @return\r\n     */\r\n    public String getUserIdByToken() {\r\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\r\n        String accessToken = request.getHeader(\"Authorization\");\r\n        if (StringUtils.isEmpty(accessToken) || accessToken.length() < 20) {\r\n            throw new GlobalException(ResultCode.ERROR_TOKEN_NULL);\r\n        }\r\n        accessToken = accessToken.substring(7);\r\n        if (\"admin\".equals(accessToken)) {\r\n            return \"1\";\r\n        }\r\n        Claims claims = JwtHelper.parseJWT(accessToken, Constant.JWT_BASE64_SECRET);\r\n        return claims.getSubject();\r\n    }\r\n复制代码3.拦截器+注解方式进行token鉴权代码 com.w77996.straw.core.annotation.IgnoreToken 先设置忽略token的注解/**\r\n * @description: 忽略token\r\n * @author: w77996\r\n **/\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(value={ElementType.METHOD,ElementType.TYPE})\r\npublic @interface IgnoreToken {\r\n}\r\n复制代码代码 com.w77996.straw.core.filter.TokenFilter 拦截器 TokenFilter 实现 HandlerInterceptor ，在每次请求进来时进行拦截,在调用controller之前都会调用 perHandle ,所以在 perHandler 内获取方法名的注解，判断是否有ignoreToken的注解，然后进行jwt的校验。@Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\r\n        IgnoreToken ignoreToken = handlerMethod.getBeanType().getAnnotation(IgnoreToken.class);\r\n        log.info(\"enter preHandle {}\",request.getRequestURL());\r\n        if (ignoreToken == null) {\r\n            ignoreToken = handlerMethod.getMethodAnnotation(IgnoreToken.class);\r\n        }\r\n        if (ignoreToken != null) {\r\n            log.info(\"ignoreToken not null\");\r\n            return true;\r\n        }\r\n        log.info(\"ignoreToken  null\");\r\n        String token = request.getHeader(\"Authorization\");\r\n        if(token != null){\r\n            log.info(\"token is {}\",token);\r\n            if (\"admin\".equals(token.substring(7))) {\r\n                return true;\r\n            }\r\n            Claims claims = JwtHelper.parseJWT(token.substring(7), Audience.BASE64SECRET);\r\n            if(claims != null){\r\n                log.info(\"claims is {} {}\",claims.toString(),claims.getSubject());\r\n                return true;\r\n            }else{\r\n                log.info(\"claims is null\");\r\n                throw new GlobalException(ResultCode.ERROR_AUTH);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n复制代码4.实现web拦截器代码 com.w77996.straw.config.WebMvcAdapterConfig 不拦截 /druid/* 的接口/**\r\n * @description: web拦截器\r\n * @author: w77996\r\n **/\r\n@Component\r\npublic class WebMvcAdapterConfig extends WebMvcConfigurationSupport {\r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        registry.addInterceptor(new TokenFilter()).excludePathPatterns(\"/druid/*\");\r\n    }\r\n}\r\n复制代码Druid监控配置代码 com.w77996.straw.config.DruidConfig 项目运行后访问 http://ip:port/druid ,输入账号 admin 密码 amdin 即可访问@Configuration\r\npublic class DruidConfig {\r\n\r\n    @Bean\r\n    @ConfigurationProperties(\"spring.datasource\")\r\n    public DataSource druidDataSource() {\r\n        DruidDataSource dataSource = new DruidDataSource();\r\n        return dataSource;\r\n    }\r\n\r\n    @Bean\r\n    public ServletRegistrationBean druidStatViewServlet() {\r\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\r\n        // IP白名单 (没有配置或者为空，则允许所有访问)e\r\n        registrationBean.addInitParameter(\"allow\", \"\");\r\n        // IP黑名单 (存在共同时，deny优先于allow)\r\n        registrationBean.addInitParameter(\"deny\", \"\");\r\n        registrationBean.addInitParameter(\"loginUsername\", \"admin\");\r\n        registrationBean.addInitParameter(\"loginPassword\", \"admin\");\r\n        registrationBean.addInitParameter(\"resetEnable\", \"false\");\r\n        return registrationBean;\r\n    }\r\n\r\n    @Bean\r\n    public FilterRegistrationBean druidWebStatViewFilter() {\r\n        FilterRegistrationBean registrationBean = new FilterRegistrationBean(new WebStatFilter());\r\n        registrationBean.addInitParameter(\"urlPatterns\", \"/*\");\r\n        registrationBean.addInitParameter(\"exclusions\", \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\");\r\n        return registrationBean;\r\n    }\r\n}\r\n复制代码全局异常拦截全局异常拦截主要是依靠 @RestControllerAdvice 注解，在方法上使用 @ExceptionHandler(value = Exception.class) 代表拦截所有Exception,然后进行对应的操作@RestControllerAdvice\r\npublic class GlobalExceptionHandler {\r\n\r\n    /**\r\n     * 全局错误拦截\r\n     *\r\n     * @param e\r\n     * @return\r\n     */\r\n    @ExceptionHandler(value = Exception.class)\r\n    private Result<Object> exceptionHandler(Exception e) {\r\n        if (e instanceof GlobalException) {\r\n            GlobalException ex = (GlobalException) e;\r\n            return Result.error(ex.getCode());\r\n        }\r\n        return Result.error(ResultCode.ERROR.getCode(),e.getMessage());\r\n    }\r\n}\r\n复制代码微信登录需要在微信公共平台获取对应的appId,appSec，小程序获取到code之后发送给后台，后台获取code向微信发送http请求，使用的是restTemplate,但是需要注意编码，微信编码返回是ISO-8859-1；调用成功后可以拿到用户的openId,再去数据库中获取对应的用户信息，进行登陆更新及用户创建的逻辑处理@RestController\r\n@RequestMapping(\"/wx\")\r\n@Slf4j\r\npublic class WxController {\r\n\r\n    @Autowired\r\n    private IUserService iUserService;\r\n\r\n    @Value(\"${wx.appId}\")\r\n    private String wxAppId;\r\n\r\n    @Value(\"${wx.appSec}\")\r\n    private String wxAppSec;\r\n\r\n    /**\r\n     * 通过code获取openId\r\n     *\r\n     * @param wxLoginDto\r\n     * @return\r\n     */\r\n    @IgnoreToken\r\n    @PostMapping(\"/code\")\r\n    public Result getUserInfoByCode(@RequestBody WxLoginDto wxLoginDto) {\r\n        log.info(\"enter getUserInfoByCode\");\r\n        //微信授权获取openId\r\n        String reqUrl = \"https://api.weixin.qq.com/sns/jscode2session?appid=\" + wxAppId + \"&secret=\" + wxAppSec + \"&js_code=\" + wxLoginDto.getCode() + \"&grant_type=authorization_code\";\r\n        JSONObject wxAuthObject = RestHttpClient.client(reqUrl, HttpMethod.GET, null);\r\n        log.info(\"wxAuthObject {}\", wxAuthObject.toJSONString());\r\n        WxTokenDto wxTokenDto = JSONObject.parseObject(wxAuthObject.toJSONString(), WxTokenDto.class);\r\n        log.info(\"wxTokenDto {}\", wxTokenDto.toString());\r\n        Map<String, Object> tokenMapper = Maps.newHashMapWithExpectedSize(2);\r\n        //生成新用户\r\n        UserEntity userEntity = iUserService.getUserByOpenId(wxTokenDto.getOpenid());\r\n        if (!ObjectUtils.allNotNull(userEntity)) {\r\n            WxUserInfoDto wxUserInfoDto = new WxUserInfoDto();\r\n            wxUserInfoDto.setNickname(wxLoginDto.getNickName());\r\n            wxUserInfoDto.setUserLogo(wxLoginDto.getUserLogo());\r\n            wxUserInfoDto.setSex(wxLoginDto.getSex());\r\n            wxUserInfoDto.setLastLogin(new Date());\r\n            wxUserInfoDto.setOpenId(wxTokenDto.getOpenid());\r\n            wxUserInfoDto.setLocation(StringUtils.join(new String[]{wxLoginDto.getCountry(), wxLoginDto.getProvince(), wxLoginDto.getCity()}, \"-\"));\r\n            iUserService.createNewUser(wxUserInfoDto);\r\n            log.info(\"create new user {}\", wxUserInfoDto);\r\n        }\r\n        tokenMapper.put(\"token\", JwtHelper.createJWT(userEntity.getId() + \"\"));\r\n        return Result.success(tokenMapper);\r\n    }\r\n}\r\n复制代码spring boot + maven多环境打包1.resouce下的yml文件项目环境分为 dev 和 prod 两种， resource 文件下默认加载 application.yml 。application.yml\r\nspring:\r\n    profiles:\r\n      active: @spring.profiles.active@\r\n复制代码@spring.profiles.active@ 对应的为pom.xml文件中profiles下的 spring.profiles.active 属性2.pom.xml配置默认情况下使用 dev 环境下的配置信息<profiles>\r\n        <profile>\r\n            <id>dev</id>\r\n            <activation>\r\n                <activeByDefault>true</activeByDefault>\r\n            </activation>\r\n            <properties>\r\n                <!-- default Spring profiles -->\r\n                <spring.profiles.active>dev</spring.profiles.active>\r\n            </properties>\r\n        </profile>\r\n        <profile>\r\n            <id>prod</id>\r\n            <properties>\r\n                <!-- default Spring profiles -->\r\n                <spring.profiles.active>prod</spring.profiles.active>\r\n            </properties>\r\n        </profile>\r\n    </profiles>\r\n复制代码3.不同环境打包打包 prod 环境：执行 mvn package -Pprod -DskipTests打包 dev 环境：执行 mvn package -Pdev -DskipTests4.项目打包命名在 properties 属性中添加时间格式，然后再 build 中添加 fileName 格式化文件名。<artifactId>hi-straw</artifactId>\r\n    <version>1.0.0</version>\r\n    <properties>\r\n        ...\r\n        <maven.build.timestamp.format>yyyy-MM-ddHHmm</maven.build.timestamp.format>\r\n    </properties>\r\n    <build>\r\n        ...\r\n        <finalName>\r\n            ${project.artifactId}-${project.version}-${spring.profiles.active}_${maven.build.timestamp}\r\n        </finalName>\r\n    </build>\r\n\r\n复制代码打包完成后生成的jar： hi-straw-1.0.0-prod_2019-04-091533.jarshell脚本编写登陆服务器，clone项目至 /root/repo_git/ 目录下,执行进入 script 目录下，执行 ./build.sh ，需要将 RELEASE_HOST 换成你自己的服务器地址，方便做保存备份#!/bin/sh\r\nset -e\r\n#打包的服务器地址\r\nRELEASE_HOST=\"你自己的服务器地址\"\r\n#打包的环境\r\nRELEASE_ENV=prod\r\n#项目目录\r\nBASE_DIR=/root/repo_git/Histraw\r\n#进入项目目录\r\ncd ${BASE_DIR}\r\n#执行git拉去最新的代码\r\necho \"pulling changes...\"\r\ngit pull origin master\r\necho \"pulling changes... finish\"\r\necho \"building...\"\r\n#执行mvn命令打包\r\nmvn clean\r\nmvn package -P${RELEASE_ENV} -DskipTests docker:build\r\necho \"building...finish\"\r\necho \"env =${RELEASE_ENV}\"\r\n#for HOST in ${RELEASE_HOST}; do\r\n#进行拷贝及备份\r\nRELEASE_TARGET=root@${RELEASE_HOST}:~/release/\r\necho \"copying to $RELEASE_TARGET...\"\r\nscp ${BASE_DIR}/target/*.jar ${RELEASE_TARGET}\r\necho \"copying to $RELEASE_TARGET...done\"\r\n#done\r\n复制代码执行 docker images查看刚刚打包好的docker镜像maven + docker 打包部署1.docker环境安装卸载老旧的版本（若未安装过可省略此步）：sudo apt-get remove docker docker-engine docker.io\r\n复制代码安装最新的docker：curl -fsSL get.docker.com -o get-docker.sh\r\nsudo sh get-docker.sh\r\n复制代码确认Docker成功安装：docker run hello-world\r\n复制代码2.项目编译打包在 src/main/docker 下建立 dockerFile 文件FROM openjdk:8-jdk-alpine\r\nVOLUME /tmp\r\nADD *.jar app.jar\r\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]\r\n复制代码pom.xml配置docker打包，配合shell脚本在linux实现maven自动打包docker<!-- Docker maven plugin -->\r\n    <plugin>\r\n        <groupId>com.spotify</groupId>\r\n        <artifactId>docker-maven-plugin</artifactId>\r\n        <version>1.0.0</version>\r\n        <configuration>\r\n            <imageName>${project.artifactId}</imageName>\r\n            <dockerDirectory>src/main/docker</dockerDirectory>\r\n            <resources>\r\n                <resource>\r\n                    <targetPath>/</targetPath>\r\n                    <directory>${project.build.directory}</directory>\r\n                    <include>${project.build.finalName}.jar</include>\r\n                </resource>\r\n            </resources>\r\n        </configuration>\r\n    </plugin>\r\n<!-- Docker maven plugin -->\r\n复制代码执行 docker images 查看刚刚打包的docker镜像执行 docker run --name hi-straw -p 8989:8989 -t hi-straw 启动镜像执行 dockers ps 查看已启动docker镜像nginx配置https1.安装nginx登陆到服务器，执行$ apt-get update // 更新软件\r\n$ apt-get install nginx // 安装nginx\r\n复制代码2. 获取证书可以去阿里云获取免费证书将生成的证书放入 /etc/nginx/sites-enabled/cert/ (具体看你将nginx安装在哪个目录下)3. 配置nginx文件新建一个https.confserver {\r\n    listen 443;\r\n    server_name 你自己的域名;\r\n    ssl on;\r\n    ssl_certificate  cert/你自己的证书.pem;\r\n    ssl_certificate_key cert/你自己的证书.key;\r\n    ssl_session_timeout 5m;\r\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\r\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\r\n    ssl_prefer_server_ciphers on;\r\n    location / {\r\n        #项目部署的ip和端口\r\n    \tproxy_pass http://localhost:port;\r\n\r\n    }\r\n}\r\n复制代码配置完成后，检查一下nginx配置文件是否可用nginx -t //检查nginx配置文件\r\n复制代码配置正确后，重新加载配置文件使配置生效nginx -s reload //使配置生效\r\n复制代码如需重启nginx，用以下命令：service nginx stop //停止\r\nservice nginx start //启动\r\nservice nginx restart //重启\r\n复制代码部署修改 resource 下的 application-dev.yml 和 application-prod.yml 中你自己申请的微信息及七牛云信息修改，修改数据库地址，用户名和密码#七牛\r\nqiNiu:\r\n  accessKey: 你申请的七牛云key\r\n  secretKey: 你申请的七牛云sec\r\n  bucket: 你申请的七牛云bucket\r\n  domain: 你申请的七牛云domain\r\n#微信\r\nwx:\r\n  appId: 你申请的微信id\r\n  appSec: 你申请的微信sec\r\n复制代码spring:\r\n  datasource:\r\n    name: graduate\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n    url: 数据库地址\r\n    username: 数据库用户名\r\n    password: 数据库密码\r\n复制代码修改 script 目录下 build.shRELEASE_HOST=\"你自己的服务器地址\"\r\n复制代码项目的服务器7月15号到期了……哪位大佬资助一下服务器，感激不尽捐助"}
{"title": "微信小程序探险记 - 生成图片分享 ", "author": "Rolan", "pub_time": "2019-7-11 00:32", "content": "前言\r\n最近几天作者一直在忙着开发一个C端微信小程序商城项目(wepy 1.7.x, 不得不吐槽坑超级多，被虐的不要不要的，下个版本打算 taro + ts 重构, 差点被逼疯了..)\r\n今天就有个生成图片分享的需求，需要实现。具体探险经历如下\r\n业务需求\r\n\r\n如图所示，在点击保存的时候，生成上方的图片并保存。\r\n具体实现\r\n\r\n需要保存的区域要用canvas绘制，之后使用wx.canvasToTempFilePath 生成本地图片 以及 wx.saveImageToPhotosAlbum 保存图片\r\n\r\n1. 创建 canvas 画布\r\n<canvas\r\n  class=\"home-share__canvas\" // 内部添加样式，主要是宽高\r\n  canvas-id=\"shareCanvas\"\r\n/>\r\n复制代码2. 绘制画布\r\nconst ctx = wx.createCanvasContext('shareCanvas')\r\n// banner图\r\nctx.drawImage('../../../assets/share/banner.png', 0, 0, 240, 40)\r\nctx.drawImage('../../../assets/share/title.png', 82, 9.5, 76, 21)\r\n\r\n// 画矩形\r\nctx.setFillStyle('white')\r\nctx.fillRect(0, 40, 240, 240)\r\n\r\nctx.setFillStyle('white')\r\nctx.fillRect(0, 280, 240, 100)\r\n\r\n// 价格文字\r\nctx.setFillStyle('#ff0136') // 文字颜色：黑色\r\nctx.setFontSize(30) // 文字字号：22px\r\n\r\nctx.font = 'bold 30px DIN Alternate' // 字体可以这样设置样式\r\nctx.fillText('996', 20, 300)\r\n\r\n......\r\n\r\nctx.stroke()\r\nctx.draw()\r\n复制代码3. 生成图片\r\nwx.canvasToTempFilePath({\r\n  canvasId: 'shareCanvas',\r\n  success: function(res) {\r\n    console.log(res.tempFilePath) // 生成的图片地址\r\n  }\r\n})\r\n复制代码4. 保存图片\r\nsaveImageToPhotosAlbum(imgUrl) { // imgUrl 即是上方的 res.tempFilePath\r\n    if (imgUrl) {\r\n        wx.saveImageToPhotosAlbum({\r\n            filePath: imgUrl,\r\n            success: res => {\r\n              wx.showToast({\r\n                title: '保存成功',\r\n                icon: 'success',\r\n                duration: 2000\r\n              })\r\n            },\r\n            fail: err => {\r\n              wx.showToast({\r\n                title: '保存失败',\r\n                icon: 'none',\r\n                duration: 2000\r\n              })\r\n            }\r\n        })\r\n    } else {\r\n      wx.showToast({\r\n        title: '绘制中……',\r\n        icon: 'loading',\r\n        duration: 3000\r\n      })\r\n    }\r\n}\r\n复制代码\r\nps: 需要授权 writePhotosAlbum, 中间需要加入授权的逻辑\r\n\r\nSo Easy\r\n别人写了一半的项目, 持续踩坑中..."}
{"title": "小程序生成海报代码分享 ", "author": "Rolan", "pub_time": "2019-7-12 00:21", "content": "最近趁垃圾分类这个热点，做了一个小程序，里面有一个模块是答题活动，题目答完之后，会生成分数海报，具体如下图所示这里涉及微信小程序的几个知识点如下获取用户个人信息授权保存图片到本地授权canvas文件操作以及下面几个APIwx.getImageInfowx.downloadFilewx.saveFilewx.createCanvasContextwx.canvasToTempFilePathwx.getSettingwx.saveImageToPhotosAlbumwx.authorizewx.saveImageToPhotosAlbum获取背景图片promiseBdImg: function(){\r\n    const _this = this\r\n    const bdImagePath = '../../static/images/common/'\r\n    return new Promise(function (resolve, reject) {\r\n      wx.getImageInfo({\r\n        src: bdImagePath + \"base.png\",\r\n        success: function (res) {\r\n          console.log('promiseBdImg', res)\r\n          resolve(res);\r\n        },\r\n        fail: function(err){\r\n          console.log('2019062007');\r\n          console.log(err);\r\n        }\r\n      })  \r\n    });\r\n  },将背景图片onReady: function () {\r\n    const _this = this\r\n\r\n    //默认进入页面就生成背景图\r\n    var windowWidth = this.data.windowWidth;\r\n    var posterHeight = this.data.posterHeight;\r\n    this.promiseBdImg().then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      //主要就是计算好各个图文的位置\r\n      ctx.drawImage('../../' + res.path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n      ctx.save() // 对当前区域保存\r\n      ctx.draw()\r\n\r\n    }).then( () => {\r\n    \r\n    })    \r\n  },生成海报图片generateImage: function(e){\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    let userInfo = e.detail.userInfo\r\n    console.log('userInfo', userInfo)\r\n    // 更新用户信息\r\n    // api.post('更新用户信息的url', userInfo)\r\n    this.setData({\r\n      userInfo: e.detail.userInfo\r\n    });\r\n\r\n    console.log('2019062006');\r\n    // 头像\r\n    // let promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n    //   resolve(wx.getStorageSync('avatarUrl'))\r\n    // }).catch(res=>{\r\n    //   console.log('catch',res)\r\n    // });\r\n\r\n    wx.showLoading({\r\n      title: '正在生成海报，请稍后'\r\n    })\r\n\r\n    let avatarUrl = userInfo.avatarUrl;\r\n    let nickName = userInfo.nickName;\r\n    let promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n      wx.getImageInfo({\r\n        src: avatarUrl,\r\n        success: function (res) {\r\n          console.log('promiseAvatarImg', res)\r\n          resolve(res);\r\n        },\r\n        fail: function(err){\r\n          console.log('2019070501');\r\n          console.log(err);\r\n        }\r\n      })  \r\n    });\r\n\r\n    const _this = this\r\n\r\n    const qrImagePath = '../../qrcode/'\r\n    let promiseQrcodeImg = new Promise(function (resolve, reject) {\r\n      wx.getImageInfo({\r\n        src: qrImagePath + \"gh_d2778c07ec2e_258.jpg\",\r\n        success: function (res) {\r\n          console.log('promiseQrcodeImg', res)\r\n          resolve(res);\r\n        },\r\n        fail: function(err){\r\n          console.log('2019062007');\r\n          console.log(err);\r\n        }\r\n      })  \r\n    });    \r\n\r\n    var windowWidth = this.data.windowWidth;\r\n    var posterHeight = this.data.posterHeight;\r\n    Promise.all([\r\n      promiseAvatarUrl, promiseQrcodeImg\r\n    ]).then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      //主要就是计算好各个图文的位置\r\n      \r\n      ctx.drawImage(res[0].path,148, 10, 75, 75, 0, 0) // 把图片填充进裁剪的圆形\r\n      ctx.restore() // 恢复\r\n      ctx.save()\r\n      \r\n      ctx.beginPath() // 开始新的区域\r\n      ctx.drawImage('../../' + res[1].path, 128, 266, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\n      ctx.restore() // 恢复\r\n      ctx.save()\r\n\r\n      ctx.beginPath();\r\n      ctx.setTextAlign('center')\r\n      ctx.setFillStyle('#000')\r\n      ctx.setFontSize(22)      \r\n      ctx.fillText('得分'+_this.data.score, 180, 250)\r\n      ctx.setFontSize(18) \r\n      ctx.fillText('欢迎'+ nickName +'参加垃圾分类答题活动', 180, 414)\r\n      ctx.stroke()\r\n      ctx.draw(true)\r\n\r\n    }).then( () => {\r\n      wx.hideLoading()\r\n    })\r\n  },将海报图片保存到本地图片如下所示saveImage: function(){\r\n    var windowWidth = this.data.windowWidth;\r\n    var posterHeight = this.data.posterHeight;\r\n\r\n    var _this = this\r\n    wx.showLoading({\r\n      title: '正在保存海报，请稍后'\r\n    })\r\n    new Promise(function (resolve, reject) {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: windowWidth*2,\r\n        height: posterHeight*2,\r\n        destWidth: windowWidth*2,\r\n        destHeight: posterHeight*2,\r\n        canvasId: 'shareImg',\r\n        success: function (res) {\r\n          console.log(res.tempFilePath);\r\n          _this.setData({\r\n            prurl: res.tempFilePath,\r\n            hidden: false\r\n          })\r\n          resolve(res)\r\n        },\r\n        fail: function (res) {\r\n          console.log(res)\r\n        }\r\n      })\r\n    }).then(res => {\r\n      console.log(res)\r\n      this.save(res)\r\n    })\r\n  },具体代码请移步 https://gitee.com/jgl1210/laj...有不懂得可以在评论区留言"}
{"title": "[打怪升级]小程序评论回复和发贴功能实战（一） ", "author": "Rolan", "pub_time": "2019-7-12 00:23", "content": "在学习成长的过程中，常常会遇到一些自己从未接触的事物，这就好比是 打怪升级 ，每次打倒一只怪，都会获得经验，让自己进步强大。特别是我们这些做技术的， 逆水行舟不进则退 。下面分享下小程序开发中的 打怪升级 经历~先来看下实际效果图，小程序开发中有时会要做一些的功能复杂的组件，比如评论回复和发帖功能等，这次主要讲的是关于 评论模块 的一些思路和实战中的经验，希望能抛砖引玉，给大家一些启发，一同成长~>> （最下面有实战demo的地址，可以直接浏览器打开添加至IDE工具中） <<根据这个demo.gif，本人做了一个简单的流程图，帮助大家理解。下面罗列一些开发中需要“ 打的怪 ”：1、组件目录结构├─components      ---小程序自定义组件\r\n│  ├─plugins      --- （重点）可独立运行的大型模块，可以打包成plugins\r\n│  │  ├─comment         ---评论模块\r\n│  │  │  │  index.js\r\n│  │  │  │  index.json\r\n│  │  │  │  index.wxml\r\n│  │  │  │  index.wxss\r\n│  │  │  │  services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n         │      \r\n         └─submit    ---评论模块子模块：提交评论\r\n                 index.js\r\n                 index.json\r\n                 index.wxml\r\n                 index.wxss为什么要单独做个 评论页面页面（submit） ？因为如果是当前页面最下面input输入的形式，会出现一些兼容问题，比如：不同手机的虚拟键盘高度不同，不好 绝对定位 和完全适配弹窗输入框过小输入不方便，如果是大的textare时，容易误触下面评论的交。注：目录结构，仅供参考。2、NODE端API接口返回结构和页面结构//node：API接口返回\r\n{\r\n    \"data\": {\r\n        \"commentTotal\": 40,\r\n        \"comments\": [\r\n            {\r\n                \"contentText\": \"喜欢就关注我\",   //评论内容\r\n                \"createTime\": 1560158823647,    //评论时间\r\n                \"displayName\": \"智酷方程式\",       //用户名\r\n                \"headPortrait\": \"https://blz.nosdn.127.net/1/weixin/zxts.jpg\",  //用户头像\r\n                \"id\": \"46e0fb0066666666\",  //评论ID  用于回复和举报\r\n                \"likeTotal\": 2,    //点赞数\r\n                \"replyContents\": [   //回复评论\r\n                    {\r\n                        \"contentText\": \"@智酷方程式  喜欢就回复我\",   //回复评论内容\r\n                        \"createTime\": 1560158986524,   //回复时间\r\n                        \"displayName\": \"神秘的前端开发\",   //回复的用户名\r\n                        \"headPortrait\": \"https://blz.nosdn.127.net/1/2018cosplay/fourth/tesss.jpg\",  //回复的用户头像\r\n                        \"id\": \"46e0fb00111111111\",   //回复评论的ID\r\n                        \"likeTotal\": 2,    //回复评论的点赞数\r\n                        \"replyContents\": [],   //回复的回复 盖楼\r\n                        \"replyId\": \"46e0fb001ec222222222\",   //回复评论的独立ID，用于统计\r\n                    },\r\n                    {\r\n                        \"contentText\": \"@智酷方程式： 威武，学习学习\",\r\n                        \"createTime\": 1560407232814,\r\n                        \"displayName\": \"神秘的前端开发\",\r\n                        \"headPortrait\": \"https://blz.nosdn.127.net/1/2018cosplay/fourth/tesss.jpg\",\r\n                        \"id\": \"46e0fb00111111111\",\r\n                        \"likeTotal\": 0,\r\n                        \"replyContents\": [],\r\n                        \"replyId\": \"46e0fb001ec222222222\",\r\n                    }\r\n                ],\r\n                \"replyId\": \"\",\r\n                \"topicId\": \"46e0fb001ec3333333\",\r\n            }\r\n        ],\r\n        \"curPage\": 1,  //当前页面\r\n        //通过ID 判断  当前用户点赞了 哪些评论\r\n        \"likes\": [\r\n            \"46e0fb00111111111\",    \r\n            \"46e0fb001ec222222222\",\r\n            \"46e0fb0066666666\",\r\n        ],\r\n        \"nextPage\": null, //下一页\r\n        \"pageSize\": 20,  //一页总共多少评论\r\n        \"total\": 7,   //总共多少页面\r\n    },\r\n    \"msg\": \"success\",\r\n    \"status\": \"success\"\r\n}<!-- HTML 部分 -->\r\n<block wx:if=\"{{commentList.length>0}}\">\r\n    <!-- 评论模块 -->\r\n    <block wx:for=\"{{commentList}}\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"idx\">\r\n        <view class=\"commentItem\" catchtap=\"_goToReply\" data-contentid=\"{{item.id}}\" data-replyid=\"{{item.id}}\"\r\n            data-battle-tag=\"{{item.displayName}}\">\r\n            <view class=\"titleWrap\">\r\n                <image class=\"logo\" src=\"{{item.headPortrait||'默认图'}}\"></image>\r\n                <view class=\"authorWrap\">\r\n                    <view class=\"author\">{{item.displayName}}</view>\r\n                    <view class=\"time\">{{item.createTime}}</view>\r\n                </view>\r\n                <view class=\"starWrap\" catchtap=\"_clickLike\" data-index=\"{{index}}\" data-like=\"{{item.like}}\"\r\n                    data-contentid=\"{{item.id}}\" data-topicid=\"{{item.topicId}}\">\r\n                    <text class=\"count\">{{item.likeTotal||\"\"}}</text>\r\n                    <view class=\"workSprite icon {{item.like?'starIconHasClick':'starIcon'}}\"></view>\r\n                </view>\r\n            </view>\r\n            <view class=\"text\">\r\n                {{item.contentText}}\r\n            </view>\r\n        </view>\r\n        <!-- 评论的评论 -->\r\n        <block wx:for=\"{{item.replyContents}}\" wx:for-item=\"itemReply\" wx:for-index=\"indexReply\" wx:key=\"idxReply\">\r\n            <view class=\"commentItem commentItemReply\" catchtap=\"_goToReply\" data-contentid=\"{{itemReply.id}}\"\r\n                data-replyid=\"{{item.id}}\" data-battle-tag=\"{{itemReply.displayName}}\">\r\n                ... 和上面类似\r\n            </view>\r\n        </block>\r\n    </block>\r\n    <!-- 加载更多loading -->\r\n    <block wx:if=\"{{isOver}}\">\r\n        <view class=\"more\">评论加载完成</view>\r\n    </block>\r\n</block>通过node提供一个API接口，通过用户的openId来判断是否点赞，这里提供一个 参考的JSON结构。JSON尽量做成array循环的结构方便渲染，根据ID来BAN人和管理。底部加上加载更多的效果，同时，记得做一些兼容，比如默认头像等。3、评论中的一些微信原生交互这里建议很多交互如果不是必须要特别定制，可以才用微信原生的组件，效果和兼容性都有保障，而且方便简单。对评论进行回复/举报<!-- HTML部分 通过绑定事件：_goToReply 进行交互-->\r\n<view class=\"commentItem\" catchtap=\"_goToReply\" data-contentid=\"{{item.id}}\" data-replyid=\"{{item.id}}\"\r\n    data-battle-tag=\"{{item.displayName}}\">\r\n    ... 内部省略\r\n</view>//JS部分  微信原生wx.showActionSheet 显示操作菜单交互\r\n_goToReply(e) {\r\n    //  上面的各种授权判断省略...\r\n    let self = this;\r\n    wx.showActionSheet({\r\n        itemList: ['回复', '举报'],\r\n        success: function (res) {\r\n            if (!res.cancel) {\r\n                console.log(res.tapIndex);\r\n                //前往评论\r\n                if (res.tapIndex == 0) {\r\n                    //判断是否是 评论的评论\r\n                    self._goToComment(replyid);\r\n                }\r\n                //举报按钮\r\n                if (res.tapIndex == 1) {\r\n                    //弹出框\r\n                    self.setComplain(contentid);\r\n                }\r\n            } else { //取消选择\r\n                \r\n            }\r\n        },\r\n        fail(res) {\r\n            console.log(res.errMsg)\r\n        }\r\n    });\r\n}\r\n//当选择“举报”的时候，二次调用 wx.showActionSheet 方法\r\nsetComplain(contentid){\r\n    let complainJson = [\"敏感信息\", \"色情淫秽\", \"垃圾广告\", \"语言辱骂\", \"其它\"];\r\n    wx.showActionSheet({\r\n        itemList: complainJson,\r\n        success: async res => {\r\n            if (!res.cancel) {\r\n                //选择好后，提交举报\r\n                try {\r\n                    let complainResult = await request.postComplainReport(complainJson[index], openid, contentid);\r\n                    if (complainResult.msg == \"success\") {  //提交成功后反馈\r\n\r\n                    } else {\r\n\r\n                    }\r\n                } catch (e) {\r\n                    console.log(e)\r\n                }\r\n            }\r\n        }\r\n    });\r\n}显示操作菜单 wx.showActionSheet 方法说明属性类型说明itemListArray.<string>按钮的文字数组，数组长度最大为 6itemColorstring按钮的文字颜色successfunction接口调用成功的回调函数failfunction接口调用失败的回调函数completefunction接口调用结束的回调函数（调用成功、失败都会执行）使用这个方法，即是主流的做法，也能很好的兼容不同机型，同时给予用户“习惯性体验”。原生评论排序切换<!-- picker组件  html部分-->\r\n<picker bindchange=\"bindPickerChange\" value=\"{{index}}\" range=\"{{array}}\">\r\n    <view class=\"picker\">\r\n        当前选择：{{array[index]}}\r\n    </view>\r\n</picker>// js部分\r\nPage({\r\n    data:{\r\n        //查看评论类型切换\r\n        array: [\"最佳\", \"最新\", \"只看自己\"],\r\n        //选择数组中的第几个显示\r\n        index:0\r\n    },\r\n    bindPickerChange(e) {\r\n        console.log('picker发送选择改变，携带值为', e.detail.value)\r\n        this.setData({\r\n            index: e.detail.value\r\n        })\r\n    }\r\n})picker组件是一个从底部弹起的滚动选择器，这里我们用它来切换不同评论的排序。每次切换都可以通过 bindchange获得对应的变化，通过 e.detail.value获取用户选择的索引值。官方文档： https://developers.weixin.qq....4、传参跳转写评论页let uriData = {\r\n    logo: \"xxx.jpg\",\r\n    type: \"commentReply\",\r\n    title: \"文章：小程序评论，动态发帖开发指北\\n 作者：智酷方程式\",\r\n    openId:\"xxxxxxxxxxx\",\r\n    replyId:\"aaaaaa\"   //用户回复的是哪个评论的ID\r\n};\r\nwx.navigateTo({ url: `/components/plugins/comment/submit/index?uriData=${encodeURIComponent(JSON.stringify(uriData))}` });这个可以用encodeURIComponent的方式处理下参数中的 中文 ，避免跳转发布评论页接收数据时出现乱码。5、发表评论页显示和控制评论的字数<!-- html部分  关于textarea 的配置 -->\r\n<view class='feedback-cont'>\r\n    <textarea auto-focus=\"true\" value=\"{{replyName}}\" maxlength=\"200\" bindinput=\"textareaCtrl\"\r\n        placeholder-style=\"color:#999;\" placeholder=\"留下评论，共同学习，一起进步\" />\r\n    <view class='fontNum'>{{content.length}}/200</view>\r\n</view>\r\n<view class='feedback-btn' bindtap='commentSubmit'>提交</view>// js部分\r\nPage({\r\n    data: {\r\n        //初始化评论内容，如果是回复则通过传参变成 @xxxx的形式\r\n        content: \"@xxxx\",\r\n    },\r\n    textareaCtrl: function (e) {\r\n        if (e.detail.value) {\r\n            this.setData({\r\n                content: e.detail.value\r\n            })\r\n        } else {\r\n            this.setData({\r\n                content: \"\"\r\n            })\r\n        }\r\n    }\r\n})textarea 在小程序中改动不大，这个标签原有的一些属性都可以继续使用，通过配置maxlength来控制字数，同时，设置auto-focus=\"true\"可以让用户进到这个发表评论页面时自动弹出虚拟键盘和光标定位在输入的区域。当然，也可以将 发表评论 和 评论展示区域 做在一起，这个就要考虑到要么通过“小程序API”获取键盘高度，要么将“发布评论”置顶区域显示，也是可以做的，只是相对考虑的点会多些。当时开发评论组件的时候，考虑开发时间短和用户体验，权衡后，最终决定以上方案，希望能给到大家一些参考和借鉴，在其他组件开发中触类旁通。[代码片段]评论回复组件实战demodemo的微信路径： https://developers.weixin.qq....demo的ID： oHs5cMma7N9W如果你装了IDE工具，可以直接访问上面的demo路径通过代码片段将demo的ID输入进去也可添加：总结，“ 组件化思想 ”对于无论做小程序、react/VUE还是其他项目来说， 减少重复开发，提高复用性 都是一个非常重要的点。 评论功能 其实只要理清楚整体思路，做起来难度并不大，通过一些 原生组件 ，可以大大提高开发效率，同时保证良好的兼容性。后面一期还将分享下功能点较多的 发帖组件 开发。"}
{"title": "mpvue框架使用记录 ", "author": "Rolan", "pub_time": "2019-6-25 00:16", "content": "最近公司接了一个订制小程序，是从APP改成微信小程序，考虑用 mpvue 框架来开发，发现还是有些坑的，下面说一下这两天使用下来的感受。template 中不支持 methods 中的函数，也没有filter过滤器，数据要预先处理比较麻烦突然想到可以用组件来预处理数据，比如项目中图片url的拼接和替换域名创建新页面比较繁琐每次创建新页面按常规流程是:新建页面文件夹 → 新建 index.vue ， main.js ， main.json 并填入页面基本内容 → 在项目 app.json 中添加页面信息。最开始我的解决方法是创建了一个模板页面，每次新建页面的时候复制一份，重命名。但是还是很麻烦，需要手动向 app.json 中添加页面路径，干脆用node写了一个快速添加页面的小工具将工具文件 addpage.js 放在mpvue项目根目录，运行 node addpage目前有一个参数可以配置新增页面的属性，是设置vue文件中用到的预处理器类型用法： node addpage wxss ， node addpage sass填入需要创建的页面路径和标题就会在 src/pages/ 下创建页面，包含三个基本文件，并自动向app.json 中写入本次创建的路径 支持多级目录页面的创建，方便分类页面，如 demo/demo1 , demo/demo2要注意的是，输入的路径下有其他页面时，会创建失败，比如创建了 demo/demo1 后，再创建 demo 就会失败如果改变了目录结构请删除 dist 文件夹重新构建下面是addpage.js的全部代码const fs = require('fs')\r\nconst readline = require('readline')\r\nconst path = require('path')\r\nconst colors = require('colors')\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n})\r\n\r\n//获取运行时附带参数，目前只定义了vue文件中的css语言类型和页面标题\r\nlet arguments = process.argv.splice(2);\r\nlet caaLang = arguments[0]\r\n\r\nlet appJson = JSON.parse(fs.readFileSync('./src/app.json', 'utf8').toString())\r\n\r\nrl.question(' 请输入页面路径: '.bgBlue, (pathStr) => {\r\n  rl.question(' 请输入页面标题: '.bgBlue, (title) => {\r\n    pageTitle = title\r\n    pageCreate(pathStr)\r\n  })\r\n})\r\n\r\nfunction pageCreate(pathStr){\r\n  let jsonPush = `pages/${pathStr}/main`\r\n  let stop = false\r\n  appJson.pages.forEach((item) => {\r\n    let pathArr = item.split('/')\r\n    let pathStrArr = pathStr.split('/')\r\n    if (pathArr.length > 3 && pathStrArr.length === 1 && pathArr.indexOf(pathStrArr[0]) !== -1) {\r\n      stop = true\r\n    }\r\n  })\r\n\r\n  if (stop) {\r\n    console.log(' 此路径下有其他页面，不可直接作为页面路径 '.bgRed);\r\n    rl.close()\r\n    return\r\n  }\r\n\r\n  if (appJson.pages.indexOf(jsonPush) !== -1) {\r\n    console.log(' 此页面已存在 '.bgRed)\r\n    rl.close()\r\n    return\r\n  }\r\n  //app.json pages数组中没有，项目结构中有，此时已有的文件夹会被删除\r\n  deleteFolder('./src/pages/' + pathStr)\r\n  try {\r\n    mkdirsSync('./src/pages/' + pathStr)\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n\r\n  if (writePage('./src/pages/' + pathStr)) {\r\n    //加入本次创建的页面路径\r\n    appJson.pages.push(jsonPush)\r\n    //写入app.json\r\n    fs.writeFile('./src/app.json', JSON.stringify(appJson, null, \"\\t\"), function (err) {\r\n      if (err) {\r\n        console.error(err)\r\n      }\r\n      console.log(' ----------新增成功---------- '.bgGreen)\r\n      rl.close()\r\n    })\r\n  }\r\n}\r\n\r\n//删除文件夹\r\nfunction deleteFolder(path) {\r\n  var files = [];\r\n  if (fs.existsSync(path)) {\r\n    files = fs.readdirSync(path);\r\n    files.forEach(function (file, index) {\r\n      var curPath = path + \"/\" + file;\r\n      if (fs.statSync(curPath).isDirectory()) { // recurse\r\n        deleteFolder(curPath);\r\n      } else { // delete file\r\n        fs.unlinkSync(curPath);\r\n      }\r\n    });\r\n    fs.rmdirSync(path);\r\n  }\r\n}\r\n//创建多级目录\r\nfunction mkdirsSync(dirname) {\r\n  if (fs.existsSync(dirname)) {\r\n    return true;\r\n  } else {\r\n    if (mkdirsSync(path.dirname(dirname))) {\r\n      fs.mkdirSync(dirname);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\n//写入目标页面的三个文件\r\nfunction writePage(path) {\r\n  try {\r\n    fs.writeFileSync(path + '/index.vue', `<template>\r\n  <div class=\"page-container\">\r\n\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {}\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"${caaLang?caaLang:'scss'}\" scoped>\r\n.page-container {\r\n  min-height: 100vh;\r\n  background-color: #f5f5f5;\r\n  background-image: linear-gradient(to bottom, #00d164, #00d164);\r\n  background-repeat: no-repeat;\r\n  background-size: 100% 170rpx;\r\n  background-position: top center;\r\n  padding-bottom: 65rpx;\r\n}\r\n</style>`, 'utf8');\r\n    fs.writeFileSync(path + '/main.js', `import Vue from 'vue'\r\nimport App from './index'\r\n    \r\nconst app = new Vue(App)\r\napp.$mount()`, 'utf8')\r\n    fs.writeFileSync(path + '/main.json', `{\r\n  \"navigationBarTitleText\": \"${pageTitle}\"\r\n}`, 'utf8')\r\n    return true\r\n  } catch (error) {\r\n    //写入错误删除该文件夹\r\n    deleteFolder(path)\r\n    console.log(' 创建页面失败 '.bgRed);\r\n    throw error\r\n  }\r\n}\r\n复制代码个人博客【花喵电台】"}
{"title": "小程序技术演进史 ", "author": "Rolan", "pub_time": "2019-6-25 00:22", "content": "【CSDN 编者按】小程序这个由微信带头的产物，格外鲜明地体现了移动互联网的「时机」这个词，早在微信小程序之前，有力推轻应用的百度，有来自 HTML5 中国产业联盟的 DCloud 所主张的流应用，但最终却都已经淹没在了移动互联网的历史长河之中。唯有微信小程序风生水起，更是带动了巨头们的争相入场。小程序迎来了专属于中国移动互联网的群雄逐鹿的时代。本文作者王安即是流应用的创造者，作为移动领域的老兵，他依然在矢志不移地构建移动开发工具框架及生态，从原生应用到 HTML5 再到如今的小程序，他是这段历史的见证者、参与者。从这篇文章中，我们能够鲜活地看到小程序的技术演进历程，以及对于所有开发者来说，终将去往何处。作者 | 王安责编 | 唐小引封图 | CSDN 付费下载自东方 IC出品 | CSDN（ID：CSDNnews）中国特色的移动互联网时代伴随着 QQ 小程序面向用户开放，这个手机端月活 7 亿的巨无霸正式入场。小程序，终于成为了超级 App 的标配。盘点下已经支持小程序的超级 App：微信、企业微信、QQ、支付宝、高德地图、手机淘宝、百度、百度贴吧、百度地图、今日头条、抖音……这些璀璨耀眼的名字，背后都是巨大的流量。在这群超级 App 的支持下，中国的移动互联网格局被彻底改变。这个有中国特色的移动互联网时代，被称为“小程序时代”。这是继手机支付后，中国的移动互联网领先世界的第二个代表事物。中国的技术标准、开发者生态，第一次得到大规模的普及应用，而且很明显，小程序在功能和体验上均超过了 HTML5。中国人能建立开发者生态吗？这个命题曾一度让人怀疑。小程序完成了这一步突破，这是一场值得歌颂的中国技术生态发展史。让我们来回顾下这场技术生态革命，是如何开始，又将要去向何方。罗马不是一天建成的小程序不是一天发明出来的HTML5 于 2007 年在 W3C 立项，与 iPhone 发布同年。乔布斯曾期待 HTML5 能帮助 iPhone 打造起应用生态系统。但 HTML5 的发展速度并不如预期，它虽然成功地实现了打破 IE+Flash 垄断局面的目标，却没有达到承载优秀的移动互联网体验的地步。于是在 iPhone 站稳脚跟后，发布了自己的 App Store，开启了移动互联网的原生应用时代。随后的 Android，本来是基于 Linux 的 OS，与之同期的 MeeGo 等竞争对手采用 C + HTML5 的双模应用生态策略，然而 C 的开发难度太大，HTML5 体验又不行。Android 依靠 Java 技术生态，在竞争中脱颖而出。于是 在移动互联网初期，应用生态被定了基调 —— 原生开发。在那个时候，硬件不行，也没有其他办法，原生开发才能在低配硬件上带来商用体验。但大家都在怀念 HTML，那种无需安装更新、即点即用，直达二级页面的特点，一直让人迷恋。图源：CSDN 付费下载自东方 IC国内有一批做浏览器的厂商，尝试去改进 HTML5，他们提出了 轻应用 的概念。通过给 WebView 扩展原生能力，补充 JS API，让 HTML5 应用可以实现更多功能。不过这类业务没有取得成功，HTML5 的问题不止是功能不足，性能体验是它更严重的问题，而体验问题，不是简单地扩展 JS 能力能搞定的。这类业务发展的顶峰，是微信的 JS SDK。作为国内事实上最大的手机浏览器，微信为它的浏览器内核扩充了大量 JS API，让开发者可以用 JS 调用微信支付、扫码等众多 HTML5 做不到的功能。微信 JS SDK 说明文档但微信团队对这套方案的体验仍然不满意，微信钱包栏目里打车、理财等很多应用虽然嵌入了 JS SDK，但每次点击要等半天白屏，让人用着很痛苦，他们在业内开始寻找新的解决方案。业内早有专业团队看到了相同的问题。与浏览器不同，Hybrid 应用是另一个细分领域。它们为开发者提供使用 JS 编写跨平台应用的工具，为了让 JS 应用更接近原生应用的功能体验，这个行业的从业者做出了很多尝试。笔者所在的 DCloud 即是其中之一，我们 提出了改进 HTML5 的“性工能”障碍的解决方案 —— 通过工具、引擎优化、开发模式调整，让开发者可以通过 JS 写出更接近原生 App 体验的应用。多 WebView 模式，原生接管转场动画、下拉刷新、Tab 分页，预载 WebView……各种优化技术不停迭代，终于让 Hybrid 应用取得了性能体验的突破。Hybrid 应用和普通的轻应用相比，还有一个巨大的差别：一个是 Client/Server，一个是 Browser/Server。简单来说，Hybrid 应用是 JS 编写的需要安装的 App，而轻应用是在线网页。C/S 的应用在每次页面加载时，仅需要联网获取 JSON 数据；而 B/S 应用除了 JSON 数据外，还需要每次从服务器加载页面 DOM、样式、逻辑代码，所以 B/S 应用的页面加载很慢，体验很差。可是这样的 C/S 应用虽然体验好，却失去了 HTML5 的动态性，仍然需要安装、更新，无法即点即用、直达二级页面。那么 C/S 应用的动态性是否可以解决呢？对此，我们提出了流应用概念，把之前 Hybrid 应用里的运行于客户端的 JS 代码，先打包发布到服务器，制定流式加载协议，手机端引擎动态下载这些 JS 代码到本地，并且为了第一次加载速度更快，实现了应用的边下载边运行。就像流媒体的边下边播一样，应用也可以实现边用边下。在这套方案的保障下，终于解决了之前的各种难题： 让 JS 应用功能体验达到原生，并且可即点即用、可直达二级页面。如今看来，这已经变成了常识。但在当年，先驱们做了无数艰辛探索。这套技术，需要让客户端引擎提前预置在手机上，就像流媒体的普及，建立在 Flash 的装机量巨大的基础上，那么普及这个客户端引擎就变得很重要。2015 年，360 和 DCloud 合作，在 360 手机助手里内嵌了这个客户端引擎，推出了业内第一个商用的小程序，360 称之为 360 微应用。微应用实现了在 360 手机助手的应用下载页面，同时出现了“秒开”按钮，点击后直接使用。并且在 360 手机助手的扫码里，应用的分享里，都实现了扫码获得一个应用，点击分享消息获得一个应用。在 360 手机助手 3.4 版本中上线的中国第一个小程序为了做大生态，DCloud 把这套技术标准，捐献给了 HTML5 中国产业联盟，随后，联盟开始推动更多的超级 App 和手机厂商加入，共同推进动态 App 产业的发展。然而事情并不顺利，巨头们有自己的利益诉求。虽然有一批厂商同意加入联盟共建生态，但最关键的角色，真正的国民应用“微信”，最终决定自立标准、自研引擎，当然技术原理与流应用是基本一致的。2016 年 1 月 11 日，微信公开课，张小龙罕见露面，公布了微信应用号的计划，为这个大事件亲自站台。2016 年 9 月 21 日，微信宣布更名应用号为小程序，面向首批开发者内测。从此，这个词被正式定了下来，“小程序”，成为后续一个时代的代名词。而“流应用”、“微应用”则淹没在历史长河中成为一个令人唏嘘的故事。2017 年 1 月 9 日，微信公开课，小程序面向用户正式推出。从此后，阿里巴巴、手机厂商联盟、百度、今日头条，陆续推出了自己的小程序平台，其中也有很多波折与故事，在有偶然、有必然的过程中，形成了今天的局面。小程序大潮卷入了更多人，并形成了更大的浪潮，最终迎来了不可逆转的小程序时代。生态难，难于上青天发明能解决功能体验和动态性的技术方案，虽然难，但不是最难的事情。最难的是开发者生态的建设。最初 HTML5 中国产业联盟的策略是在 HTML5 上扩展强化，复用现有的 HTML5 生态。当微信的标准完全自立重建时，业内人士都悬着一颗心。在全球，基于 Web 的技术生态已经非常成熟，各种开发工具、框架、组件、模板...提升着开发者的效率。小程序丢弃了国际标准组织 W3C 的 DOM 和 Window 标准，仅仅采用基础 JavaScript。这意味着 HTML5 生态的各种轮子无法复用，要完全重造一个新的小程序开发生态。当初微信推广 JS SDK 时，是那么地顺其自然，开发者纷纷开始使用，因为对于开发者，只是在他们的 H5 版本上补充一些 API 而已。而 小程序初期，充满了开发者的质疑声 ：我的业务迭代那么久，让我重新做一个版本，你的生态到底能不能支撑我的投入？微信用持续而快速的版本升级、高管的站台，告诉大家微信做小程序的决心，并最终通过 2017 年底的跳一跳，引爆了小程序。从此大家的问题不再是我要不要做小程序了，而转向了：既然要做，怎么才能提升小程序的开发效率、降低开发成本？任何一种技术，或者开发模式的演进，在不断成熟的过程中，都遵循着类似的成熟规律：技术标准 -> 基础平台 -> 开发工具 -> 培训市场 -> 框架诞生 -> 周边生态逐步完善 -> 轮子之上的轮子在 HTML5 生态里，已经发展到最终极的形态，比如 Vue 是一个重要框架，而基于 Vue 的各种丰富的 UI 库、测试框架，则是轮子之上的轮子。多层轮子代表着生态的繁荣，也意味着开发者的开发效率更高。可微信的全新标准出现时，它把开发者推回了原始社会，一切都要重来。这在当时看来，并不是一个必然会成功的事情（ 其实直到现在，比如图表类轮子，小程序仍然比不过 HTML5 ）。时至今日，讨论这个标准的选择对错已经没有意义。当支付宝、百度、今日头条都开始参考这个标准做小程序时，时代已经不可阻挡。所幸，最终的结果是，中国人做成了。 在国际标准之外，在中国，终于建立起了自己的技术生态。并且这个生态，给用户带来了更好的体验，给开发者带来了更多流量和变现效率的提升，这是一个比 HTML5 更优秀的生态。野蛮的技术生态成长速度两年时间，中国的小程序开发者如何从原始社会进阶到现代文明？这也是一段有趣的历史。我们来看看小程序技术生态是如何快速成长，走完上面所说的这套技术成熟路线，也就是从技术标准到轮子之上的轮子的。在 Web 世界里，已经成熟到了原生 JS 用量很少的时代了，开发人员大量使用 Vue 等框架，并且在 Vue 的基础之上，又有更多轮子。当中国的开发人员面临重头开始时，他们感受到效率对比的差距，既然时代已不可阻挡，那就拥抱它。勤劳的中国技术人开始蓬勃地建设起了小程序各种周边技术生态。其中比较重要的是 开发框架的迭代 ，我们看看每个小程序开发框架为什么会诞生、流行和衰落。最初的微信小程序，一片荒蛮，一份文档 + 一个难用的 IDE，很多效率工具比如 npm、预处理器这些都不支持，而这些已经是大型项目离不开的工具。于是，第一个标志性的框架出现了 —— WePY。WePY 紧随微信小程序在 2017 年发布，原本是腾讯其他部门的一个个人工程师的作品。在那个年代，WePY 有效地解决了小程序不支持 npm、预处理器的痛点，被引爆后，腾讯官方才把这个框架收编到官方的 GitHub 下。不过 WePY 也面临很多问题，它使用了私有语法，这让它在生态建设上面临很大难度，IDE 着色、语法提示、语法校验、格式化、人员招聘培训等各方面问题制约着它的流行和普及。面对这些问题，人们开始思考，有什么更好的方式，可以复用现有技术生态来快速完善小程序生态？这时候下一个重要框架借势诞生，美团前端在 2018 年初开源了 MPVue。MPVue 采用 Vue 语法来开发小程序，通过对 Vue.js 的底层改造，实现了编译到微信小程序。MPVue 良好地借助了 Vue 的技术生态，周边工具如 IDE、校验器、格式化等支持直接复用、人员招聘培训等生态建设压力大幅下降，受到了大量开发者的欢迎。看着熟悉 Vue 的开发者终于有了趁手的轮子，那熟悉 React 的开发者怎会无动于衷？京东团队是 React 的重度用户，还自研了 JDreact，于是他们开发了 Taro 框架，一款基于 React 语法编写小程序的框架。但 Taro 并不是想简单做一个 MPVue 在 React 世界里的翻版，Taro 相比 MPVue，想要解决更多重要问题。Taro 面世较晚，此时微信、支付宝、百度、头条都已发布或宣传了自己的小程序，开发者面临一个多端开发和适配的问题。于是 Taro 率先支持多端开发，它甚至还能发布到 H5 和 App。图源：京东凹凸实验室当时小程序领域还有一个重要变化，微信开始支持小程序自定义组件。组件是一个成熟框架不可缺的东西，不管是 Vue 还是 React 都有丰富的组件生态。在过去，MPVue 时代，是把 Vue 组件也编译成页面模板，这带来一个很大的性能问题，在复杂页面里（比如长列表）使用组件，更新组件状态会导致整个页面的数据全部从 JS 逻辑层向视图层通讯一次，大量数据通讯会非常卡顿。注意：小程序的逻辑层运行在 V8 或 JSCore 下，和视图层是分离的，通讯阻塞很容易引发性能问题。于是 Taro 把 React 组件编译为新出的微信小程序自定义组件，这种组件在数据更新时，只会更新组件内部的数据，而不是整个页面更新数据，从而大幅减少了数据通信量。这一轮的后浪推前浪很猛，Taro 在性能和多端支持上，都超越了 MPVue。看着 React 阵营取得如此成绩，Vue 阵营自然会继续追击。我们基于 Vue 开发了 uni-app ，它实现了自定义组件编译模式，并在算法上做了很多优化。 另外，之前 MPVue 对 Vue 的语法支持度不太完善，比如过滤器等不支持，在 uni-app 中我们进行了解决。同样，uni-app 也看到了前浪的其他问题：Taro 虽然迈出了多端的第一步，但多端支持能力比较弱，每个平台仍然各自开发大量代码。核心原因，是Taro 在 H5 端和 App 端，并不是一个完整的小程序技术架构，无法保持最大程度的统一。于是 uni-app 在 App 端，使用了一个技术架构相同的小程序引擎，本身就可以直接运行小程序应用，这个引擎搭配小程序代码打包为 App，开发者一行代码不用改，可以同时发布小程序和 App。当然，其 App 引擎从 Hybrid 应用起家，它提供的 API 要比小程序多很多，因为 App 的需求会比小程序丰富，它还支持把 WebView 渲染引擎替换为 Weex 渲染引擎。之后 uni-app 又发布了 H5 版的小程序引擎，原理与小程序的 PC 模拟器相同，实现了良好的跨 H5 版的发布。 于是 uni-app 比较完美地实现了开发一次，7 个平台发布。第一层轮子就这样迅速发展了起来，Web 世界里最成熟的 Vue、React 技术生态被导入了小程序开发生态中。然后轮子之上的轮子开始如火如荼的建设。以 UI 库为例，之前的 UI 库，有 Vue 库、React 库，有 PC 库、H5 库和小程序库，种类繁多，甚至说混乱。比如在 Vue 阵营中，Vant 和 iView 这两个 UI 库，都是同时维护两个版本，它们即有 H5 版，又有小程序版。不止框架作者麻烦，开发者想在多端使用这些 UI 库时，会发现在不同端还需要引入不同的 UI 库，写法都不一样，这让开发者很崩溃。既然已经可以多端开发应用，于是 在多端开发的领域里，开始出现轮子之上的轮子，多端 UI 库 。首先是 Taro 推出了 Taro UI，实现了 H5 和小程序 UI 库的统一，不过可惜 Taro UI 不支持 App 端。然后 uni-app 推出了 uni UI，这个 UI 库同时支持多家小程序、H5、App。由于 uni-app 和 MPVue 同属 Vue 阵营，它们的组件是互通的。于是这两家联合举办了一场插件大赛，建立了插件市场。在中国的前端开发者领域，有很多和国外不一样的地方：一个是国内有小程序，第二个是国内 Vue 的开发者体量远超过 React 和 Angular。这里面很大的原因，是 Vue.js 的作者尤雨溪，是中国人。Vue 和 React 百度指数对比在庞大的 Vue 用户体量支持下，uni-app 和 MPVue 的周边生态迅速发展起来，开发工具、周边轮子、教育培训等生态快速完善。目前在 Vue 阵营下，开发者在 Web 生态下所需的轮子，在多端开发下基本也都有了。短短两年时间，小程序开发生态里几拨迭代，轮子之上的轮子不断涌现，快速进入了成熟期。结语产业还在继续发展，每当底层有重大技术变更时，上层框架世界就会发生新机会。当年 HTML5 标准不统一，浏览器兼容性问题严重，诞生了 jQurey 的机会。而在移动互联网下半场，浏览器兼容已经不再是核心问题，jQurey 的地位被更适合移动互联网的 Vue 替代。我们不知道未来还会有什么新的框架出世，但我们知道方向：对于开发者而言，总是会向着更高的开发效率、更高的性能、更高的投入产出比前进。对于开发商，目前的小程序，虽然发展了 2 年，但流量增长空间仍然巨大，微信之外，很多超级 App 的势能将逐渐释放，整个小程序产业的日活总量有数亿的提升空间。如果开发商能追上这拨红利，就能获得更多增长。而多端框架的出现，可以帮助开发商更好的把握这拨红利。中国的技术发展，此刻正在经历一个分水岭，从全面的技术进口，到开始建设自己的标准和开发者生态。迟早，会开始向外输出，引领世界的进步。不管中美是否开打贸易战，这一转变都是必须做的事情。中国的移动支付、小程序、5G，很多领域已经走在了全球前面。中国人发明的 Vue 已经在影响全球。虽然还有很多困难仍需克服，但我们每个开发者，都是新时代的见证者，更是新生态的建设者！作者简介：王安，DCloud 公司创始人，HTML5 中国产业联盟秘书长。2003 年开始从事移动互联网工作，十几年编程和商业经验，连续创业者。声明：作者独立观点，不代表 CSDN 立场。"}
{"title": "微信小程序实战教程——1.基础知识 ", "author": "Rolan", "pub_time": "2019-6-25 00:32", "content": "微信小程序的语法与vueJS类似，没学过vueJS的同学尽量先过一遍vue再看本教程。首先在微信平台中注册一个账号获得开发者AppID，如下载微信小程序的开发者工具，安装完毕后打开开发者工具创建一个项目，将项目名称位置AppID填入即可。2 文件目录及每个文件的功能微信小程序的文件有四类，分别是.wxml文件，.wxss文件，.js文件，.json文件。 其中.wxml对应.html文件，.wxss文件对应.css文件，.json文件是配置文件。pages文件夹中每一个文件夹代表一个页面，新建的项目有两个页面，分别四index和logs页面，每个页面包含一个.js文件，一个.wxml文件，一个.wxss文件以及一个.json文件。四类文件的作用稍后会讲到。utils文件存放的是工具类，这个文件夹是非必须的，可以直接删掉。project.config.json与sitemap.json初学者可以暂时不理会。2.1 .wxml文件.wxml文件类似我们写的.html文件，但标签上有些不同。使用<view></view>标签代替<div></div>，使用<image></image>代替<img/>，使用<block></block>标签代替<template></template>，引入<text></text>标签等等，后续做项目的时候会了解到更多标签。<!--新建项目的index.wxml文件-->\r\n<view class=\"container\">\r\n  <view class=\"userinfo\">\r\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\r\n    <block wx:else>\r\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" mode=\"cover\"></image>\r\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n    </block>\r\n  </view>\r\n  <view class=\"usermotto\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n</view>\r\n复制代码2.2 .wxss文件.wxss文件就是.css文件。在app.wxss中控制全局样式，在pages文件夹中的页面文件的.wxss文件中控制局部样式。局部样式的优先级大于全局样式。微信小程序推荐的布局方式是弹性布局（ 弹性布局快速入门点这里 ）,使用弹性布局可以很快速的搭建我们的项目。微信小程序为了适配多种不同屏幕大小的设备，采取了一种的响应式单位rpx，使用rpx单位就好像使用百分比作为单位一样实现响应式布局。rpx是一种相对大小，我们使用iphone6的机型时，1px=2rpx，iphone6的大小为375px*667px，对于的rpx为750rpx*1334rpx。关于rpx的更多了解见wxss.html#尺寸单位2.3 .json文件.json文件是项目的配置文件//-新建项目的app.json文件\r\n{\r\n  \"pages\": [\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n  },\r\n  \"sitemapLocation\": \"sitemap.json\"\r\n}\r\n复制代码pages是存放所有页面的数组,每一个使用到的页面都需要写入pages内，不需要写文件后缀，window属性配置的是状态栏的样式，如navigationBarBackgroundColor用于设置背景色，navigationBarTitleText设置状态栏显示的文本，navigationBarTextStyle设置状态栏文本的颜色，只能传入black/white，除此之外还可以配置底部导航栏tabBar等等。app.json文件进行全局配置，每个页面文件夹下还有一个.json文件用于局部配置，局部配置只能配置window属性//局部配置.json文件,这里的配置会覆盖app.json中的window属性\r\n{\r\n  \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n}\r\n复制代码注意事项必须用一对大括号将属性包围起来，写成json字符串的格式。属性名必须用双引号包围起来..json文件中不可以写注释。2.4.js文件小程序的生命周期分为应用声明周期和页面生命周期，应用声明周期函数在app.js中定义，且在小程序运行过程中一直存在内存中处于运行状态，在这里可以定义应用声明周期函数以及定义全局变量。每个页面中的.js文件中则可以定义页面声明周期函数等，语法类似vueJS。小程序为了提高性能，是不允许开发者操作DOM元素的。//新建项目的app.js文件，通过App方法声明\r\nApp({\r\n  onLaunch: function () {\r\n   //页面渲染前执行\r\n  },\r\n  globalData: {\r\n    //定义全局变量\r\n    userInfo: null  \r\n  }\r\n});\r\n//页面的.js文件，通过Page方法声明\r\nPage({\r\n    \r\n});\r\n复制代码3 指令小程序中常用的指令有wx:for、wx:if、wx:elif、wx:else等。//wxml\r\n<view>\r\n    <text wx:if=\"count>0\">{{count}}</text>\r\n    <text wx:elif=\"count<0\">{{count}}</text>\r\n    <text wx:else>{{count}}</text>\r\n</view>\r\n//js\r\ndata() {\r\n    return {\r\n        count:0\r\n    }\r\n}\r\n复制代码wx:if、wx:elif、wx:else的逻辑等同于if else。//wxml\r\n<view>\r\n    <text wx:for=\"arr\" wx:for-item=\"value\" wx:for-index=\"index\">\r\n        {{index}}.{{value}}\r\n    </text>\r\n</view>\r\n//js\r\ndata() {\r\n    return {\r\n        arr:[\r\n            '小明',\r\n            '小红',\r\n            '李雷'\r\n        ]\r\n    }\r\n}\r\n输出===>\r\n<view>\r\n    <text>1.小明</text>\r\n    <text>2.小红</text>\r\n    <text>3.李雷</text>\r\n</view>\r\n复制代码wx:for即循环生成标签。4 事件小程序中不使用click事件，而用tab（触摸）事件代替，事件的前缀有两种分别是bind和catch，bind:tab表示冒泡事件，即事件触发后继续冒泡触发后续事件，catch:tab表示非冒泡事件，即事件触发后不再冒泡，类似执行了event.stopPropagation()方法。//实现一个点击加一的计数器\r\n//wxml\r\n<view>\r\n    <text bind:tab=\"addNumber\">{{count}}</text>\r\n</view>\r\n//js\r\nComponent({\r\n    //调用组件传来的变量\r\n    properties:{\r\n    },\r\n    //内部变量\r\n    data() {\r\n        return {\r\n            count:0\r\n        }\r\n    },\r\n    //内部方法\r\n    methods:{\r\n        //点击加一\r\n        addNumber() {\r\n            this.setData({\r\n               count:count+1 \r\n            });\r\n        }\r\n    }\r\n});\r\n复制代码改变data中的属性值必须使用this.setData()方法，传入一个对象，对象中存放需要改变的属性键值对。bind:tab可以简写为bindtb，个人喜欢bind:tab，看起来更清晰5 组件对于一个js文件，函数就是一个最小的、可复用的代码片段。而组件就是对于一个项目最小的、可复用的代码片段，他包括html、css、js代码，如我们常见的页面导航栏就可以做成一个组件，通过组件名字来使用，而不用将导航栏的代码复制粘贴到每个页面中。5.1组件的使用小程序的组件通过Component方法声明//.js文件\r\nComponent({\r\n    properties:{\r\n        //接收外接传来的变量\r\n    },\r\n    data() {\r\n        return {\r\n            //组件内部的变量\r\n        }\r\n    },\r\n    methods:{\r\n        //组件内部的方法\r\n    }\r\n});\r\n复制代码声明完毕之后，在需要使用到该组件的页面中进行调用//使用组件的页面的.json文件\r\n{\r\n    \"usingComponents\":{\r\n        //由键值对组成，键表示组件的名字，值是组件的路径，也是不需要文件后缀\r\n        \"component-name\":\"/components/component/index\"\r\n    }\r\n}\r\n//使用组件的页面的.wxml文件\r\n<view>\r\n    <component-name />  <!--不需要传入properties-->\r\n    <component-name userName=\"小明\"/>  <!--传入properties-->\r\n</view>\r\n复制代码5.2父子组件的传值首先我们看一下使用组件内部变量的例子，我们定义了userName变量并把它渲染到页面当中。//component .wxml文件\r\n<view>\r\n    <text>Hello {{userName}},how are you?</text>\r\n</view>\r\n//component .js文件\r\nComponent({\r\n    properties:{\r\n        //接口外接传来的变量\r\n    },\r\n    data() {\r\n        return {\r\n            userName:\"李雷\"\r\n        }\r\n    }\r\n});\r\n复制代码5.2.1父组件向子组件传值接着我们接受一个外部的变量并把它渲染到页面上，这样就实现了父组件向子组件传值。//component .wxml文件\r\n<view>\r\n    <text>Hello {{userName}},how are you?</text>\r\n</view>\r\n//component .js文件\r\nComponent({\r\n    properties:{\r\n        userName:{\r\n            type:String,    //调用该组件时传入的值的类型，可以是Number、String、Boolean、Object、Aray、Null(任意类型)\r\n            value:\"李雷\"    //默认值，调用该组件时未传入userName时，则userName的值为预设值李雷\r\n        }\r\n    },\r\n    data() {\r\n        return {\r\n            //组件内部变量\r\n        }\r\n    }\r\n});\r\n复制代码5.2.2子组件向父组件传值子组件向父组件传值的思路一般都是父组件监听一个自定义的事件，子组件触发这个事件同时将值传入，父组件监听这个事件的时候就可以拿到子组件传过来的值。//component .wxml文件\r\n<view>\r\n    <text bind:tap=\"clickMe\">Hello world</text>\r\n</view>\r\n//component .js文件\r\nComponent({\r\n    properties:{\r\n        //接口外接传来的变量\r\n    },\r\n    data() {\r\n        return {\r\n            //组件内部变量\r\n        }\r\n    }，\r\n    methods:{\r\n        //用户点击Hello world的时候向父组件传值\r\n        clickMe() {\r\n            //第一个参数为自定义事件名，父组件需要监听这个事件，第二个参数为需要传的值\r\n            this.triggerEvent('clickMe',{msg:'Hello world'});\r\n        }\r\n    }\r\n});\r\n//parent.wxml\r\n<!--监听clickMe事件-->\r\n<component bind:clickMe=\"clickMe\"></component>\r\n//parent.js\r\nclickMe(event) {\r\n    console.log(event.detail.msg);//输出子组件传来的参数Hello world，子组件传来的参数都在event.deail中\r\n}\r\n复制代码5.3注意事项前面我们说到了可以在app.wxss中定义全局样式，每个page页面都可以继承全局样式。但组件不同，组件只能继承有关字体以及color的样式，其他全局样式不能影响到组件的样式。6 声明周期小程序的声明周期分为整个应用的声明周期以及单个页面的声明周期，对于初学者来说这部分内容可以先跳过，它就像一幅眼镜，你自然会知道什么时候需要。6.1 应用生命周期回调函数在app.js中调用的App函数中，可以设置应用声明周期的回调函数App({\r\n  onLaunch (options) {\r\n    //初始化完成后执行\r\n  },\r\n  onShow (options) {\r\n    //进入小程序后执行\r\n  },\r\n  onHide () {\r\n    //离开小程序后执行，注意不是销毁，如切换其他App时，微信处于后台中，这时调用onHide\r\n  },\r\n  onError (msg) {\r\n    //小程序出错时执行\r\n  }\r\n});\r\n复制代码6.2 页面的生命周期回调函数Page({\r\n  onLoad: function(options) {\r\n    //页面初始化后执行\r\n  },\r\n  onReady: function() {\r\n    //初次渲染结束执行\r\n  },\r\n  onShow: function() {\r\n    //进入页面执行\r\n  },\r\n  onHide: function() {\r\n//页面隐藏/切入后台时触发，如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等  \r\n  },\r\n  onUnload: function() {\r\n    //页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。\r\n  },\r\n  onPullDownRefresh: function() {\r\n    // Do something when pull down.监听下拉刷新事件,必须开启enablePullDownRefresh\r\n  },\r\n  onReachBottom: function() {\r\n    // Do something when page reach bottom. 监听用户上拉触底事件\r\n  },\r\n  onShareAppMessage: function () {\r\n    // return custom share data when user share.点击转发按钮\r\n  },\r\n  onPageScroll: function() {\r\n    // Do something when page scroll 页面滚动事件\r\n  },\r\n  onResize: function() {\r\n    // Do something when page resize旋转屏幕触发\r\n  },\r\n  onTabItemTap(item) {\r\n    console.log(item.index)\r\n    console.log(item.pagePath)\r\n    console.log(item.text)\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    }, function() {\r\n      // this is setData callback\r\n    })\r\n  },\r\n  customData: {\r\n    hi: 'MINA'\r\n  }\r\n})\r\n\r\n复制代码6.3 组件生命周期回调函数Component({\r\n  lifetimes: {\r\n\tcreated:function() {\r\n\t\t//组件实例化的时候执行，此时不能调用setData()\r\n\t}\r\n    attached: function() {\r\n      // 在组件实例进入页面节点树时执行\r\n    },\r\n    detached: function() {\r\n      // 在组件实例被从页面节点树移除时执行\r\n    },\r\n  },\r\n});\r\n复制代码7零碎知识点7.1<image><image>标签中，不管图片多大，默认的图片大小宽度为300px,高度为225px，所以一定要给图片设置宽高。7.2页面最外层元素html页面中最外层的元素为<html>，小程序中的最外层元素为<page>，且<page>不需要自己添加啊，小程序自动添加的。7.3开启识别转义字符<text></text>标签中默认不能识别&nbsp;&lt;&gt;等转移字符,设置decode属性即可识别这些转移字符。<text>< ><text>\r\n==>输出，不可识别转移字符\r\n< >\r\n<text decode=\"{{true}}\">< ><text>\r\n==>输出，可以识别转移字符\r\n< >\r\n复制代码7.4 隐藏元素VueJS中使用v-if控制元素是否渲染，使用v-show控制元素是否显示。微信小程序中也有对应的操作，使用wx:if控制元素是否渲染，使用属性hidden控制元素是都显示。<!--渲染且显示(display:inline)-->\r\n<text>Hello World<text>\r\n<!--渲染但不显示(display:none)-->\r\n<text hidden=\"{{true}}\">Hello World<text>\r\n复制代码"}
{"title": "微信小程序实战教程——2实战之模仿知乎 ", "author": "Rolan", "pub_time": "2019-6-25 00:42", "content": "除了小程序项目中自带的文件夹，我引入了几个新的文件夹：.vscode文件夹存放vscode编辑器的配置文件。components文件夹存放组件。images文件夹存放公共图片。Mock文件夹存放使用MockJS模拟后端接口的类。models文件夹存放封装好的请求类。utils文件夹存放公共类。接下来我以首页为例进行分析，其他页面也都类似。建议能力较强的小伙伴先把 项目 下载下来，自己先尝试着根据效果图实现代码，做完之后再回来看与我的思路有哪些不同。2 起步2.1 布局与样式这个页面中每一条记录都是相同的，所以可以抽象为一个组件，在components文件夹下面创建一个组件，wxml与wxss比较简单，不做过多讲解。//wxml\r\n<view class=\"container-item\">\r\n    <view class=\"item-title\">\r\n        <text>{{items.title}}</text>\r\n        <image src=\"./images/more.png\"></image>\r\n    </view>\r\n    <view class=\"item-author\">\r\n        <image src=\"{{items.imgUrl}}\"></image>\r\n        <text>{{items.author}}</text>\r\n    </view>\r\n    <text class=\"text-body\">{{items.content}}</text>\r\n    <view class=\"item-action\">\r\n        <text>{{items.starNum}}</text>\r\n        <text>赞同</text>\r\n        <text>{{items.reviewNum}}</text>\r\n        <text>评论</text>\r\n    </view>\r\n</view>\r\n//部分scss\r\n$border-color:#dfdfdf;\r\n.container-item {\r\n  padding:10rpx;\r\n  display: flex;\r\n  flex-direction: column;\r\n  width: 100%;\r\n  background-color: #fff;\r\n  margin-top: 10rpx;\r\n  border-top: 1px solid $border-color;\r\n  border-bottom: 1px solid $border-color;\r\n}\r\n复制代码2.2 子组件与父组件的粒度大小子组件需要监听两个事件，分别为触摸该子组件时跳转到该问题的回答的详情页面以及触摸右上角的三个点跳转到该问题的详情页面。第二个事件触发的同时会冒泡并触发第一个事件，所以监听第二个事件的时候需要采用catch前缀监听并阻止事件冒泡。完整代码如下。<view class=\"container-item\" bind:tap=\"clickItems\">\r\n    <view class=\"item-title\">\r\n        <text>{{items.title}}</text>\r\n        <image src=\"./images/more.png\" catch:tap=\"clickMore\"></image>\r\n    </view>\r\n    <view class=\"item-author\">\r\n        <image src=\"{{items.imgUrl}}\"></image>\r\n        <text>{{items.author}}</text>\r\n    </view>\r\n    <text class=\"text-body\">{{items.content}}</text>\r\n    <view class=\"item-action\">\r\n        <text>{{items.starNum}}</text>\r\n        <text>赞同</text>\r\n        <text>{{items.reviewNum}}</text>\r\n        <text>评论</text>\r\n    </view>\r\n</view>\r\n复制代码抽象出子组件并不难，难的是如何设计子组件与父组件的粒度大小，在上面的例子中子组件监听了触摸事件，这时候是由子组件执行wx.navigateTe()还是由父组件执行，这才是我们最需要考虑的问题，我的想法是子组件只控制样式的变化，不执行业务逻辑，业务逻辑我一律交给父组件来做。下面代码参考 微信小程序实战教程——1基础知识 5.2.2//子组件中将index传给父组件，让父组件执行业务逻辑\r\nmethods: {\r\n    //打开回答详情\r\n    clickItems() {\r\n      let index=this.properties.index;\r\n      this.triggerEvent('clickItems',{index});\r\n    },\r\n    //打开问题详情\r\n    clickMore() {\r\n      let index=this.properties.index;\r\n      this.triggerEvent('clickMore',{index});\r\n    }\r\n}\r\n//父组件中监听子组件准备触发的事件并执行业务逻辑\r\n//wxml\r\n<view class=\"container\">\r\n    <block wx:for=\"{{items}}\" wx:for-item=\"v\" wx:for-index=\"i\">\r\n        <index-items items=\"{{v}}\" index=\"{{i}}\" bind:clickItems=\"clickItems\" bind:clickMore=\"clickMore\"></index-items>\r\n    </block>\r\n</view>\r\n//js\r\n//点击回答打开详情\r\nclickItems(event) {\r\n    //取出子组件传来的index，表示被点击的子组件的下标\r\n    let index=event.detail.index;\r\n    let id=this.data.items[index].id;\r\n    wx.navigateTo({\r\n      url: '/pages/detail/detail?id='+id\r\n    });\r\n},\r\n//点击打开问题详情\r\nclickMore(event) {\r\n    let index=event.detail.index;\r\n    let id=this.data.items[index].id;\r\n    wx.navigateTo({\r\n      url:\"/pages/problem/problem?id=\"+id\r\n    });\r\n}\r\n复制代码2.3利用Mock制作虚拟数据分析首页可以得知，每条记录需要一个id、标题、作者头像、作者名、正文内容、点赞的数量以及回复的数量。在Mock文件夹下创建一个indexMock.js文件专门为首页提供虚拟数据。//indexMock.js\r\nlet Mock = require('./mock-min.js');//引入Mock\r\nconst Random = Mock.Random;\r\nclass IndexMock {\r\n    constructor() {}\r\n    //返回首页记录模拟数据\r\n    getIndexList() {\r\n        return Mock.mock({\r\n            'status': '0',\r\n            'msg': '',\r\n            'data|10': [{\r\n                'id': '@guid()',   //id\r\n                'img': Random.img('16x16', '#4A7BF7','#000','@word(1,2)'),   //头像\r\n                'title': '@ctitle(1,8)',                    //标题\r\n                'author':'@word(1,8)',                     //作者\r\n                'content':'@cparagraph(1)',                 //正文\r\n                'star_num': '@integer(0,10000)',            //点赞数量\r\n                'review_num':'@integer(0,1000)'            //回复数量\r\n            }]\r\n        });\r\n    }\r\n}\r\nexport { IndexMock };\r\n复制代码2.4 封装AJAX请求微信小程序提供了wx.request()接口发送网络请求，这是十分常用的API，封装后我们可以省去很多的代码量。//不封装直接使用我们发送一个AJAX请求需要大量代码\r\nwx.request({\r\n    url:\"\",\r\n    data:\"数据\",\r\n    method:\"请求方式\"， //有GET、POST、PUT等值\r\n    dataType:\"返回数据类型\",//默认为json字符串\r\n    header:{\r\n        //请求头    \r\n    },\r\n    success() {\r\n        //接口调用成功的回调函数\r\n    },\r\n    fail() {\r\n        //接口调用失败的回调函数\r\n    },\r\n    complete() {\r\n        //接口调用成功/失败都会执行的回调函数\r\n    }\r\n});\r\n复制代码在utils文件夹中创建一个HTTP.js文件，在这里对wx.request进行一次封装class HTTP {\r\n    constructor() {}\r\n    request(params) {\r\n        //默认值处理,url不允许为空\r\n        if(!params.url) {\r\n            console.log('url没有传入');\r\n            return;\r\n        }\r\n        //method默认为GET\r\n        if(!params.method) {\r\n            params.method='GET';\r\n        }\r\n        wx.request({\r\n            url:params.url,\r\n            method:params.method,\r\n            data:params.data,\r\n            header:{\r\n                'content-type':'application/json'\r\n            },\r\n            success:res=> {\r\n                let code=res.statusCode.toString().substr(0,1);\r\n                //http请求状态码为2开头的时候判断为请求成功\r\n                if(code==='2') {\r\n                    params.success && params.success(res.data);\r\n                }\r\n                //状态码不为2开头如5开头的则判断为请求失败\r\n                else {\r\n                    params.error && params.error(res.data);\r\n                }\r\n            },\r\n            fail:()=> {\r\n                console.log('ajax error');\r\n            }\r\n        });\r\n    }\r\n};\r\nexport {HTTP};\r\n复制代码现在我们发送一个AJAX只需要传入url、data、method为GET时可以省略、success方法以及error方法。仍然需要传入很多参数，这时候可以对每一个具体的AJAX请求做一个封装。在models文件夹中创建首页发送AJAX的文件indexModels.js，在这其中对首页使用到的AJAX请求进行第二次封装。import {HTTP} from '../utils/HTTP.js';\r\nimport {IndexMock} from '../Mock/indexMock.js' ;\r\nlet indexMock=new IndexMock();\r\nclass IndexModels extends HTTP{\r\n    constructor (){\r\n        super();\r\n    }\r\n    //请求首页真实数据\r\n    getIndexList(data,success) {\r\n        let params={\r\n            url:'http://xxx.com/Index/List',\r\n            //请求数据使用GET请求，method不需要设置\r\n            data:data,\r\n            success:success\r\n        };\r\n        this.request(params);\r\n    }\r\n    //请求首页模拟数据\r\n    getIndexListByMock(data,success) {\r\n        let list=indexMock.getIndexList();\r\n        success && success(list);\r\n    }\r\n}\r\nexport {IndexModels};\r\n复制代码在页面中引入indexModels.js文件后new一个类即可调用getIndexListByMock方法，此时只需要传入data与success方法。2.5 简化Mock的副作用使用Mock之后总是要切换回真实数据的，这时候在页面中的每一个AJAX请求都需要更改，太过繁琐，这时可以考虑引入一个全局常量，只修改这个常量即可实现Mock数据切换为真实数据。在最外层创建一个config.js文件，定义一个常量用于控制数据来源是Mock数据还是真实数据。const DEBUGGER=true;\r\nexport {DEBUGGER};\r\n复制代码在indexModels.js文件中引入config.js，使用常量DEBUGGER来判断使用哪个来源的数据，indexModels.js改变为：//DEBUGGER为true表示请求虚拟数据，为false表示请求真实数据\r\nimport {DEBUGGER} from '../config.js';\r\nimport {HTTP} from '../utils/HTTP.js';\r\nimport {IndexMock} from '../Mock/indexMock.js' ;\r\nlet indexMock=new IndexMock();\r\nclass IndexModels extends HTTP{\r\n    constructor (){\r\n        super();\r\n    }\r\n    //请求首页数据\r\n    getIndexList(data,success) {\r\n        if(!DEBUGGER) {//请求真实数据\r\n            let params={\r\n                url:'http://xxx.com/Index/List',\r\n                data:data,\r\n                success:success\r\n            };\r\n            this.request(params);\r\n        }\r\n        else {//请求虚拟数据\r\n            let list=indexMock.getIndexList();\r\n            success && success(list);\r\n        }\r\n    }\r\n}\r\nexport {IndexModels};\r\n复制代码之后需要改变数据来源为真实数据时，只需要在config.js中将DEBUGGER改变为false即可。至此，这个页面就已经写完了。"}
{"title": "微信小程序数据统计和错误统计的实现 ", "author": "Rolan", "pub_time": "2019-6-26 00:08", "content": "某些情况下我们需要对小程序某些用户的行为进行数据进行统计，比如统计某个页面的UV,PV等，统计某个功能的使用情况等。好让产品对于产品的整个功能有所了解。在网页里，我们很多人都用过谷歌统计，小程序里也有一些第三方数据统计的库, 比如腾讯的MTA等等。但是，第三方的数据统计库要么功能太简单，满足不了需求，要么就是要收费。（留下了贫穷的泪水。）等等，又不是你出钱，怕啥？ 贵一点就贵一点呀。嗯，说的没错。但是，公司团队内部想实现一套完整的自己的数据统计系统以满足自己的需求。所以，还是没有用第三方的。所以，具体要统计些啥？产品经理想知道用户都是怎么进入我们的小程序的？用户在我们小程序里那个页面停留的时间最长？平均用户停留时间是多少？想知道我们最近开发的那个功能用的人多不多？想统计小程序里的一些按钮有多少用户点击了开发自己总是很难复现用户端出现的bug,要是可以知道用户端发生错误时，知道用户当时的用的手机型号，微信版本，网络环境，页面参数，和错误信息就好了想知道我们小程序启动时间是多少？接口在用户端的平均响应时间是多少ms? 哪些接口报错了针对产品经理的需求，我们可以知道，Ta想要的是就是数据统计要实现的功能。对于开发来说，我们关注的更多就是错误统小程序性能这块的东西。好，到这里，我们需求是明白了。就是要实现一套既能统计普通的埋点数据，也要能统计到小程序里一些特殊触发的事件，比如appLaunch, appHide 等，还要可以统计错误。好，那先来看看如何实现产品的需求吧用户进入小程序可以在 小程序 onLaunch 回调里拿到参数 的scene 值，这样就可以知道用户是怎么进入小程序的了。小case, 难不到我。嗯，第一个需求实现了，那如何统计第二个呢？如何统计某个页面的停留时间呢？这也难不倒我，用户在进入页面时会触发onShow 事件， 同样，在离开页面（或者切后台时）会触发onHide事件，我只需要在onShow里记录一下时间，同时在onHide 里也记录一下时间，把两个时间一减就可以了。   Page({\r\n       data: {\r\n        beginTime: 0,\r\n        endTime: 0\r\n       },\r\n       onShow: function() {\r\n         // Do something when page show.\r\n         this.setData({\r\n           beginTime:  new Date().getTime()\r\n         })\r\n       },\r\n       onHide: function() {\r\n         // Do something when page hide.\r\n         let stayTime = new Date().getTime() - this.beginTime;\r\n         // 这个就是用户在这个页面的停留时间了\r\n       },\r\n   })等等，这样确实实现了需求，万一产品要统计所有也面的停留时长？ 那我们岂不要在每一个页面都这样写一遍？有没有更好的方法呢？好，接下来就是数据统计实现的要点了，即拦截微信原生事件，这样可以在某个特殊事件触发时，做一些我们统计的事情。同时，还要拦截微信发生网络请求的方法，这样可以拿到网络请求相关的数据，最后，为了能统计到错误，还需要拦截微信发生错误的方法。1.特殊事件的监听App(Object object)注册小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。拦截全局的事件:下面是小程序官方文档对于App 注册方法的文档：App({\r\n  onLaunch (options) {\r\n    // Do something initial when launch.\r\n  },\r\n  onShow (options) {\r\n    // Do something when show.\r\n  },\r\n  onHide () {\r\n    // Do something when hide.\r\n  },\r\n  onError (msg) {\r\n    console.log(msg)\r\n  },\r\n  globalData: 'I am global data'\r\n}) 假如我们要在小程序onLaunch 时打印一句hello Word，我们有哪些方法实现？方法1：直接写在onLaunch方法里  onLaunch (options) {\r\n     console.log('hello World')\r\n  }方法2：使用 monkey patch方法 猴子补丁(monkey patch)猴子补丁主要有以下几个用处：在运行时替换方法、属性等在不修改第三方代码的情况下增加原来不支持的功能在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加举个栗子，假如我们在console.log 方法里都先打印出当前的时间戳，我们可以这样：var oldLog = console.log\r\nconsole.log = function() {\r\n  oldLog.call(this, new Date().getTime())\r\n  oldLog.apply(this, arguments)\r\n}同理，我们针对onLaunch 进行猴子补丁var oldAp = App\r\nApp = function(options) {\r\n  var oldOnLaunch = options.onLaunch\r\n  options['onLaunch'] = function(t) {\r\n    // 做一些我们自己想做的事情\r\n    console.log('hello word....')\r\n    // 调用原来的onLaunch 方法\r\n    oldOnLaunch.call(this, t)\r\n  }\r\n  \r\n  // 调用原来的App 方法\r\n  oldApp(options)\r\n  \r\n  // 想像一下，小程序内部调用onLaunch 方法应该是这样子的：\r\n  options.onLaunch(params)\r\n}\r\n\r\n// 问题，有的时候，我们可能没有注册某一个事件，比如页面的onShow, 所有，我们在替换的时候还需要判断一下参数是否传了对应的方法\r\nPage({\r\n  onLoad (options) {},\r\n  onHide (options) {}\r\n})\r\n\r\n// 针对这种情况，我们需要这样写\r\nvar oldPage = Page\r\nPage = function(options) {\r\n  if (options['onShow']) {\r\n    // 如过有注册onShow 这个回调\r\n    var oldOnShow = options.onShow\r\n    // onShow 方法调用时都是 传了一个对象\r\n    options['onShow'] = function(t) {\r\n      // doSomething()\r\n      oldOnShow.call(this, t)\r\n    }\r\n  }\r\n  // 调用原来的Page 方法。\r\n  oldPage.apply(null, [].slice.call(arguments))\r\n  // 注意： 下面这两种写都会报错: VM23356:1 Options is not object: {\"0\":{}} in pages/Badge.js 问题具体原因暂时未找到。\r\n  // oldPage.call(null, arguments)\r\n  // oldPage(arguments)\r\n}通过上面的方法，我们可以拦截了 App 方法注册的一些全局方法，比如 onLaunch , onShow, onHide, 和Page 注册的事件如 onShow, onHide， onLoad, onPullDownRefresh, 等页面注册事件。2.网络请求的监听思路： 拦截微信的请求事件。 let Request = {\r\n      request: function (e) {\r\n        let success = e[0].success,\r\n          fail = e[0].fail,\r\n          beginTime = smaUtils.getTime(),\r\n          endTime = 0\r\n        // 拦截请求成功方法\r\n        e[0].success = function () {\r\n          endTime = smaUtils.getTime()\r\n          const performance = {\r\n            type: constMap.performance,\r\n            event: eventMap.wxRequest,\r\n            url: e[0].url,\r\n            status: arguments[0].statusCode,\r\n            begin: beginTime,\r\n            end: endTime,\r\n            total: endTime - beginTime\r\n          }\r\n          smaUtils.logInfo('success performance:', performance)\r\n          // 这里做上报的事情\r\n          // SMA.performanceReport(performance)\r\n          success && success.apply(this, [].slice.call(arguments))\r\n        }\r\n        // 拦截请求失败方法\r\n        e[0].fail = function () {\r\n          endTime = smaUtils.getTime()\r\n          const performance = {\r\n            type: constMap.performance,\r\n            event: eventMap.wxRequest,\r\n            url: e[0].url,\r\n            status: arguments[0].statusCode,\r\n            begin: beginTime,\r\n            end: endTime,\r\n            total: endTime - beginTime\r\n          }\r\n          smaUtils.logInfo('fail performance:', performance)\r\n          // 这里做上报的事情\r\n          // SMA.performanceReport(performance)\r\n          fail && fail.apply(this, [].slice.call(arguments))\r\n        }\r\n      },\r\n   }\r\n \r\n \r\n    // 替换微信相关属性\r\n    let oldWx = wx,\r\n      newWx = {}\r\n    for (var p in wx) {\r\n      if (Request[p]) {\r\n        let p2 = p.toString()\r\n        newWx[p2] = function () {\r\n          Request[p2](arguments)\r\n          // 调用原来的wx.request 方法\r\n          oldWx[p2].apply(oldWx, [].slice.call(arguments))\r\n        }\r\n      } else {\r\n        newWx[p] = oldWx[p]\r\n      }\r\n    }\r\n    // eslint-disable-next-line\r\n    wx = newWx疑惑：为什么要使用替换整个wx对象的方法呢？ 不直接用我们的request 方法 替换 wx.request 方法var oldRequest = wx.request\r\nwx.request = function(e) {\r\n  // doSomething();\r\n  console.log('请求拦截操作...')\r\n  oldRequest.call(this, e); // 调用老的request方法\r\n}\r\n// 结果报错了：\r\n//  TypeError: Cannot set property request of [object Object] which has only a getter\r\n\r\n3.错误的监听3.1 拦截App里注册的 onError事件var oldAp = App\r\nApp = function(options) {\r\n  var oldOnError = options.onErrr\r\n  options['onErrr'] = function(t) {\r\n    // 做一些我们自己想做的事情\r\n    console.log('统计错误....', t)\r\n    // 调用原来的onLaunch 方法\r\n    oldOnError.call(this, t)\r\n  }\r\n  \r\n  // 调用原来的App 方法\r\n  oldApp(options)\r\n}3.2 拦截 conole.error console.error = function() {\r\n      var e = [].slice.call(arguments)\r\n      if (!e.length) { return true }\r\n      const currRoute = smaUtils.getPagePath()\r\n      // 统计错误事件\r\n      // SMA.errorReport({event: eventMap.onError, route: currRoute, errrMsg: arguments[0]})\r\n      smaUtils.logInfo('捕捉到error 事件,', e)\r\n      oldError.apply(console, e)\r\n  }至此，我们已经有能力在小程序发起请求时，发生错误时，生命周期或者特殊函数回调时，我们都能在里面做一些我们想要的数据统计功能了。说了这么多大家估计也看累了。鉴于篇幅,具体的代码就不在这里贴了。最终实现的数据统计模块大致实现了以下功能：普通埋点信息上报功能错误信息上报功能性能数据上报功能具体的上报时机支持配置支持指定网络环境上报支持统计数据缓存到微信本地功能整个统计代码的配置文件如下：const wxaConfig = {\r\n  project: 'myMiniProgram', // 项目名称\r\n  trackUrl: 'https://youhost.com/batch', // 后台数据统计接口\r\n  errorUrl: 'https://youhost.com/batch',  // 后台错误上报接口\r\n  performanceUrl: 'https://youhost.com/batch', // 后台性能上报接口\r\n  version: '0.1',\r\n  prefix: '_wxa_',\r\n  priority: ['track', 'performance', 'error'], // 发送请求的优先级，发送时，会依次发送\r\n  useStorage: true, // 是否开启storage缓存\r\n  debug: false, // 是否开启调试（显示log）\r\n  autoTrack: true, // 自动上报 onShow, onHide, 分享等 内置事件\r\n  errorReport: false, // 是否开启错误上报\r\n  performanceReport: false, // 接口性能上报\r\n  maxReportNum: 20, // 当次上报最大条数\r\n  intervalTime: 15,  // 定时上报的时间间隔，单位 s, 仅当开启了定时上报有效。\r\n  networkList: ['wifi', '4g', '3g'], // 允许上报的网络环境\r\n  opportunity: 'pageHide' // pageHide、appHide、realTime(实时上报)、timing(定时上报) 上报的时机，四选一\r\n}\r\nexport default wxaConfig\r\n具体上报时，上报的数据结构大致长这样：项目已传到GitHub -> GitHub传送门-wxa如果这篇文章帮到你了，觉得不错的话来点个Star吧你们是如何实现小程序数据统计的呢？ 欢迎在评论里留言交流~~"}
{"title": "小程序云开发遇到的一些问题集合 ", "author": "Rolan", "pub_time": "2019-6-26 00:19", "content": "最近在开始尝试做小程序的云开发。学习云开发主要有以下几个原因：云开发使用的语言就是js，服务端就是nodejs自己开发小程序的服务端，要自己买服务器，买域名，域名备案，还要配置https，不熟悉怎么配置的人估计会踩很多坑，会花很多的时间。下面记录一下我在云开发过程中遇到的一些问题。1.小程序端可以直接调用操作数据库的api小程序有云函数和数据库相关的操作，我自己也有做后端，正常的逻辑应该是在后端操作数据库，所以我一开始理解是，小程序端调用云函数，云函数操作数据库，但是仔细看了官方的文档之后，发现可以直接在小程序端调用操作数据库的api。2.发送模板消息不能定时发送我想做一个每日定时推送消息的一个功能，刚好云函数也直接定时触发，所以每次用户点击的时候就把formId存下来，在云函数里读取formId，再发送模板消息，但是一直不生效，云函数是能定时触发了，但是每次结果都失败了，找了很久，最后才知道，发送模板消息不能在云函数里调用，只能在小程序的发起。希望后面微信能支持云函数定时发送模板消息吧3.数据库有控制台（需要下载开发版2019.06.20及之后的版本）开发版nightly版本下载链接4.集合的主键：_id必须是字符串因为一些原因，我需要在某个集合的每条记录里加一个自增的值，所以我把_id设置成了number类型的，然后试了导入数据和云函数新增数据两种方法，试了好久，一直新增不成功，我以为是什么其他的原因，报错的原因也不是很准确，找了很久，通过数据库操作控制台，新增了一个add模板，把需要的新增的数据新增，执行语句之后，这回的报错才是准确的，这回才了解到_id必须是字符串。"}
{"title": "实现小程序和H5页面之间互相跳转 ", "author": "Rolan", "pub_time": "2019-6-26 00:32", "content": "一、背景需求背景是这样的，在小程序里面，点击查看用户签订的协议，跳转到协议详情页，刚好协议详情页在另一个H5项目的已经有，所以就想直接跳转过去，避免再开发小程序版本的协议详情页二、小程序跳转H5页面小程序里面运行H5页面，需要嵌在<web-view></web-view>\tweb-view 里面，注意：一个项目只能有一个<web-view></wb-view>。Demo:在小程序里面打开百度网页在小程序项目里面src/pages/新建一个webview的文件夹，含有wxml/wxss/json/jswxml：\r\n<web-view src=\"{{ src }}\"></web-view>js：在onLoad里面获取到url这个参数，然后赋值给data，这样在wxml里面就能取到src的值。\r\nPage({\r\n    data: {\r\n        url: '',\r\n    },\r\n    onLoad: function (param) {\r\n        this.setData({\r\n            url: decodeURIComponent(param.url),\r\n        })\r\n    }\r\n});json/wxss是空文件就可以了。在小程序的页面跳转到H5页面的写法wx.navigateTo({\r\n    url: '../webview/index?url=https://www.baidu.com/'\r\n});这样就成功实现从小程序跳转到H5页面。三、H5页面返回小程序从H5页面返回小程序页面，需要使用微信SDK提供的跳转方法。window.wx.miniProgram.navigateTo({\r\n    url: `/page/account/index`,\r\n });使用微信的SDK方法，需要先发送签名验证wx.config。四、小程序和H5互跳遇到的坑【问题描述】wx.miniProgram.navigateTo中url无法跳转问题【问题解决】:app.json中配置的tabBar与wx.navigateTo中的url引用相同页面导致首先pages/account/index这个路径在app.json已经存在，也就是当前从H5页面window.wx.miniProgram.navigateTo(url)的url已经和app.json的一样。此时是不能通过这个方式跳转，而是要改成window.wx.miniProgram.reLaunch(url)总结：如果url在app.json已定义，则使用reLaunch跳转，如果没有，则使用miniProgram.navigateTo(url)【问题描述】在小程序里面跳转到H5协议详情页的时候，进入了系统错误页（项目里定义好的错误页），当我现在微信公众号打开该协议详情页，此时再从小程序进入，不会出现。【问题解决】这里我判断是跟登录态有关系，因为我先访问一下公众号，此时浏览器里有了登录态，所以在小程序里面访问协议详情页不会进入系统错误页。定位问题过程：H5页面是vue页面，先从路由文件/routes/index.js开始debugger，果然就在登录的js里面找到问题，查看登录的js里面有一个先会登出的过程，然后再login（这里是因为不同券商的原因，需要logout清除上一个券商的数据，哈哈，流水账，不然越记越长，不展开咯）在登录logout的过程，此时该cgi抛出异常，刚好被全局捕获，所以进入了系统错误页。后面的解决方法，是在登出的时候try catch捕获异常，不要把异常被全局捕获。try {await request('logout.cgi')} catch(e) {console.log('error')}记下问题2，是想跟自己说，bugger经常有，遇到了就一个个地看debugger，看错误来源哪里。谨记在心。"}
{"title": "微信小程序入口场景的问题整理与相关解决方案 ", "author": "Rolan", "pub_time": "2019-6-26 00:42", "content": "前言最近一段时间都在做小程序。虽然是第二次开发小程序，但是上次做小程序已经是一年前的事了，所以最终还是被坑得死去活来。这次是从零开始开发一个小程序，其实除了一些莫名其妙的兼容性问题，大多数坑点都是在微信小程序的各个入口场景处。所以这里整理一下微信小程序的各个入口场景，以及从这些入口场景进入小程序会面临的问题以及解决方案。这里只列出常用的几种场景：[简单场景]启动小程序并进入[简单场景]退出重进（启动小程序后，退出小程序，再次进入小程序）[简单场景]退出重进首页（启动小程序后，退出小程序，通过扫二维码再次进入小程序）[复杂场景]启动并进入指定页面（从小程序的分享卡片或者微信发送的通知消息进入小程序）[复杂场景]退出重进指定页面（启动小程序后，退出小程序，从小程序的分享卡片或者微信发送的通知消息进入小程序）启动小程序并进入微信小程序的入口场景光微信提供的场景值就有几十种，但是绝大多数都可以划分为启动小程序并进入。这是最常用的一种进入小程序的方式，比如通过搜索进入或者点击最近使用小程序的方式进入，都算是这种类型。这一场景下，首先我们需要明白发生了什么：下载小程序 => 启动小程序 onLaunch事件触发 => 加载首页 onLoad事件触发 => 首页 onShow事件然后在这个场景下，需要注意以下几个问题：这个场景下一般会涉及到登录。所谓登录，不一定是要在这个阶段做，但是登录信息的判断这个阶段是一定要做的。通常前端肯定是要将登录的这些信息存储在小程序的storage里，然后在onLaunch事件中判断是否登录，没登录就跳转到登录页面，登录了就跳转到首页。这里的登录判断一定要放在onLaunch，而不要放在首页的onLoad里面，因为小程序启动一定会进入onLaunch，而不一定会进入首页的onLoad。而登录页面在设计的时候最好要加上一个url参数，传入登录成功后跳转到的页面地址，而不是登录之后始终跳转到首页，后面会讲为什么需要这么做。onLaunch阶段是否有发出请求，并在请求完成后进行了页面跳转，或者请求完成设置storage，并在onLoad页面中使用？这种情况的出现，会导致在请求时间过长时，首页的onLoad已经执行了，此时就会出现BUG。对于这个问题，有的人会用定时器去判断是否完成这个操作，但是我的建议是尽量避免在onLaunch中进行这些操作。如果一定要有，那么最好的方式就是做一个加载页面去承载这些功能。首页数据的初始化，一般是放在onLoad中执行。当然总是有些特殊的需求是要放在onShow里面的。关于onLoad和onShow，最常见的处理区别就在跳转页面时。当载入首页时，先触发onLoad，再触发onShow。此时通过wx.navigateTo 的方式跳转到页面A，这个时候首页并没有被关闭，那么从页面A再返回首页时，onLoad就不会触发，但onShow会触发。通常在加载数据时，一般会用到onLoad。但是如果说页面A更新了数据，然后返回首页时，首页的相关数据也需要更新。那么初始化数据就不能放在onLoad里，而需要放在onShow里。（当然还有一种方式是通过getCurrentPages的方式在页面A中调用首页的方法。但是这里极不推荐这种方式，属于某个页面的事情一定要给这个页面。最好不要将页面间的职责通过这种方式打乱，容易引起代码混乱，不易维护。）退出重进（启动小程序后，退出小程序，再次进入小程序）这种场景实际上是对第一种场景的扩展。而所谓的退出小程序不管你是点右上角的退出按钮还是Home键直接切出都算是这类退出。但是退出后再立即进入小程序的时候，依然会进入你退出小程序时所在的页面，而不会触发onLaunch，也不会触发这个页面的onLoad，不过onShow是肯定会触发的。这一场景下，首先我们需要明白发生了什么：再次进入小程序 => 进入退出小程序时所在页面 触发onShow在这个场景下，只需要注意onShow中是否有不可重复执行的操作。例如onShow中会获取用户喜欢吃的食物，加载到页面的列表中，在这种场景下，如果不清空之前的列表或者加个判断的话，就会出现重复数据。退出重进首页（启动小程序后，退出小程序，通过扫二维码再次进入小程序）这种场景实际上是对第二种场景的扩展。我们通常给二维码配置的是一个无参数的小程序首页地址，当我们退出小程序，通过扫二维码再次进入小程序时会进入首页。这一场景下，首先我们需要明白发生了什么：再次进入小程序 => 进入退出小程序时所在页面A 不触发onShow => 触发页面A onHide => 触发页面A onUnload=> 进入首页 onLoad => 首页onShow在这个场景下，除了需要注意第二种场景存在的问题，还需要注意页面A的onHide事件中是否会触发奇怪的操作，例如页面跳转。启动并进入指定页面（从小程序的分享卡片或者微信发送的通知消息进入小程序）这块场景常见于邀请他人进入小程序，需要注意的是他们往往被赋予了更多的业务功能，也就往往增大了小程序的实现难度。这一场景下，首先我们需要明白发生了什么：下载小程序 => 启动小程序 onLaunch事件触发 => 加载指定页面 onLoad事件触发 =>指定页面  onShow事件这里就可以看出，并不是进入小程序就一定会进入首页的onLoad。所以这就是为什么之前强调不要将登录判断放在首页的onLoad中，而一定要放在onLaunch里。但是这里又和扫二维码不同，扫二维码的链接一般都是指定的首页。而这里通常跳转到的是非首页的页面，而且可能还多了复杂的业务功能。我们在需求分析和设计阶段应该更多地考虑到这里可能会引发的复杂问题，而尽量将此处的业务逻辑简化，或者加大估时。接下来，我们将根据业务从简单到复杂，慢慢讲解这个场景下可能存在的问题。最简单的邀请函（进入小程序首页）和第一种场景差不多，这里略过进阶邀请函（进入小程序指定页面，带参数，需要根据参数初始化页面）这种情况下，需要考虑以下几个问题：首先在onLaunch阶段会判断是否登录，没登录那么就需要跳转到登录页面，登录页面登录之后，肯定要跳转到这个页面，而不是首页。所以之前说过登录页面设计的时候需要传入一个url参数，来明确登录成功后跳转到哪个页面。这种跳转到指定页面的情况通常都需要一个回到首页的按钮。就比如邀请某人查看一篇文章，点击邀请卡片后会进入小程序内的文章详情。一般在小程序内通常是通过点击文章列表跳转到文章详情，那么这个时候可以逐级返回到首页。但是在点击邀请函进入的情况是没有返回功能的，此时如果没有回到首页功能，那么用户可能就永远没法回到首页。（其实是可以的，但是小程序的的这个功能藏得比较深，不要指望所有用户都那么热爱摸索）这里一定要特别注意第一种场景的第三个应该注意的问题，对于第一种场景而言那个问题因为启动次数很多容易出现，但是在当前的场景下可能很容易被忽略掉。涉及身份的邀请函（进入小程序指定页面，带参数，需要根据参数切换身份，更可能涉及到登录）为了更好地说明这种情况，我们来列举一个场景。如果有一个打车软件，进入这个软件后有两种身份，一种是乘客，一种是司机。用户是司机，那么看到的是页面A或者选定了TabA，如果是乘客，那么看到的是页面B或者选定了TabB。而且还有一个需求，用户上次登陆时什么身份，这次登陆也是什么身份。考虑到换手机的场景，那么这个信息肯定是存储在服务端的，所以进入小程序的时候会去请求服务端进行判断。现在我用司机的身份发了个单，微信给了个通知消息，我没点开。然后切换到乘客的身份了，再去点击通知消息，那么我会以司机的身份去打开这个消息。这个场景其实在业务上来看是很合理的，但是对于我们的程序实现来看，复杂度一下子就上来了。首先我们确定一下这个请求身份信息的请求在哪个阶段发出？onLaunch？那么是不是需要在onLoad阶段去获取这个身份的信息然后给出不同的页面？这样一下子就会出现进阶邀请函的第三个问题，而且还不仅仅是这一个问题，之后我们会讲到。所以这个地方需要做一个专门的邀请加载页面去处理这个事情。分离出一个单独的加载页面之后，其实我们的工作会变的简单清晰起来。因为我们只需要去做我们这个页面所需要做的事情就行了。根据参数去获取我们现在的身份，然后以这种身份跳转到相应的页面。这里还涉及到一个问题，那就是正常启动而不是通过通知消息进入的时候，也需要去请求服务端获取身份信息。我给的建议是一定要另外单独建一个页面去承载这个功能，而不要将这两个加载页面糅合到一起。里面的页面展示我们可以用组件化的方式去做，但是页面的逻辑一点更要分开。因为这两种情况真的很容易混杂，也是为了利于后面的维护工作。正常启动时的加载页面也可以看情况糅合到首页的onLoad里面。但是如果有可能，还是希望放在单独的页面里。首页往往功能很多，代码量比较大，不要将本来可以分离出去的功能放进去。还是那句话，页面的职责分开。我这里讲的其实还是一个比较常见的功能，通常我们的业务也不一定像上面这样简单。所以如果涉及到这方面的操作，在需求分析和设计的时候就应该考虑清楚。如果等到功能开发的时候再去考虑这些事情，那么等待你的一定是延期或者加班。退出重进指定页面（启动小程序后，退出小程序，从小程序的分享卡片或者微信发送的通知消息进入小程序）这种场景同样是第四种场景的进阶，但是如果你在第四种场景中使用了我所说的加载页面，那么接下来的问题会简单很多。这一场景下，首先我们需要明白发生了什么：再次进入小程序 => 进入退出小程序时所在页面A 不触发onShow => 触发页面A onHide => 触发页面A onUnload => 进入邀请加载页面onLoad => 加载页面onShow对于第四种场景中的打车小程序而言，如果按照我们先前所说没有在onLaunch中获取身份信息，而是放在了加载页中，那么现在什么都不用改。如果获取身份信息的请求放在onLaunch中，现在又得在onLoad中加一道逻辑。当然这里还是得注意一个问题，对于这一类型的进入小程序的方式，比如从分享卡片进入和微信的通知消息进入。即使他们所进入的页面不同，但是他们都可以使用这个载入页面去做判断。与正常启动场景的载入页面是不同的，他们本来就是同一种入口场景。所以该共用的地方还是得共用，用不同的业务code判断即可。总结总的来说，以上的几种情况应该能涵盖绝大多数小程序的入口场景。整理的目的其实主要是为了做需求分析和设计时参考使用，以避免在考虑业务问题时漏过这些场景导致后期的工作计划受到影响。所谓加班和项目延期发布，大都是前期需求分析和设计考虑不周。我们不可能考虑到所有的场景，但是应该尽善尽美。谋定而后动，前事不忘后事之师，也算是PDCA了。"}
{"title": "常被忽略的小程序二三事 ", "author": "Rolan", "pub_time": "2019-6-27 00:15", "content": "小程序在冷启动的时候遇到版本更新，小程序会异步加载，帮我们下载最新版本的代码包，并同时使用微信本地版本的代码包启动，也就是说最新的代码包，将在小程序下次启动才去加载。如果偏要使用最新版本的代码包，我们可以使用api来处理wx.getUpdateManagerconst updateManager = wx.getUpdateManager()\r\n\r\nupdateManager.onCheckForUpdate(function (res) {\r\n  // 请求完新版本信息的回调\r\n  console.log(res.hasUpdate)\r\n})\r\n\r\nupdateManager.onUpdateReady(function () {\r\n  wx.showModal({\r\n    title: '更新提示',\r\n    content: '新版本已经准备好，是否重启应用？',\r\n    success(res) {\r\n      if (res.confirm) {\r\n        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\r\n        updateManager.applyUpdate()\r\n      }\r\n    }\r\n  })\r\n})\r\n\r\nupdateManager.onUpdateFailed(function () {\r\n  // 新版本下载失败\r\n})\r\n复制代码小程序加载机制：小程序的启动流程图里面：左侧的部分是在启动的时候，微信客户端里面的视图层和逻辑层一些交互逻辑以及数据缓存的存取操作，在小程序启动的时候，会向 cdn 请求最新代码包，第一次启动必须等到代码包下载完毕，注入到 webView 容器内执行之后，才能看到小程序页面，所以在网络不好的情况下，我们会感觉到页面打开比较慢，客户端会帮我们把代码包缓存到本地，当我们下一次启动的时候，我们会从 cdn请求是否有最新版本的代码包。小程序应用和页面的生命周期：小程序应用生命周期：onLaunch，onShow，onHide，onError首次进入小程序，从 cdn 或者小程序本地拿到代码包注入到运行环境， 微信客户端会给我们逻辑层 app.js 的 app 实例来派发 onLaunch 事件， 在逻辑层， app.js 的 app 构造器的参数里面的 onLaunch 方法就会被调用。 当用户使用 home 件或者点击右上角小程序关闭按钮，来关闭小程序时，小程序是没有被直接销毁的，这时 app 构造器的参数里面的 onHiede 方法就会被调用，当我们再次打开小程序时，微信唤起小程序， onShow 方法就会被调用， 当小程序脚本发现错误时，或 api 调用失败时，会调用 onError 。小程序页面的生命周期：onLoad，onShow，onReady，onHide，onUnload，页面未被销毁之前， onLoad 只会调用一次， 页面显示之后，会调用page实例里面的 onShow当页面初次渲染之后， onReady 就会被调用，页面未被销毁之前，只会调用一次 onReady 触发之后，逻辑层和视图层进行交互， 当我们在当前页面打开新的页面之后，当前页面会触发 onHide ， 如果关闭当前页，会触发 onUnload负责页面视图的 view 线程和处理数据的服务以及服务的服务线程， AppService ， 协同完成生命周期周期调用小程序事件模型1. 事件捕获阶段绑定的事件从最外层节点向下传递到目标节点元素，依次检查，所经过的节点是否绑定了同一事件类型的监听回调函数，如果有则执行对应的事件回调函数2. 事件处理阶段事件在到达目标节点之后，会触发目标节点所绑定的监听回调函数3. 事件冒泡阶段事件从目标节点，向上冒泡到最外层节点，依次检查经过的节点是否绑定了，同样事件类型的监听回调函数，如果有，会执行这个回调函数target 属性： 触发事件的当前组件 currentTarget 属性： 触发事件的根源组件eg: 如果有外层 view 还有个里层 view 嵌套，都通过 bind 绑定了点击事件， target 为外层 view 组件的事件对象, currentTarget 为底层 view 组件的事件对象type 触发事件的触发类型timestamp 触发事件的时间戳target 触发事件的根源组件，包括触发事件根源组件的id自定义属性的集合currenTarget 事件绑定额当前组件 ，包括当前组件的 id ，类型， data 自定义属性的集合touches 是一个数组，每一个元素都是一个 touc h对象 ，标识当前停留在屏幕上的触摸点和信息changedTouches 是一个数据，标识有变化的 触摸点，即当前触摸点从有到无或从无到有的变化detail 标识各个事件带有的数据，点击事件： ‘触摸点距离文档左上角的距离’ 媒体事件，触发事件的时候播放状态，以及时间戳小程序运行环境：在不同环境下的 javascript 脚本运行环境是不同的，微信小程序运行在三端 ：iOS（iPhone/iPad） 、 Android 和 用于调试的开发者工具。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS8 、 iOS9 、 iOS10 ；在 Android 上，旧版本，小程序逻辑层的 javascript 代码运行中 X5 JSCore 中，视图层是由 X5 基于 Mobile Chrome 57 内核来渲染的新版本，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 6 7 内核来渲染的；在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium 60 Webview 来渲染的。Tips:wx：key列表数据发生改变重新出发页面渲染的时候，列表中的项目可以保持自身状态 比如在 input 组件里，输入了内容之后 在页面渲染之后，不希望 input 内容发生改变，需要用此属性 这个属性，在页面重新渲染的时候，确保带有 key 的组件 会重新排序，而不是重新渲染，从而提高页面渲染性能的效率Block是一个包装元素，不是组件，渲染之后页面看不出来wx：if 和hidden 区别wx:if 在切换时有局部渲染的过程，从而保证条件块渲染时，可以销毁并重新渲染，有更高的切换消耗 hidden 始终渲染。可以控制视图上的显示和隐藏，有更高的初始化渲染消耗, 所以元素频繁切换的话，使用 hiddenwxml支持文件引用import ： 只能引用我们定义模板文件的模板内容块作用域的概念：只能引用目标文件定义的 template模板，如果目标文件内嵌套了其他模板，是不会被引用的，避免了引用模板死循环的问题include : 把目标 文件内除了模板代码块外的 所有代码都引入，相当于拷贝到了 include位置这里Wxss和css对比尺寸单位rpx先了解几个概念：设备像素\r\nCss像素\r\nPpi/dpi\r\nDpr ：手机的某一方向上设备像素和css像素之比虽然 wxss 支持 rem ，但是我们知道 rem 是根据 html 根元素的 fontSize 大小来适配的， wxss 不能直接操作 html 的样式属性，所以 rem 适配方案就失效了。 rpx 应运而生，规定屏幕宽度为 750rpx ，从而我们可以根据屏幕宽度来自适应， rpx 和 rem 实现方式是相似额，而且 rpx 最终转换为 rem样式导入外联样式引入： @import ‘./ss.wxss’内连样式引入： style 一般用来写动态的样式选择器一般想要修改他人插件样式的时候使用"}
{"title": "仿网易云音乐微信小程序 ", "author": "Rolan", "pub_time": "2019-6-27 00:37", "content": "项目部分截图(Gif)前言前一阵子学习了微信小程序，为了巩固所学的知识和提高实战经验，决定自己手撸一款小程序。因为听歌一直在用网易云音乐，所以突发奇想就做一款仿网易云音乐的小程序吧！开发中遇到了很多在学习中没有遇到过的坑，也很感谢在我改不出BUG时给予帮助的老师学长同学！本着学习和分享的目的，写下以下的文字,希望能给初学小程序的你带来一点帮助,大佬轻点喷。#开发前准备VScode代码编辑器。微信开发者工具ios网易云音乐(V5.9.1版本)酷狗音乐小程序(提供了一些思路)网易云音乐API(阿里巴巴矢量图标库)提供一些图标icontabBar部分自定义tabBar一般在开发中，微信小程序给我们的tabBar就能满足需求。但是，有些特别的需求必须使用自定义tabBar才能满足。 比如tabBar实现半透明。那么，如何才能自定义tabBar呢？1.首先,在 app.json里的\"tabBar\"里声明 \"tabBar\": { \"custom\": true }2.接着在项目的根目录下新建一个custom-tab-bar文件夹。里面包含index.wxml index.js index.json index.wxss四个文件。更多细节参考微信小程序文档developers.weixin.qq.com/miniprogram…\r\n\r\n\r\n\"tab-bar\">\r\n   \"tab-bar-border\">\r\n\r\n  'tab-bar-item' >\r\n    '../images/music.png' hidden='{{isShow_index}}' bindtap='switchTab_index'>\r\n    '../images/selected-music.png' hidden='{{!isShow_index}}' bindtap='switchTab_index'>\r\n    \"color:{{isShow_index ? selectedColor : color}}\">乐库\r\n  \r\n\r\n\r\n    'tab-bar-item' bindtap='switchTab_playing'>\r\n    '../images/selected-playing.png' hidden='{{isShow_playing}}'>\r\n    '../images/playing.png' hidden='{{!isShow_playing}}'>\r\n    \r\n  \r\n\r\n\r\n    'tab-bar-item' bindtap='switchTab_me'>\r\n    '../images/me.png' hidden='{{isShow_me}}'>\r\n    '../images/selected-me.png' hidden='{{!isShow_me}}'>\r\n    \"color:{{isShow_me ? selectedColor : color}}\">我的\r\n  \r\n\r\n复制代码// index.js\r\nComponent({\r\n  data: {\r\n    isShow_index:true,\r\n    isShow_playing:false,\r\n    isShow_me:false,\r\n    selected: 0, //首页\r\n    color: \"#8D8D8D\",\r\n    selectedColor: \"#C62F2F\",\r\n    list: [{\r\n      pagePath: \"/pages/index/index\",\r\n      iconPath: \"/images/music.png\",\r\n      selectedIconPath: \"/images/selected-music.png\",\r\n      text: \"乐库\"\r\n    }, {\r\n      pagePath: \"/pages/love/love\",\r\n        iconPath: \"/images/selected-playing.png\",\r\n      selectedIconPath: \"/images/playing.png\",\r\n      text: \"\"\r\n    },\r\n      {\r\n        pagePath: \"/pages/me/me\",\r\n        iconPath: \"/images/me.png\",\r\n        selectedIconPath: \"/images/selected-me.png\",\r\n        text: \"我的\"\r\n      }]\r\n  },\r\n\r\n  methods: {\r\n    switchTab_index:function(){\r\n      wx.switchTab({\r\n        url:'/pages/index/index'\r\n      })\r\n      this.setData({\r\n        isShow_index: true,\r\n        isShow_me: false,\r\n        isShow_playing: false\r\n      })\r\n    },\r\n    switchTab_playing: function () {\r\n      wx.switchTab({\r\n        url: '/pages/love/love'\r\n      })\r\n      this.setData({\r\n        isShow_playing: true,\r\n        isShow_index: false,\r\n        isShow_me: false\r\n      })\r\n    },\r\n    switchTab_me: function () {\r\n      wx.switchTab({\r\n        url: '/pages/me/me'\r\n      })\r\n      this.setData({\r\n        isShow_me:true,\r\n        isShow_playing: false,\r\n        isShow_index: false\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码tabBar半透明\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">/* custom-tab-bar/index.wxss */\r\n.tab-bar {\r\n  height:7%;\r\n  position: fixed;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  height: 48px;\r\n  background:#FAFBFD;\r\n  opacity: 0.93;\r\n  display: flex;\r\n  padding-bottom: env(safe-area-inset-bottom);\r\n}\r\n复制代码API封装一般我们https请求都是通过wx.request来请求,但是这种方法只能请求一次数据,如果首页用wx.request来请求的话,代码看起来会很冗长和杂乱。不仅自己容易搞糊涂,其他人看代码时也会很累。因此为了代码的整洁干净,我在这里新建了一个文件专门存放API。一般在根目录下的utils文件夹下新建一个api.js,但我在根目录下新建了文件夹API,里面包含api.js。// api.js\r\nconst API_BASE_URL = 'http://musicapi.leanapp.cn';\r\nconst request = (url, data) => { \r\n  let _url = API_BASE_URL  + url;\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: _url,\r\n      method: \"get\",\r\n      data: data,\r\n      header: {\r\n        'Content-Type': 'application/x-www-form-urlencoded'\r\n      },\r\n      success(request) {\r\n        resolve(request.data)\r\n        \r\n      },\r\n      fail(error) {\r\n        reject(error)\r\n      }\r\n    })\r\n  });\r\n}\r\n\r\n\r\nmodule.exports ={\r\n  gethotsongs:(data) =>{\r\n    return request('/search/hot',data)//热搜接口\r\n  },\r\n  searchSuggest:(data)=>{\r\n    return request('/search/suggest',data)//搜索建议接口\r\n  },\r\n  searchResult:(data)=>{\r\n    return request('/search',data)//搜索结果接口\r\n  },\r\n  getBanner:(data)=>{\r\n    return request('/banner',data)//个性推荐轮播\r\n  },\r\n  getsongsheet:(data)=>{\r\n    return request('/top/playlist',data)//热门歌单接口\r\n  },\r\n  getNewSong:(data)=>{\r\n    return request('/personalized/newsong',data)//最新音乐接口\r\n  },\r\n  getDjRadios:(data)=>{\r\n    return request('/dj/recommend',data)//电台推荐接口\r\n  },\r\n  getProgramRecommend:(data)=>{\r\n    return request('/program/recommend',data)//推荐节目接口\r\n  },\r\n  getRecommendType:(data)=>{\r\n    return request('/dj/recommend/type',data)//所有电台分类推荐\r\n  },\r\n  getRecommendMV:(data)=>{\r\n    return request('/personalized/mv',data)//推荐MV\r\n  },\r\n  getNewMv:(data)=>{\r\n    return request('/mv/first',data)//最新MV\r\n  },\r\n  getNewEst:(data)=>{\r\n    return request('/album/newest',data)//最新专辑\r\n  },\r\n  getTopList:(data)=>{\r\n    return request('/top/list',data)//排行榜\r\n  },\r\n  getDjList:(data)=>{\r\n    return request('/dj/catelist',data) //电台分类\r\n  },\r\n  getPay:(data)=>{\r\n    return request('/dj/paygift',data)//付费精品\r\n  },\r\n  getSonger:(data)=>{\r\n    return request('/toplist/artist',data)//歌手排行\r\n  }\r\n}\r\n复制代码api.js只能通过module.exports来暴露,那个页面要数据就从这拿。如果在哪个页面要用到它,还需要在头部引入一下:const API = require('../../API/api')以个性推荐轮播图为例，  getBanner: function() {\r\n    API.getBanner({\r\n      type: 2\r\n    }).then(res => {\r\n      if (res.code === 200) { //更加严谨\r\n        this.setData({\r\n          banner: res.banners\r\n        })\r\n      }\r\n    })\r\n  }\r\n复制代码这样就把请求到的数据存储到banner中了。搜索部分输入框样式\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">我这里是引入了WEUI的样式， 1.下载weui.wxss,链接我找不到了，所以我放上了我的github上的weui.wxss。 2.把下载好的weui.wxss放到根目录下。 3.在app.wxss中@import \"weui.wxss\";引入一下就可以使用微信提供给我们的样式了。 4.WeUI样式库热门搜索\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">上面已经提到我从api.js中拿数据。 // 从接口到获取到数据导入到hotsongs\r\n  gethotsongs() {\r\n    API.gethotsongs({ type: 'new' }).then(res => {\r\n      wx.hideLoading()\r\n      if (res.code === 200) {  //严谨\r\n        this.setData({\r\n          hotsongs: res.result.hots\r\n        })\r\n      }\r\n    })\r\n  }\r\n复制代码搜索历史\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">思路：当在输入框输入完成后-->失去焦点--> 利用wx.setStorageSync存进缓存中-->wx.getStorageSync获取到并把它打印出来。  // input失去焦点函数\r\n  routeSearchResPage: function(e) {\r\n    console.log(e.detail.value)\r\n    let history = wx.getStorageSync(\"history\") || [];\r\n    history.push(this.data.searchKey)\r\n    wx.setStorageSync(\"history\", history);\r\n  },\r\n\r\n//每次显示变动就去获取缓存，给history，并for出来。\r\n  onShow: function () {\r\n    this.setData({\r\n      history: wx.getStorageSync(\"history\") || []\r\n    })\r\n  },\r\n复制代码清空搜索历史\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">思路：×图标绑定事件->呼出对话框wx.showModal->确定则把history赋值为空  // 清空page对象data的history数组 重置缓存为[]\r\nclearHistory: function() {\r\n  const that = this;\r\n  wx.showModal({\r\n    content: '确认清空全部历史记录',\r\n    cancelColor:'#DE655C',\r\n    confirmColor: '#DE655C',\r\n    success(res) {\r\n      if (res.confirm) {\r\n        that.setData({\r\n          history: []\r\n        })\r\n        wx.setStorageSync(\"history\", []) //把空数组给history,即清空历史记录\r\n      } else if (res.cancel) {\r\n      }\r\n    }\r\n  })\r\n},\r\n复制代码实时搜索建议\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">思路：实时获取输入框的值->把值传给搜索建议API，发起网络请求->请求之后拿到搜索建议->打印结果并隐藏其他组件只保留搜索建议的组件(类似于Vue里的v-show) //获取input文本并且实时搜索,动态隐藏组件\r\n  getsearchKey:function(e){\r\n    console.log(e.detail.value) //打印出输入框的值\r\n    let that = this;\r\n    if(e.detail.cursor != that.data.cursor){ //实时获取输入框的值\r\n      that.setData({\r\n        searchKey: e.detail.value\r\n      })\r\n    }\r\n    if(e.value!=\"\"){ //组件的显示与隐藏\r\n      that.setData({\r\n        showView: false\r\n      })\r\n    } else{\r\n      that.setData({\r\n        showView: \"\"\r\n      })\r\n    }\r\n    if(e.detail.value!=\"\"){ //解决 如果输入框的值为空时，传值给搜索建议，会报错的bug\r\n      that.searchSuggest();\r\n    }  \r\n  }\r\n复制代码// 搜索建议\r\nsearchSuggest(){\r\n  API.searchSuggest({ keywords: this.data.searchKey ,type:'mobile'}).then(res=>{\r\n    if(res.code === 200){\r\n      this.setData({\r\n        searchsuggest:res.result.allMatch\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码点击热搜或历史，执行搜索思路：关键是event,点击通过e.currentTarget.dataset.value拿到所点击的值，再交给其他方法执行搜索行为。// 点击热门搜索值或搜索历史，填入搜索框\r\n  fill_value:function(e){\r\n    let that = this;\r\n    console.log(history)\r\n    // console.log(e.currentTarget.dataset.value)\r\n    that.setData({\r\n      searchKey: e.currentTarget.dataset.value,//点击吧=把值给searchKey,让他去搜索\r\n      inputValue: e.currentTarget.dataset.value,//在输入框显示内容\r\n      showView:false,//给false值，隐藏 热搜和历史 界面\r\n      showsongresult: false, //给false值，隐藏搜索建议页面\r\n    })\r\n    that.searchResult(); //执行搜索功能\r\n  }\r\n复制代码搜索结果思路：输入结束->确认键->调用searchResult请求到结果// 搜索完成点击确认\r\n  searchover:function(){\r\n    let that = this;\r\n    that.setData({\r\n      showsongresult: false\r\n    })\r\n    that.searchResult();\r\n  }\r\n复制代码 // 搜索结果\r\nsearchResult(){\r\n  console.log(this.data.searchKey)\r\n  API.searchResult({ keywords: this.data.searchKey, type: 1, limit: 100, offset:2 }).then(res => {\r\n    if (res.code === 200) {\r\n      this.setData({\r\n        searchresult: res.result.songs\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码乐库部分乐库部分其实没什么逻辑很难的部分，以结构和样式为主，在这里就不赘述了。可以到我的github上查看。在这里分享一些小功能的实现和踩到的坑。个性推荐，主播电台切换1.个性推荐和主播电台是两个swiper-item所以他们才可以左右滑动，就像轮播图一样，不过轮播图放的是图片，而这里放的是整个页面。 2.我要实现的效果是左右滑动的同时，个性推荐和主播电台下面的白色方块也要跟着滑动。1. 第一种方法给包裹两个swiper-item的swiper添加一个bindchange=\"changeline\"事件，把事件对象event打印出来发现，console.log(e.detail.current),当我们左右滑动的时候cuurrent的值会在0和1之间切换。所以我给白色方块添加class=\"{{changeline?'swiper_header_line_before':'swiper_header_line_after'}}\"\r\n复制代码    if(e.detail.current === 0){\r\n    this.setData({\r\n       changeline:true\r\n      })\r\n    }else{\r\n    this.setData({\r\n       changeline:false\r\n      })\r\n    }\r\n复制代码当current为0，即页面在个性推荐时，让changeline为true;当current为1，即页面在主播电台时，让changeline为false;为true时，给白色方块加持swiper_header_line_before的样式，为false时，加持swiper_header_line_after的样式。这样就可以跟随swiper-item的滑动而切换了。但是，这种切换方式太僵硬了，没有那种流畅的切换效果，而且不适合多swiper-item页面。2. 第二种方法\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">让一半宽度，四分之一宽度设置为变量是为了兼容不同的手机型号。因为写死数据肯定会有BUG，所以才要计算宽度。\"weui-navbar-slider\" style=\"transform:translateX({{slideOffset}}px);\">\r\n复制代码.weui-navbar-slider{\r\n  width:28px;\r\n  height: 5px;\r\n  background: #ffffff;\r\n  border-radius:10rpx;\r\n  transition: transform .6s;\r\n }\r\n复制代码slideOffset为变量，动态接受从data传来的数据。onLoad:function(){\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // console.log(res.windowWidth)\r\n        // console.log(res.windowWidth / 2 / 2)\r\n        half = res.windowWidth / 2 ;\r\n        quarter = res.windowWidth / 2 / 2;\r\n        that.setData({\r\n          slideOffset: quarter - 14 //onLoad的时候让 quarter - 14 给slideOffset，即一开始就让他在个性推荐的下面，否则onLoad的时候一开始在0的位置\r\n        })\r\n      }\r\n    })\r\n}\r\n\r\n  changeline:function(e){\r\n    // console.log(e)\r\n    // console.log(e.detail.current)\r\n    let current = e.detail.current; //获取swiper的current值\r\n    if(e.detail.current === 0){\r\n      this.setData({\r\n        slideOffset: quarter - 14\r\n      })\r\n    }\r\n    if(e.detail.current === 1){\r\n      this.setData({\r\n        slideOffset: (quarter - 14) + half\r\n      })\r\n    }\r\n    if(e.detail.current === null){\r\n      this.setData({\r\n        slideOffset: quarter - 14\r\n      })\r\n    }\r\n  }\r\n复制代码MV播放\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">主要是结构和样式，我直接上代码了。\r\n\"mv_box\">\r\n    \"{{mv.brs['480']}}\" class=\"mv\" autoplay=\"{{autoplay}}\" loop=\"{{loop}}\" direction=\"{{0}}\" show-fullscreen-btn=\"{{showfullscreenbtn}}\"\r\n    show-center-play-btn=\"{{showcenterplaybtn}}\" enable-progress-gesture=\"{{enableprogressgesture}}\" show-mute-btn=\"{{showmutebtn}}\" title=\"{{mv.name}}\"\r\n    play-btn-position=\"{{center}}\" object-fit=\"{{objectfit}}\">\r\n\r\n\r\n\"mv_name\">{{mv.name}}\r\n\"mv_time\"> 发行:  {{mv.publishTime}}\r\n\"mv_time mv_times\">播放次数:  {{mv.playCount}}\r\n\"mv_time mv_desc\">{{mv.desc}}\r\n\"mv_time mv_desc mv_other\">点赞: {{mv.likeCount}}\r\n\"mv_time mv_desc mv_other\">收藏: {{mv.subCount}}\r\n\"mv_time mv_desc mv_other\">评论: {{mv.commentCount}}\r\n\"mv_time mv_desc mv_other\">分享: {{mv.shareCount}}\r\n复制代码/* play/play_mv.wxss */\r\n.mv_box{\r\n    width: 100%;\r\n    height: 480rpx;\r\n    margin-top:-2rpx;\r\n}\r\n.mv{\r\n    width: 100%;\r\n    height: 100%;\r\n    border-radius:15rpx;\r\n}\r\n.mv_name{\r\n    margin-top:20rpx;\r\n    margin-left:20rpx;\r\n}\r\n.mv_time{\r\n    font-size: 12px;\r\n    margin-left:20rpx;\r\n    color:#979798;\r\n    display:initial;\r\n}\r\n.mv_times{\r\n    margin-left: 100rpx;\r\n}\r\n.mv_desc{\r\n    display: block;\r\n    color:#6A6B6C;\r\n}\r\n.mv_other{\r\n    display: block;\r\n}\r\n复制代码// play_mv.js\r\nconst API_BASE_URL = 'http://musicapi.leanapp.cn';\r\nconst app = getApp();\r\nPage({\r\n  data: {\r\n    mv: [],\r\n    autoplay: true,\r\n    loop: true,\r\n    showfullscreenbtn: true,\r\n    showcenterplaybtn: true,\r\n    enableprogressgesture: true,\r\n    showmutebtn: true,\r\n    objectfit: 'contain',\r\n  },\r\n  onLoad: function (options) {\r\n    // console.log(mv_url);\r\n    const mvid = options.id; // onLoad()后获取到歌曲视频之类的id\r\n\r\n    // 请求MV的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)\r\n    wx.request({\r\n      url: API_BASE_URL + '/mv/detail',\r\n      data: {\r\n        mvid: mvid    \r\n      },\r\n      success: res => {\r\n        console.log(res.data.data.brs['480'])\r\n        console.log('歌曲音频url:', res)\r\n        if (res.data.data.brs === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页\r\n          console.log('播放出错')\r\n          wx.showModal({\r\n            content: '服务器开了点小差~~',\r\n            cancelColor: '#DE655C',\r\n            confirmColor: '#DE655C',\r\n            showCancel: false,\r\n            confirmText: '返回',\r\n            complete() {\r\n              wx.switchTab({\r\n                url: '/pages/index/index'\r\n              })\r\n            }\r\n          })\r\n        } else {\r\n          this.setData({\r\n            mv: res.data.data\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n})\r\n复制代码歌手榜\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">// 歌手榜的js\r\nconst API = require('../../API/api');\r\nconst app = getApp();\r\nPage({\r\n\r\n  data: {\r\n    songers: [], //歌手榜\r\n  },\r\n\r\n  onLoad: function (options) {\r\n    wx.showLoading({\r\n      title: '加载中',\r\n    });\r\n    this.getSonger();\r\n  },\r\n\r\n  getSonger: function () {\r\n    API.getSonger({}).then(res => {\r\n      wx.hideLoading()\r\n      this.setData({\r\n        songers: res.list.artists.slice(0, 100)\r\n      })\r\n    })\r\n  },\r\n  handleSheet: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性\r\n    const sheetId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId\r\n    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面\r\n      url: `./moremore_songer?id=${sheetId}`\r\n    })\r\n  },\r\n})\r\n复制代码\r\nfor=\"{{songers}}\" wx:key=\"\" class='songer_box' data-id=\"{{item.id}}\" bindtap='handleSheet'>\r\n  'songer_index_box'>\r\n    'songer_index'>{{index + 1}}\r\n  \r\n  'songer_img_box'>\r\n  \"{{item.picUrl}}\" class='songer_img'>\r\n  \r\n  'songer_name_box'>\r\n  'songer_name'>{{item.name}}\r\n  'songer_score'>{{item.score}}热度\r\n  \r\n\r\n复制代码// 歌手下级路由歌曲列表\r\nconst API_BASE_URL = 'http://musicapi.leanapp.cn';\r\nconst app = getApp();\r\nPage({\r\n  data: {\r\n    songList: []\r\n  },\r\n  onLoad: function (options) {\r\n    wx.showLoading({\r\n      title: '加载中',\r\n    });\r\n    const sheetId = options.id;\r\n    wx.request({\r\n      url: API_BASE_URL + '/artists',\r\n      data: {\r\n        id: sheetId    \r\n      },\r\n      success: res => {\r\n        const waitForPlay = new Array;\r\n        for (let i = 0; i <= res.data.hotSongs.length - 1; i++) { //循环打印出其id\r\n          waitForPlay.push(res.data.hotSongs[i].id) //循环push ID 到waitForPlay数组\r\n          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组\r\n          // console.log(app.globalData.waitForPlaying)\r\n        }\r\n        wx.hideLoading()\r\n        console.log(res.data.hotSongs)\r\n        this.setData({\r\n          songList: res.data.hotSongs\r\n        })\r\n      }\r\n    })\r\n  },\r\n  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性\r\n    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId\r\n    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面\r\n      url: `../../play/play?id=${audioId}`\r\n    })\r\n  }\r\n})\r\n复制代码\r\n'search_result_songs'>\r\n  for=\"{{songList}}\" wx:key=\"\" class='search_result_song_item songer_box' data-id=\"{{item.id}}\" bindtap='handlePlayAudio'>\r\n    'songer_index_box'>\r\n      'songer_index'>{{index + 1}}\r\n    \r\n    'songer_img_box'>\r\n      'search_result_song_song_name'>{{item.name}}\r\n      'search_result_song_song_art-album'>{{item.ar[0].name}} - {{item.al.name}}\r\n    \r\n  \r\n\r\n复制代码推荐歌单\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">因为样式与排行榜类似，所以只放出图片，源码可以到我的github上查看。榜单排行\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">请查看源码换一换功能\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">思路：绑定点击事件->选取随机的三个数->给空值->push三个随机数进数组中->重新赋值。  // 换一换\r\n  change_1:function(){\r\n    let maxNum = this.data.more_recommend_create.length  //计算数据长度\r\n    let r1 = parseInt(Math.random() * (maxNum - 0) + 0); //取【0-数据长度】内的整数随机数\r\n    let r2 = parseInt(Math.random() * (maxNum - 0) + 0);\r\n    let r3 = parseInt(Math.random() * (maxNum - 0) + 0);\r\n    this.setData({\r\n      recommend_create: []\r\n    })\r\n    //重新取3组数据\r\n    this.data.recommend_create.push(this.data.more_recommend_create[r1])\r\n    this.data.recommend_create.push(this.data.more_recommend_create[r2])\r\n    this.data.recommend_create.push(this.data.more_recommend_create[r3])\r\n    //重新赋值\r\n    this.setData({\r\n      recommend_create: this.data.recommend_create\r\n    })\r\n  }\r\n复制代码播放界面\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">图片太大，因此加快了播放。播放功能思路：利用data-id=\"{{item.id}}\"获取到歌曲ID放在event中-> 通过event对象事件获取ID并跳转到播放页面 ->wx.request获取到歌曲的音频地址及detail->背景音频管理器 wx.getBackgroundAudioManager()->播放以歌手榜下级路由歌曲列表为例，for=\"{{songList}}\" wx:key=\"\" class='search_result_song_item songer_box' data-id=\"{{item.id}}\" bindtap='handlePlayAudio'>\r\n复制代码  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性\r\n    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId\r\n    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面\r\n      url: `../../play/play?id=${audioId}`\r\n    })\r\n  }\r\n复制代码// play.js\r\nconst API_BASE_URL = 'http://musicapi.leanapp.cn';\r\nconst app = getApp();\r\nPage({\r\ndata: {\r\n  isPlay: '',\r\n  song:[],\r\n  innerAudioContext: {},\r\n  show:true,\r\n  showLyric:true,\r\n  songid:[],\r\n  history_songId:[]\r\n},\r\nonLoad: function (options) {\r\n  const audioid = options.id; // onLoad()后获取到歌曲视频之类的id\r\n  this.play(audioid); //把从wxml获取到的值传给play()\r\n},\r\nplay: function (audioid){\r\n  const audioId = audioid;\r\n  app.globalData.songId = audioId;  //让每一个要播放的歌曲ID给全局变量的songId\r\n  const innerAudioContext = wx.createInnerAudioContext();\r\n  this.setData({\r\n    innerAudioContext,\r\n    isPlay: true\r\n  })\r\n  // 请求歌曲音频的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)\r\n  wx.request({\r\n    url: API_BASE_URL + '/song/url',\r\n    data: {\r\n      id: audioId\r\n    },\r\n    success: res => {\r\n      if (res.data.data[0].url === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页\r\n        wx.showModal({\r\n          content: '服务器开了点小差~~',\r\n          cancelColor: '#DE655C',\r\n          confirmColor: '#DE655C',\r\n          showCancel: false,\r\n          confirmText: '返回',\r\n          complete() {\r\n            wx.switchTab({\r\n              url: '/pages/index/index'\r\n            })\r\n          }\r\n        })\r\n      } else {\r\n        this.createBgAudio(res.data.data[0]);\r\n      }\r\n    }\r\n  })\r\n  //获取到歌曲音频，则显示出歌曲的名字，歌手的信息，即获取歌曲详情；如果失败，则播放出错。\r\n  wx.request({\r\n    url: API_BASE_URL + '/song/detail',\r\n    data: {\r\n      ids: audioId    //必选参数ids\r\n    },\r\n    success: res => {\r\n      if (res.data.songs.length === 0) {\r\n        wx.showModal({\r\n          content: '服务器开了点小差~~',\r\n          cancelColor: '#DE655C',\r\n          confirmColor: '#DE655C',\r\n          showCancel: false,\r\n          confirmText: '返回',\r\n          complete() {\r\n            wx.switchTab({\r\n              url: '/pages/index/index'\r\n            })\r\n          }\r\n        })\r\n      } else {\r\n        this.setData({\r\n          song: res.data.songs[0],  //获取到歌曲的详细内容，传给song\r\n        })\r\n        app.globalData.songName = res.data.songs[0].name;\r\n      }\r\n    },\r\n  })\r\n},\r\ncreateBgAudio(res) {\r\n  const bgAudioManage = wx.getBackgroundAudioManager(); //获取全局唯一的背景音频管理器。并把它给实例bgAudioManage\r\n  app.globalData.bgAudioManage = bgAudioManage;         //把实例bgAudioManage(背景音频管理器) 给 全局\r\n  bgAudioManage.title = 'title';                        //把title 音频标题 给实例\r\n  bgAudioManage.src = res.url;                          // res.url 在createBgAudio 为 mp3音频  url为空，播放出错\r\n  const history_songId = this.data.history_songId\r\n  const historySong = {\r\n    id: app.globalData.songId,\r\n    songName:app.globalData.songName\r\n  }\r\n  history_songId.push(historySong)\r\n  bgAudioManage.onPlay(res => {                         // 监听背景音频播放事件\r\n    this.setData({\r\n      isPlay: true,\r\n      history_songId\r\n    })\r\n  });\r\n  bgAudioManage.onEnded(() => {                  //监听背景音乐自然结束事件，结束后自动播放下一首。自然结束，调用go_lastSong()函数，即歌曲结束自动播放下一首歌\r\n    this.go_lastSong();\r\n  })\r\n  wx.setStorageSync('historyId', history_songId); //把historyId存入缓存\r\n},\r\n})\r\n复制代码暂停/播放  \r\n\"play_suspend\">\r\n  \"icon_playing\">\"handleToggleBGAudio\" src=\"../images/suspend.png\" hidden=\"{{!isPlay}}\" class=\"{{'img_play_suspend'}}\" />  \r\n  \"handleToggleBGAudio\" src=\"../images/play.png\" hidden=\"{{isPlay}}\" class=\"{{'img_play_suspend'}}\" /> \r\n\r\n复制代码// 播放和暂停\r\nhandleToggleBGAudio() {\r\n  // const innerAudioContext = app.globalData.innerAudioContext;\r\n  const bgAudioManage = app.globalData.bgAudioManage;\r\n  const {isPlay} = this.data;\r\n  if (isPlay) {\r\n    bgAudioManage.pause();\r\n    // innerAudioContext.pause();handleToggleBGAudio\r\n  } else {\r\n    bgAudioManage.play();\r\n    // innerAudioContext.play();\r\n  }\r\n  this.setData({\r\n    isPlay: !isPlay\r\n  })\r\n  console.log(this.data.isPlay)\r\n}\r\n复制代码上一首/下一首(随机播放)思路：点击歌单或歌手页，获取到对应的歌单/歌手id->wx.request请求数据获取到所有的歌单内/歌手热门歌曲音频地址->给全局变量globalData->点击上一首/下一首随机获取到全局变量的一则数据->给play()方法->播放\r\n  onLoad: function (options) {\r\n  wx.showLoading({\r\n    title: '加载中',\r\n  });\r\n  const sheetId = options.id;\r\n  wx.request({\r\n    url: API_BASE_URL + '/playlist/detail',\r\n    data: {\r\n      id: sheetId    \r\n    },\r\n    success: res => {\r\n      const waitForPlay = new Array;\r\n      for (let i = 0; i <= res.data.playlist.trackIds.length - 1;i++){ //循环打印出其id\r\n        waitForPlay.push(res.data.playlist.trackIds[i].id) //循环push ID 到waitForPlay数组\r\n        app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组\r\n      }\r\n      wx.hideLoading()\r\n      this.setData({\r\n        songList: res.data.playlist.tracks\r\n      })  \r\n    }\r\n  })\r\n}\r\n复制代码\"icon_playing \">\"../images/lastSong.png\" class=\" icon_play\" bindtap=\"go_lastSong\" />\r\n\"icon_playing \">\"../images/nextSong.png\" class=\" icon_play\" bindtap=\"go_lastSong\" />\r\n复制代码  go_lastSong:function(){ \r\n  let that = this;\r\n  const lastSongId = app.globalData.waitForPlaying;\r\n  const songId = lastSongId[Math.floor(Math.random() * lastSongId.length)]; //随机选取lastSongId数组的一个元素\r\n  that.data.songid = songId;\r\n  this.play(songId)//传进play()方法中\r\n  app.globalData.songId=songId;\r\n}\r\n复制代码歌词/封面切换\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">因为网易云API的歌词接口崩溃，请求不到歌词，所以我只能把歌词写死为纯音乐，请欣赏。类似于v-show。 \r\n\r\n\"sing-show\" bindtap=\"showLyric\" >\r\n  \"moveCircle {{isPlay ? 'play' : ''}}\" hidden=\"{{!showLyric}}\">\r\n    \"{{song.al.picUrl}}\" class=\"coverImg {{isPlay ? 'play' : ''}}\" hidden=\"{{!showLyric}}\"/>\r\n  \r\n  \"{{showLyric}}\" class=\"songLyric\">纯音乐，请欣赏\r\n\r\n复制代码  // 点击切换歌词和封面\r\nshowLyric(){\r\n  const {showLyric} = this.data;\r\n  this.setData({\r\n    showLyric: !showLyric\r\n  })\r\n}\r\n复制代码破产版的孤独星球动效\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">封面旋转：@keyframes rotate {\r\n  0%{\r\n    transform: rotate(0);\r\n  }\r\n  100%{\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n复制代码扩散的圆形线条： 其实就是外面套一个盒子，盒子边框变大以及透明度逐渐变低。@keyframes moveCircle {\r\n  0%{\r\n    width: 400rpx;\r\n    height: 400rpx;\r\n    border: 1px solid rgba(255, 255, 255, 1)\r\n  }\r\n  30%{\r\n    width: 510rpx;\r\n    height: 510rpx;\r\n    border: 1px solid rgba(255, 255, 255, 0.8)\r\n  }\r\n  50%{\r\n    width: 610rpx;\r\n    height: 610rpx;\r\n    border: 1px solid rgba(255, 255, 255, 0.6)\r\n  }\r\n  80%{\r\n    width: 700rpx;\r\n    height: 700rpx;\r\n    border: 1px solid rgba(255, 255, 255, 0.4)\r\n  }\r\n  99%{\r\n    width: 375px;\r\n    height: 375px;\r\n    border: 1px solid rgba(255, 255, 255, 0.1)\r\n  }\r\n  100%{\r\n    width: 0px;\r\n    height: 0px;\r\n    border: 1px solid rgba(255, 255, 255, 0)\r\n  }\r\n}\r\n复制代码背景毛玻璃\r\n\"{{song.al.picUrl}}\" class=\"background_img\" >\r\n复制代码/* 播放界面毛玻璃效果 */\r\n.background_img{ \r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  filter: blur(20px);\r\n  z-index: -1;\r\n  transform: scale(1.5); /*和网易云音乐对比了一下，发现也是放大1.5倍*/\r\n}\r\n复制代码播放tabBar\" style=\"width: auto; height: auto; border-style: none; max-height: none; margin: 0px; max-width: 100%; visibility: visible; background-color: rgb(248, 249, 250); background-position: 50% center; background-repeat: no-repeat; cursor: zoom-in;\">思路是参考酷狗音乐小程序。这个tabBar的js，wxml与播放功能界面的js，wxml相同。因为音乐播放是用wx.getBackgroundAudioManager()背景音频播放器管理的，所以才能同步。我的tabBar播放历史思路：play.js中一旦播放成功就把歌名及歌曲ID传入全局变量->push到play.js里的数组中->wx.setStorageSync把数据存入缓存->在需要的页面wx.getStorageSync获取到缓存。\r\nconst history_songId = this.data.history_songId\r\nconst historySong = {\r\n      // id: res.id\r\n      id: app.globalData.songId,\r\n      songName:app.globalData.songName\r\n    }\r\n    history_songId.push(historySong)\r\n    wx.setStorageSync('historyId', history_songId); //把historyId存入缓存\r\n复制代码\r\n onShow:function(){\r\n    var history = wx.getStorageSync('historyId');\r\n    // console.log(history)\r\n     this.setData({\r\n      hidden:true,\r\n      //  historyId: app.globalData.songName\r\n       historyId: history\r\n    })\r\n    console.log(this.data.historyId)\r\n  }\r\n复制代码结语做项目的过程总的来说痛并快乐，因为改不出BUG的样子真的很狼狈，但实现了某一个功能的那一刻真的很欣慰。再次感谢给予帮助的老师学长同学。如果你喜欢这篇文章或者可以帮到你，不妨点个赞吧！同时也非常希望看到这篇文章的你在下方给出建议！最后奉上源码，有需要的可以自取。最后，说点题外话，因为我是2020届毕业生，现在面临实习压力，有没有大佬捞一下。"}
{"title": "腾讯在线教育小程序开发实践之路 ", "author": "Rolan", "pub_time": "2019-7-2 00:08", "content": "作者于2019年6月21日赴北京GMTC大前端技术会议小程序专场，分享话题《腾讯在线教育小程序开发实践之路》演讲稿一、腾讯在线教育小程序矩阵首先介绍下腾讯在线教育下的3个主要业务：面向成人职业化，兴趣化学习的腾讯课堂面向小学，初高中k12领域的企鹅辅导面向少儿英语学习的ABCmouse每个业务下都有PC Web,客户端,H5,APP这几端，来满足学生的多端上课需求。但由于教育的前身是基于QQ群视频孵化出来的，后续也是围绕QQ生态去搭建产品形态，所以在流量上面，QQ相关的流量占比较多。我们希望能够通过小程序生态，来为教育业务带来微信端流量的增长，并且优化学生的微信端上课体验，所以我们打造了在线教育的小程序矩阵。我们通过工具，内容型的小程序，来获取流量。比如腾讯课堂打开小程序，腾讯微课堂，企鹅速算，口语拼读等工具型小程序，并最终转化到平台小程序上。二、小程序基础架构设计及工程化探索上面提到的那么多小程序，我们是如何进行框架选型 以及团队在多人协作的开发中，是如何制定统一的开发规范，小程序工程化的探索呢？下面将一一介绍。框架选型时，我们对小程序几大主流开发框架，taro, wepy, mpvue跟原生开发框架进行了对比。可以看出原生框架在CSS预处理，多端复用，管理，自动构建这几块能力对比其他框架是欠缺到。但考虑到以下几点，我们比较倾向于使用原生框架进行开发：小程序的特性更新迭代速度较快，我们希望能最快使用上最新特性，其他第三方框架可能会有迭代滞后到问题我们的多端复用需求较弱对性能调优，问题排查要求较高，希望直接操控原生API那么以上这些开发上的缺陷，使用原生框架是否可以解决，如何解决呢？1，CSS预处理首先来看CSS预处理，我们是期望能够在小程序中使用到CSS预处理，包括嵌套语法，mixin，变量等以及styleLint等工具。 经过调研后，我们可以直接使用postcss来写样式文件并编译处理成wxss。并且通过引入插件，可以解决小程序样式开发中的痛点。比如postcss-url解决background-image不支持本地图片问题，将其变成base64格式；通过postcss-font-base64插件将字体变成base64格式。2，数据管理数据管理方面可以使用westore来接入。3，构建小程序的构建需要完成什么事情呢？小程序开发者工具已经提供了部分能力: ES7/ES6转ES5，NPM包管理，代码分包，组件化，打包合并。我们借助gulp来实现图片压缩以及前面提到的Post CSS编译为什么使用gulp而不用更流行的webpack呢?这里补齐的能力主要涉及文件处理比较多，使用gulp开发效率较高，小程序一些官方脚手架也是使用gulp。最后，我们选择了小程序原生框架作为我们的开发框架。并且补齐了跟其他开发框架对比欠缺的基础能力。当然，这里并非说其他框架不好，具体选择还是需要看具体的业务场景。确定好开发框架后，统一的目录规范也是团队协同开发必须约束的。在引入npm包管理后，我们在小程序的基础目录中，通过新起了一个miniprogram目录来作为小程序代码的根目录。这是由于小程序会对node_modules里面的包打包编译到miniprogram_npm目录，为了避免小程序的node_modules跟其他工程化相关的node_modules混在一起，才新起了一个文件夹来存放小程序工程代码。可以通过修改project.config.js可以配置小程序代码的根目录路径。约束好目录，那么在团队协同开发，如何维护规范化，风格统一的代码，我们希望可以团队成员开发时可以统一代码规范, 提交规范, 风格保持一致。因此，跟我们其他web项目一样，我们可以使用 eslint，stylelint，commitment，prettier等插件来对我们的代码进行约束，规范。通过git hook来在做提交时的校验检测，不通过则不允许提交。通过Commitizen以及standard-version来自动化生成统一的版本号以及ChangeLog。会自动将你在本次版本迭代中，提交的规范化log（遵循Angular团队的commit规范： https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits )自动生成ChangeLog, 注明是特性发布，bugfix还是breakingChange，以及对应的log信息。后续我们在需要回滚或者回溯某一版本的改动时，就可以一目了然。我们基于上面的能力以及约束规范，做成统一的脚手架，方便团队在统一的环境下快速开发，并且开源了出去( https://github.com/imweb/generator-imweb-wxapp )。三、小程序开发实践介绍完我们的框架选型，工程化探索，接下去分享下在线教育小程序的开发实践经历。1，小程序音视频第一部分是小程序音视频能力相关的实践。腾讯课堂是一个在线学习的平台，那么最核心的就是音视频直播，录播能力。那么在小程序上面，我们如何搭建课堂音视频能力呢？1)，直播场景我们先来看未接入小程序前，腾讯课堂的直播架构。我们通过老师上行到云上，再实时下行到端上, App学生以及通过WebRTC下行到PC web学生。对于延迟要求不高的场景，我们可以将直播流旁路转码到CDN，再供用户拉流观看，以节省成本。这是各端使用的直播协议以及延迟对比，小程序应该采用那种协议，如何接入呢？揭秘之前，我们先来了解下小程序音视频能力的发展历史。最初，小程序音视频只有原生的video标签。意味着只能支持 HLS高延时直播场景。2017年4月份，腾讯云与小程序达成合作，在小程序上嵌入腾讯云音视频SDK，并封装成了live-pusher,live-player标签,使小程序能够支持更低延迟的直播协议，如：rtmp, http-flv等。因此，我们可以使用live-player来播放rtmp,http-flv协议的流媒体来播放，降低小程序直播场景上的延迟。不过目前live-player还存在一些不足:比如全屏按钮不支持，需要自己定义。由于live-player是原生组件，因此需要通过cover-view以及一些hack方式来实现自定义控制条的全屏按钮跟视频窗口显示层级的bugIOS全屏时，bindevent无效 不过小程序后面采用同层渲染的方案，解决了原生组件需要使用cover-view来解决显示层级问题，使用最新版本的基础库即可。使用live-player大概1-2s的延迟，那么小程序上还有没更低延迟的直播方案呢？加入你是在腾讯云上面开通了WebRTC后，可以使用wbertc-room去实现小程序上更低延迟的直播。其原理是基于live-player的RTMP，但走的高速专线，不经过CDN，降低了延迟。(小程序接入课堂音视频的整体架构图)2)，录播场景介绍完直播接入方案，接着讲下录播。由于版权保护，腾讯课堂录播播放采用了加密HLS。由于录播对延迟没要求，小程序上面可以直接使用video标签来播放加密hls流。在Web上，播放加密HLS的流程如下：1，获取到加密HLS的m3u8地址，传给video;2，浏览器video底层解析m3u8，发现其带有加密协议标识-EXT-X-KEY，其值是一个获取解密key的接口地址；3，浏览器会自动发起该请求，发起请求，去获取解密key；4，浏览器自动发起请求时，会把用户登陆态通过cookie方式带上，业务后台对cookie鉴权后返回解密key，之后浏览器拿到解密key后就可以解密播放了。但在小程序中，由于小程序是没有cookie的，那么怎么去针对小程序发起的获取解密key请求鉴权呢？我们通过在获取m3u8文件时，在meu8地址加入加密后的鉴权参数，并加上前缀\"voddrm.token.\"，这样server返回m3u8文件时，会在EXT-X-KEY的请求地址上，将鉴权参数拼接进去。后面发起请求时，业务后台获取到鉴权参数，按照协商好到方式解密，即可获取到用户登陆票据进行判断是否合法用户。之后就按照之前的流程，鉴权通过即返回解密key。2，小程序自动化发布补齐了音视频能力后，我们项目也正常上线。由于平台功能不断增加，小程序也在按照以下流程进行迭代发布。但是上面流程是存在一些隐藏问题的，特别对于新人，容易因疏忽导致出错，我们也因此导致了一个现网bug。不知道大家能发现不？揭晓下答案，主要有2个问题：1，多人开发过程，npm包可能存在不同版本，比如登录能力的npm包，有可能会忘记更新最新包。2，构建npm按钮在开发者工具上面入口比较隐蔽，容易导致更新了npm包但是忘记点击构建npm，覆盖了线上的特性 上面操作对于熟悉小程序开发的人来说不容易出错，但对于新人，由于不熟悉，容易疏忽。即使犯错但概率很小，但是也必须解决。 那么我们能否通过自动化工具来帮我们校验检测这些隐患呢？我们希望在上传发布前，可以进行以下流程的自动检测：1，代码合并主干检测2，node_modules版本检测，必须是大于或者等于当前package.json的版本3，自动执行构建npm操作4，自动执行上传操作，包括填写版号以及备注信息其中1跟2可以通过githook以及npm命令来判断，3跟4涉及到小程序相关到能力调用，是否有暴露相关到接口可以调用呢？这里小程序开发者工具提供了命令行以及http调用方式（ https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html），可以让你操作项目打开/关闭，代码上传，预览，构建npm , 自动化测试等功能。因此，我们利用这个能力，采用cli调用等方式，实现了构建npm以及自动发布等能力。具体流程如下：1，进行是否更新最新主干代码检测；2，判断是否安装了小程序开发者工具且正常设置到环境变量；3，进行本地node_modules版本检测；4，调用构建npm命令；5，自动获取package.json的版本号作为上传版本，获取git 提交log作为备注； 6，调用上传命令进行上传自动化发布流程示例3，小程序第三方平台有了以上工具后，我们就可以愉快地进行开发迭代发布了。但随着我们课堂平台小程序的推广，课堂平台的各家机构都想拥有其自己的机构小程序，并且其页面是课堂平台小程序的一个子集。通过分析后，我们决定通过构建的方式，从平台小程序中拆离出机构小程序代码。通过2份模版配置信息, 通过构建，可以动态生成平台小程序以及机构小程序的app.json。这样进行上传的时候，就只会上传对应的页面。代码复用的问题解决了，但随着而来还有另外一个问题。需要生成的机构有80多家，有些机构不一定有开发人员，如果帮助机构快速上传发布他们自己的机构小程序呢？这里引入微信第三方平台的概念（ https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1489144594_DhNoV&token=&lang=zh_CN ），我们可以往微信开发平台申请成为第三方平台。机构申请完独立的小程序账号后，将其授权给我们腾讯课堂第三方平台。这样我们就可以获取到该机构到代码管理，版本发布到权限。通过上传我们之前构建好到机构小程序模版，再调用发布接口，就可以快速实现帮助机构发布其独立个体到机构小程序了。4，性能优化实践我们的小程序上线后，通过在小程序管理后台看到的启动总耗时，发现几个问题： 1，小程序管理后台只展示了启动总耗时，下载耗时，渲染耗时这3个数据纬度，但是启动总耗时!= 下载耗时 + 渲染耗时；2，启动耗时居然达到了3.8s，这是一个合格都数据吗？除了下载耗时跟渲染耗时，其他耗时消耗在哪个环节呢？要想知道耗时消耗在哪里，首先要先了解小程序启动过程中究竟发生了什么。1， 小程序初始化在这个步骤，微信会初始化小程序环境，比如逻辑层的js引擎，视图层的WebView，并且注入公共基础库。2，下载小程序代码包这里会进行业务小程序代码包的下载。3，加载业务代码包对下载完成对代码包进行注入执行 - 小程序的代码会被加载到适当的线程中执行。此时，所有app.js、页面所在的JS文件和所有其他被require的JS文件会被自动执行一次，小程序基础库会完成所有页面的注册。4，初始化小程序首页拉取数据，从逻辑层传递到视图层，生成VD树，进行渲染。了解完小程序的启动过程后，我们经过分析定位，个阶段耗时如上图所示。其中灰色部分是小程序底层的执行耗时，这块开发者是无法操控的。那在其他耗时中，下载代码包这块占比比较高。我们能怎么去减少这块耗时呢？原先对课堂小程序的所有页面都是在一个包里面，那么这里我们采用分包方案。将主tab的3个页面以及util, 常用组件这种公共模块放在主包。其他每个页面单独分成300-500k左右大小对子包，子包可以引用主包对公共模块。经过分包处理后，下载代码包对耗时减少了500ms左右，整体启动耗时降到了3.2s。整体来说，已经比小程序大盘平均启动耗时4.5s少了1.3s。不过随着而来的，也有其他问题的引入，比如从首页打开课程详情页这一场景。这个时候点击详情页时，需要先下载完详情页分包，才能打开课程详情页，显然这样的体验是极差的。我们可以通过分包预加载的方案，来解决这个问题。打开首页，加载完主包后，可以静默加载其他分包，通过配置preloadRule即可实现分包预加载。下面是一组本地测试数据，可以看到使用分包以及分包预加载的方案，可以减少启动耗时以及提高用户体验。除了普通分包方案，小程序还有独立分包的方案。不依赖主包加载，即可打开分包页面。常用于一些比较独立的页面，比如活动页等。但使用独立分包也有一些限制：独立分包无法引用主包或其他分包的资源全局App对象只能在主包定义，独立分包不能使用App对象生命周期只能通过：wx.onAppShow, wx.onAppHide来监听解决了代码包下载的耗时以及采用分包，以及分包与加载提高页面打开性能以及效率。我们接下来看渲染耗时这块。这是一个典型但小程序双线程通信的模型。每次调用setData方法，都会将数据从逻辑层传递到native层，再到渲染层，形成VD树进行渲染。以上是setData传输数据量以及传输时间的关系图，可以看到当数据量大于64kb时，传输时间呈指数级增长。因此，在使用setData时，应该尽量遵循以下建议：不要频繁调用setData, 尽量合并到一次setData调用传输数据量跟通信性能有关，尽量少于64k，避免一些不需要在页面展示的复杂数据结构或者长字符串与界面无关的数据最好不要设置在data中去掉不必要的事件绑定，减少通信的数据量以及次数不要在节点data前缀放置过大数据（需要传输target的currentTarget和dataset）5，公共基础组件库为了提高开发效率，代码复用率，我们对常见的一些能力以及功能型组件进行了封装（后续计划开源）。这里拿基础能力的request组件来看，我们基于wx.request来封装，利用storage来存储登陆后的cookie信息，并在后续发起请求的时候，将登陆票据设置到请求头中。采用可插拔插件式封装方法，来做各种插件到扩展。例如有loading插件，一个可以在发起请求的时候，自动显示loading，请求完成后，自动隐藏的插件。以上就是小程序开发实践相关的分享。四、QQ小程序QQ小程序是一个基于手Q庞大流量，面向年轻化群体，跟随小程序行业标准的小程序平台。启动于18年12月份，并于6月底全量发布，目前覆盖微信小程序API达到了95%以上。从用户侧来看，基本跟微信小程序类似。在聊天下拉即可发现小程序入口，里面有小程序商城，可发现各类小程序以及小游戏。它的开发者工具的UI也类似微信开发者工具。它跟微信小程序之间有以下的一些区别：API以及功能方面调用前缀：例如：qq.getSystemInfoSync (也兼容wx语法) ，覆盖率95%webview: QQ小程序暂不支持webview唤起方式：支持http链接唤起小程序组件：不支持live-player, live-pusher组件分享：QQ小程序支持分享到QQ空间开发者工具方面底层框架：都是基于nw.js编译能力：不支持增强型编译不支持多核心编译其他不支持体验评分不支持自动化测试总的来说，QQ小程序的API基本对齐微信小程序，它的迭代速度较快，能力逐渐补齐中。并且拥有QQ生态流量红利，最重要的是从微信小程序迁移到QQ小程序工作量较小，代码95%以上基本可以复用。总结小程序生态发展之迅速，支付宝，百度等各大厂商都在各自研发自己的小程序。从开发者的角度来说，希望能够统一一套API规范，形成行业标准。前不久W3C中文兴趣组也在对小程序的生态进行了规范的相关讨论，相信后续必然会朝着标准化的方向发展。以上便是此次在线教育小程序开发实践之路的分享，可以通过下方的二维码关注IMWeb团队的公众号以及个人的公众号。"}
{"title": "微信小程序-麦当劳点餐+爬虫 ", "author": "Rolan", "pub_time": "2019-7-3 00:04", "content": "hello大家好，这是我的第一篇掘金文章，每天都在掘金上面看各位大佬的文章，终于鼓足勇气决定写一篇属于自己的文章了。今天呢，就给大家带来一篇微信小程序（麦当劳点餐）+爬虫的详解吧。大佬们可以忽略我这个小辣鸡，但是如果你也是前端小白的话，可以认真看看哟，说不定对你有帮助呢。项目介绍这个小程序是为最近参加的一个小活动而制作的（为期两天，3-4人组队，完成一个小型项目）。说实话，两天怎么可能完成一个小程序呢？在前两天，我们大致完成了小程序基本结构，然后由我完成收尾工作，前前后后历时四天。项目预览图大家可以看到，这个小程序有四个页面。项目工作分配由于我是组长，所以工作的内容是由我分配的，我们组内四个成员，正好一人一个页面，但是页面有简单和复杂之分的，在我的暴政下，分到了复杂页面的也不许抱怨！当然我是一个好组长，我给自己分配了选餐的页面并且爬虫爬数据也由我完成。所以下面我给大家分享的就是我完成的那个页面。项目开始前的准备一些准备工作：申请账号：进入微信公众平台根据指示申请注册账号开发工具：VScode和微信开发者工具小程序官方文档github申请存储库使用的一些工具：小程序云开发数据库功能微信官方文档markMan(可以进行图片测量和标注的工具)iconfont(阿里巴巴矢量图标库，有大量icon资源)github（由于这是我们一个小组完成的项目，所以需要建一个新的存储库，然后把大家拉进来）这里需要着重说明一下github命令行的操作，一个人开发的时候，直接git push就行。但是多人合作开发的时候，是不能直接git push的，如果别人先提交了项目，然后你再提交之前一定先要git pull，先把别人的项目拉下来，然后在git push，不然会导致冲突。其实除了这些基本的准备工作以外，我们最应该做的就是思考。有一位前辈曾经告诉我，在接手项目的时候，不应该第一时间就去敲代码，而是应该闭上眼睛思考一会。具体思考什么，他也没有细说，但是通过这次，我领悟到了前辈的意思。首先，我们需要仔细的看一下设计稿，在脑子里搭建起来大致的框架，以便在写代码的时候，可以提升效率。其次，我们应该思考数据如果存放，打个比方：在做电商页面的时候，点击左边导航栏，右边内容框显示相应的数据，这就涉及到数据的存放了。所以在写代码之前，我们就应该思考好这些逻辑。项目完成过程下图就是我要完成的页面。第一开始看见这个页面的时候，心里其实并不慌，因为之前也做过一些电商的小程序，所以知道这个页面的基本功能应该如何实现，所以在写代码的过程中，还算很顺利。点餐页面当看见这个页面的时候，脑子里大致就需要搭建一个结构框架。页面上端是一个swiper，用于滚动不同的广告。页面中间的部分是地址栏，点击可以选择不同的商店。页面中下部是一个点餐栏，左边和右边同时都要使用scroll-view。尾部是一个类似于购物车的东西，这一部分建议大家写成一个组件调用，为了减少代码耦合度。（虽然我没用组件）话不多说，下面来分析结构吧！首先我们来看一下页面的swiper部分可以从图片看出，这是一个广告位置，用于放置最新的产品，这一部分其实很简单，直接引用小程序的swiper组件即可。<swiper indicator-dots=\"true\" \r\n        indicator-active-color=\"rgba(242,207,4,1)\" \r\n        autoplay=\"true\" \r\n        circular=\"true\" \r\n        interval=\"4000\" \r\n        duration=\"1000\" \r\n        class=\"header\" \r\n        wx:if=\"{{hidden}}\">\r\n        <swiper-item wx:for=\"{{adImage}}\" wx:key=\"index\">\r\n            <image mode=\"aspectFill\" class=\"headerImg\" src=\"{{item.image}}\" />\r\n        </swiper-item>\r\n    </swiper>\r\n复制代码这一部分代码如上，需要提一下的就是swiper组件里面indicator-active-color这个属性只接受rgba形式，不接受十六进制颜色的输入，大家可以自行在百度上面找转换的方法。接下来就是地址栏的部分我这里放两张图片，方便对比：这一部分的页面并不算简单，首先外面的大盒子需要设置为弹性布局，方便左边的地址栏，还有右边的会员并排在一排。然后地址栏也需要设置为弹性布局，将flex-flow设置为column就可以沿Y轴分布，然后将align-items: center;就可以把店名还有地址放在方框中间。因为这个地址栏是可以点击切换地址的，所以内边距不可以写死，只能用弹性布局将它们放在中间，如果选择的地址过长的话，页面也会自动调整边距，十分的美观。<!-- 地址栏 -->\r\n    <view class=\"middle\" wx:if=\"{{hidden}}\">\r\n        <navigator style=\"display: inline-block\" target=\"\" url=\"../index/index\" hover-class=\"navigator-hover\">\r\n            <view class=\"address\">\r\n                <view>\r\n                    <view class=\"storeName\">{{storeInfo.name}}</view>\r\n                    <view class=\"storeAdress\">{{storeInfo.address}}</view>\r\n                </view>\r\n            </view>\r\n        </navigator>\r\n        <view class=\"member\">\r\n            <image src=\"../../images/menuImg/u=324093054,273186418&fm=26&gp=0.jpg\" class=\"menberImg\" />\r\n            <text class=\"memberText\">会员中心</text>\r\n        </view>\r\n    </view>\r\n复制代码.middle{\r\n    height: 110rpx;\r\n    width: 100%;\r\n    background-color: #fff;\r\n    display: flex;\r\n    border-bottom: 1px solid #eeeeee;\r\n}\r\n.address{\r\n    width: 600rpx;\r\n    height: 110rpx;\r\n    display: flex;\r\n    align-items: center;\r\n    border-right: 1px solid #eeeeee;\r\n}\r\n.storeName{\r\n    line-height: 40rpx;\r\n    font-size: 28rpx;\r\n    font-weight: bold;\r\n    margin-left: 40rpx;\r\n}\r\n.storeAdress{\r\n    line-height: 34rpx;\r\n    font-size: 22rpx;\r\n    color: #737373;\r\n    margin: 0 40rpx;\r\n}\r\n.member{\r\n    width: 150rpx;\r\n    height: 110rpx;\r\n    padding: 16rpx 0;\r\n    box-sizing: border-box;\r\n    display: flex;\r\n    flex-flow: column;\r\n    align-items: center;\r\n}\r\n.menberImg{\r\n    width: 40rpx;\r\n    height: 40rpx;\r\n    border-radius: 50%;\r\n    margin: 0 ;\r\n}\r\n.memberText{\r\n    position: relative;\r\n    width: 100%;\r\n    font-size: 24rpx;\r\n    line-height: 24rpx;\r\n    text-align: center;\r\n    margin-top: 14rpx;\r\n}\r\n复制代码因为这里是有一个点击事件的，点击过后，跳转到选地址页面，然后选完地址在跳转回本页面。那么在页面与页面之间是怎么传递数据的呢？在逛了一圈小程序开发文档之后，我们发现了一个api十分的好用，可以将页面的数据暂时放入缓存区，以一个key来命名，然后在另外一个页面，也用相同的key来获取，就可以获取缓存区的数据了，下面来看看代码吧。toDetail (e) {\r\n    let idx = e.currentTarget.dataset.idx;\r\n    if (idx) {\r\n      wx.setStorage({\r\n        key:\"itemsIndex\",\r\n        data: this.data.items[idx],\r\n      })\r\n    } else {\r\n      wx.setStorage({\r\n        key:\"itemsIndex\",\r\n        data: this.data.items[0]\r\n      })\r\n    }\r\n    wx.navigateTo({\r\n      url: '../menu/menu'\r\n    })\r\n  },\r\n复制代码这是通过另外一个页面跳转我的页面的点击事件，用wx.setStorage来存取数据。wx.getStorage({\r\n      key: 'itemsIndex',\r\n      success: (res) => {\r\n        let storeInfo = this.data.storeInfo;\r\n        storeInfo.name = res.data.name;\r\n        storeInfo.address = res.data.address;\r\n        // console.log(storeInfo);\r\n        this.setData({\r\n          storeInfo\r\n        })\r\n      },\r\n      fail: () => {},\r\n      complete: () => {}\r\n    });\r\n复制代码这是在本页面接收数据的方法，并且这个方法要写在onLoad生命周期函数里，这样就可以在页面加载的时候把获取到的数据渲染到页面上。然后就是本页面含金量最高的部分了这一部分，应该是所有电商小程序都会用到的。其实说难也不难，说简单也不简单，只要认真看完我下面的讲解，应该就了解要怎么做了。相信大家看到这个截图之后，内心都有一些自己的想法，那不妨继续看看我的做法，然后与你们自己的想法融合在一起，看看是不是会迸发出新的火花呢！<!-- 选餐栏 -->\r\n    <view class=\"menuContent\">\r\n        <view class=\"scrollLeft\">\r\n            <scroll-view scroll-y>\r\n                <navigator class=\"search\" url=\"../\" hover-class=\"none\">\r\n                    <image class=\"searchImage\" src=\"../../images/menuImg/sou-suo.png\" />\r\n                    <text class=\"searchText\">搜索</text>\r\n                </navigator>\r\n                <block wx:for=\"{{scrollLeft}}\" wx:key=\"index\">\r\n                    <view class=\"{{curIndex === index ? 'selected' : 'select'}}\" \r\n                    bindtap=\"onSelect\" \r\n                    data-index=\"{{index}}\" \r\n                    data-id=\"{{item.id}}\">\r\n                        <image src=\"{{item.url}}\" \r\n                        class=\"selImg\" \r\n                        wx:if=\"{{curIndex === index}}\" />\r\n                        <view class=\"{{curIndex === index ? 'selectedText' : 'selectText'}}\">\r\n                            {{item.name}}\r\n                        </view>\r\n                    </view>\r\n                </block>\r\n            </scroll-view>\r\n        </view>\r\n        <view class=\"scrollRight\">\r\n            <scroll-view scroll-y scroll-into-view=\"{{toView}}\" \r\n            scroll-with-animation=\"true\" \r\n            bindscroll=\"scrollTop\" \r\n            style=\"height: 1205rpx\">\r\n                <block wx:for=\"{{scrollRight}}\" wx:key=\"index\">\r\n                    <view class=\"food\" \r\n                    wx:for=\"{{item.detail}}\" \r\n                    wx:key=\"index\" \r\n                    wx:for-item=\"food\" \r\n                    id=\"{{item.id}}\">\r\n                        <view class=\"foodName\">{{food.name}}</view>\r\n                        <view class=\"foodPrice\">\r\n                            ￥\r\n                            <view class=\"foodPriceNum\">{{food.price}}</view>\r\n                            起*\r\n                        </view>\r\n                        <image src=\"{{food.img}}\" class=\"foodPci\" />\r\n                        <view class=\"custom\">\r\n                            <view class=\"customText\">去定制</view>\r\n                            <navigator url=\"../cart/cart\"\r\n                             hover-class=\"none\">\r\n                                <view class=\"customBtn\" \r\n                                bindtap=\"gotoCart\" \r\n                                data-id=\"{{item.id}}\" \r\n                                data-index=\"{{index}}\">\r\n                                    <image src=\"../../images/menuImg/toRight.png\" class=\"customPic\" />\r\n                                </view>\r\n                            </navigator>\r\n                        </view>\r\n                        <view class=\"order\">\r\n                            <view class=\"orderText\">大套餐</view>\r\n                            <view class=\"orderselect\" wx:if=\"{{food.showCombo}}\">\r\n                                <view class=\"reduce\" bindtap=\"OnReduce\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n                                    <image src=\"../../images/menuImg/jianhao.png\" class=\"orderPic\" />\r\n                                </view>\r\n                                <text class=\"orderTitle\">{{food.title}}</text>\r\n                                <view class=\"add\" bindtap=\"OnAdd\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n                                    <image src=\"../../images/menuImg/jiahao.png\" class=\"orderPic\" />\r\n                                </view>\r\n                            </view>\r\n                            <view class=\"orderBtn\" wx:else bindtap=\"OnAdd\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n                                <image src=\"../../images/menuImg/jiahao.png\" class=\"orderPic\" />\r\n                            </view>\r\n                        </view>\r\n                    </view>\r\n                </block>\r\n            </scroll-view>\r\n        </view>\r\n    </view>\r\n复制代码从页面结构可以看出，这一部分分为左边和右边两部分，然后都通过wx:for循环，将数据循环渲染在页面上，左边和右边也都使用了scroll滚动条，这里有一个坑不知道大家是否踩过，就是使用小程序scroll-view组件时，必须要给这个组件设置固定的高度或者宽度（这采决与你是设置了Y方向滚动还是X方向滚动），如果不设置高度的话，滚动条就会失效，虽然这个坑我已经踩过很多次了，但是每当我遇到时，都还会在踩一遍。这里由于css太多了，所以就不放上来了展示给大家看了，如果有想看朋友可以去文章最下面的github地址观看。在css里也有一个坑，那就是在选择布局的时候有两种方法，第一种是使用弹性布局，将左边导航栏和右边选餐栏并排一起。第二种是使用display: inline-block;方法，使得左边导航栏和右边选餐栏都变成行内块元素，并排在一起，虽然布局上面没问题，但是当循环数据时，你就会发现右边的数据会倒叙排列，我也没有找到会导致这种方法的原因。所以遇到左右两边需要并排且需要填充数据的时候，推荐使用弹性布局。接下来就是最最最最难的逻辑部分了，我会给大家分左边和右边来讲解。虽然百度上面也有很多左右联动的逻辑方法，但是百度到的答案不尽人意，所以我就取其精华去其糟粕，写了一下自己的逻辑，接下来我就要给大家细致的讲一下左右联动的效果实现。我们先来看看点击左边导航栏，然后点击的导航栏变换样式是怎样实现的。onSelect(e) {\r\n    console.log(e);\r\n    const that = this;\r\n    const curIndex = e.currentTarget.dataset.index;\r\n    const toView = e.currentTarget.dataset.id;\r\n    console.log(toView)\r\n    that.setData({\r\n      curIndex,\r\n      toView\r\n    })\r\n  },\r\n复制代码这里通过点击事件，获取到该数据的index并赋值给curIndex，然后通过判断class=\"{{curIndex === index ? 'selected' : 'select'}}\"改变样式。同时点击事件时，也将数据里的id值赋给toView，然后在右边的滚动条里，设置scroll-into-view=\"{{toView}}\"，通过这个属性，滚动条就可以自动跳转到对应的toView数据里。这是小程序自定义的方法，可以很方便的做到点击左边，右边自动跳转的操作。但是滚动右边，左边样式也自动切换就不是那么容易的事情了。.then(res => {\r\n          let heightArr = [];\r\n          const height = 180;\r\n          let heightList = 0\r\n          for(let i = 0; i < res.length; i++) {\r\n            heightList += res[i].detail.length * height;\r\n            heightArr.push(heightList);\r\n          }\r\n          // console.log(heightArr);\r\n          this.setData({\r\n            heightArr\r\n          })\r\n        }) \r\n复制代码在这里，我是在onLoad生命周期函数里，先请求数据，通过.than接收到数据，const height = 180;这是我设置的每一个食物框的固定高度，所以通过这个高度乘以分类里面的每个数据，就可以获得右边滚动条不同分类的高度区间，然后存入heightArr数组。scrollTop(e) {\r\n    // console.log(e)\r\n    const scrollTop = e.detail.scrollTop;\r\n    if(scrollTop > 100) {\r\n      this.setData({\r\n        hidden: false\r\n      })\r\n    }\r\n    else{\r\n      this.setData({\r\n        hidden: true\r\n      })\r\n    }\r\n    const heightArr = this.data.heightArr;\r\n    for(let i = 0; i < heightArr.length; i++) {\r\n      if(scrollTop > 0 && scrollTop < heightArr[0]) {\r\n        this.setData({\r\n          curIndex: 0\r\n        })\r\n      } else if (scrollTop < heightArr[i] && scrollTop > heightArr[i - 1]) {\r\n        this.setData({\r\n          curIndex: i\r\n        })\r\n      }\r\n    }\r\n  },\r\n复制代码右边高度的区间我们已经得到了，然后我们应该怎么利用好它呢？在scroll-view组件里，有一个bindscroll=\"scrollTop\"方法是滚动滚动条时可以触发的事件，这个方法可以获取到滚动的顶部在滚动时距离顶部的距离。那么我们就可以利用这个滚动的距离，然后获取到这个距离在heightArr区间的哪一部分，然后将这个区间的索引值赋值给curIndex。 这样左边的样式就能随右边滚动而改变了。这个方法大家学会了嘛，如果没有看懂，可以在下面评论区问我哟！OnAdd(e) {\r\n    const id = e.currentTarget.dataset.id;\r\n    const indexSelect = e.currentTarget.dataset.index;\r\n    let totalPrice = this.data.totalPrice;\r\n    let index = id.split('l')[1];\r\n    let scrollRight = this.data.scrollRight;\r\n    const price = scrollRight[index].detail[indexSelect].price;\r\n    scrollRight[index].detail[indexSelect].title++;\r\n    scrollRight[index].detail[indexSelect].showCombo = true;\r\n    totalPrice = totalPrice + price;\r\n    this.setData({\r\n      scrollRight,\r\n      totalPrice\r\n    })\r\n  },\r\n  OnReduce(e) {\r\n    const id = e.currentTarget.dataset.id;\r\n    const indexSelect = e.currentTarget.dataset.index;\r\n    let index = id.split('l')[1];\r\n    let scrollRight = this.data.scrollRight;\r\n    let title = scrollRight[index].detail[indexSelect].title;\r\n    let totalPrice = this.data.totalPrice;\r\n    const price = parseFloat(scrollRight[index].detail[indexSelect].price);\r\n    totalPrice = totalPrice - price;\r\n    if(title > 1) {\r\n      scrollRight[index].detail[indexSelect].title--;\r\n      this.setData({\r\n        scrollRight,\r\n        totalPrice\r\n      })\r\n    }else if(title = 1) {\r\n      scrollRight[index].detail[indexSelect].title--;\r\n      scrollRight[index].detail[indexSelect].showCombo = false;\r\n      this.setData({\r\n        scrollRight,\r\n        totalPrice,\r\n      })\r\n    }\r\n  },\r\n复制代码上面是一些简单的加和减的方法，点击+号的时候，触发onAdd事件，获取到当前点击事件的索引值，然后找到数据里面每一项的价格，以及数量，除了将数量+1之外，还需要算出当前所有物品的总价。点击-号的方法一样，我就不再赘述了。最后就是页面下端的购物车部分了当选餐时，就会自动跳出购物车按钮，然后点击购物车，就会显示出购物清单列表，在购物清单列表中，也可以增加或者减少食物。<view class=\"shoppingList\" wx:if=\"{{showList && totalPrice != 0}}\">\r\n        <view class=\"shadow\" bindtap=\"onList\"></view>\r\n        <view class=\"shoppingBottom\">\r\n            <view class=\"shoppingHeader\">\r\n                <view class=\"hasSelected\">\r\n                    <image src=\"../../images/menuImg/shoppingGray.png\" class=\"image\" />\r\n                    <view class=\"text\">已选产品</view>\r\n                </view>\r\n                <view class=\"empty\" bindtap=\"onEmpty\">\r\n                    <image src=\"../../images/menuImg/lajitong.png\" class=\"image\" />\r\n                    <view class=\"text\">清空</view>\r\n                </view>\r\n            </view>\r\n            <scroll-view scroll-y \r\n                style=\"max-height: 534rpx\">\r\n                <block wx:for=\"{{scrollRight}}\" wx:key=\"index\">\r\n                    <view class=\"shoppingBody\" wx:for=\"{{item.detail}}\" wx:for-item=\"food\" wx:if=\"{{food.showCombo}}\" wx:key=\"index\">\r\n                        <view class=\"name\">{{food.name}}</view>\r\n                        <view class=\"unitPrice\">\r\n                            ￥\r\n                            <view class=\"unitPriceNum\">{{food.price * food.title}}</view>\r\n                        </view>\r\n                        <view class=\"orderselect addPlace\">\r\n                            <view class=\"reduce\" bindtap=\"OnReduce\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n                                <image src=\"../../images/menuImg/jianhao.png\" class=\"orderPic\" />\r\n                            </view>\r\n                            <text class=\"orderTitle\">{{food.title}}</text>\r\n                            <view class=\"add\" bindtap=\"OnAdd\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n                                <image src=\"../../images/menuImg/jiahao.png\" class=\"orderPic\" />\r\n                            </view>\r\n                        </view>\r\n                    </view>\r\n                </block>\r\n            </scroll-view>\r\n        </view>\r\n    </view>\r\n    <!-- 选好了 -->\r\n    <view class=\"shopping\" wx:if=\"{{totalPrice != 0}}\">\r\n        <view class=\"shoppingLeft\">\r\n            <view class=\"shoppingCar\" bindtap=\"onList\">\r\n                <image src=\"../../images/menuImg/shopping.png\" class=\"shoppingImg\" />\r\n            </view>\r\n            <view class=\"shoppingPrice\">\r\n                <view class=\"priceTitle\">￥</view>\r\n                <view class=\"priceNum\">{{totalPrice}}</view>\r\n            </view>\r\n        </view>\r\n        <navigator url=\"../settlement/settlement\" class=\"shoppingRight\" bindtap=\"gotoSettlement\" >\r\n            <view class=\"rightText\">选好了</view>\r\n            <image src=\"../../images/menuImg/yellowRight.png\" class=\"rightImg\" />\r\n        </navigator>\r\n    </view>\r\n复制代码这是购物清单还有购物车的部分，使用position: fixed;将这部分固定在屏幕的底部，不会随着屏幕滑动而滑动，在结构上面，还设置了一个蒙层，当展示购物清单时显示。// 是否显示选餐列表\r\n  onList() {\r\n    let showList = this.data.showList;\r\n    showList = !showList;\r\n    this.setData({\r\n      showList\r\n    })\r\n  },\r\n  // 清空事件\r\n  onEmpty() {\r\n    const scrollRight = this.data.scrollRight;\r\n    for(let i = 0; i < scrollRight.length; i++) {\r\n      for(let j = 0; j < scrollRight[i].detail.length; j++) {\r\n        scrollRight[i].detail[j].title = 0;\r\n        scrollRight[i].detail[j].showCombo = false;\r\n      }\r\n    }\r\n    this.setData({\r\n      scrollRight,\r\n      totalPrice: 0,\r\n      showList: false\r\n    })\r\n  },\r\n  // 跳转到cart页面\r\n  gotoCart(e) {\r\n    // console.log(e)\r\n    const id = e.currentTarget.dataset.id;\r\n    const indexSelect = e.currentTarget.dataset.index;\r\n    let index = id.split('l')[1];\r\n    let scrollRight = this.data.scrollRight;\r\n    const zhushi = scrollRight[index].detail[indexSelect];\r\n    console.log(zhushi);\r\n    wx.setStorage({\r\n      key: \"cartFood\",\r\n      data: zhushi\r\n    })\r\n  },\r\n复制代码这些方法都是基本方法，还是很简单的，大家看一下应该就知道做什么的了，也不再一一介绍了。啊啊啊啊啊啊啊啊啊啊，好累，码了这么多字，感觉写文章比写小程序还累！但是我不能停下来，因为还有重点没有讲！接下来就是这篇文章的重点部分了，小伙伴们快竖起耳朵听啊！爬虫爬取数据相信大家在写小项目的时候，最头疼的就是写假数据了，每次编写假数据，自己看的都头皮发麻。所以我给大家带来一个简单的爬虫，不仅可以轻轻松松的获取到数据，而且显得既高端又专业！我把爬虫写在了云函数里，这样可以直接在运行云函数的时候，就把爬虫爬取到的数据直接存储到云数据库。在写爬虫之前，首先需要将运行环境初始化成node运行环境，然后下载基本的依赖，以便后面可以在网页上获取数据。因为我这里要获取到的数据在不同的页面里，所以我先将网页全部定义好，方便直接引用。同时我也创建了不同的空数组，为了将从不同网页中获取到的不同数据存入不同的数组里。这些准备工作都做完了，下面来看看代码吧。const cloud = require('wx-server-sdk');\r\nconst request = require('request');\r\nconst cheerio = require('cheerio');\r\nconst breakfast = 'http://www.5ikfc.com/mdl/menu/breakfast/';  //早餐\r\nconst chaozhitaocan = 'http://www.5ikfc.com/mdl/menu/chaozhitaocan/';  //超值套餐\r\nconst happymeals = 'http://www.5ikfc.com/mdl/menu/happymeals/';  //快乐套餐\r\nconst sides = 'http://www.5ikfc.com/mdl/menu/sides/';  //配餐\r\nconst drink = 'http://www.5ikfc.com/mdl/menu/drink/';  //饮料\r\nconst dessert = 'http://www.5ikfc.com/mdl/menu/dessert/';  //甜品\r\nconst mccafe = 'http://www.5ikfc.com/mdl/menu/mccafe/';  //麦咖啡\r\nlet breakfastList = [];\r\nlet chaozhitaocanList = [];\r\nlet happymealsList = [];\r\nlet sidestList = [];\r\nlet drinkList = [];\r\nlet dessertList = [];\r\nlet mccafeList = [];\r\n\r\n// 初始化 cloud\r\ncloud.init()\r\n\r\nconst db = cloud.database();\r\n\r\nfunction maidanglaoSpider(http, list) {\r\n    return new Promise((resolve, reject) => {\r\n        request(http,\r\n        (err, res) => {\r\n            if(err) {\r\n                reject('net error');\r\n            }\r\n            if(!err) {\r\n                const body = res.body;\r\n                const $ = cheerio.load(body, {\r\n                decodeEntities: false\r\n                })\r\n                $('.lside.fr.bdgrey.main_wrap .fx li')\r\n                .each(function() {\r\n                    const img = $('a img', this).attr('src');\r\n                    const name = $('a', this).text().trim();\r\n                    const price = $('b', this).text().trim();\r\n                    list.push({\r\n                        name,\r\n                        img,\r\n                        price\r\n                    })\r\n                    console.log({\r\n                        name,\r\n                        img,\r\n                        price\r\n                    })\r\n                })\r\n                resolve(list);\r\n            }\r\n        })\r\n    })\r\n}\r\nmaidanglaoSpider(breakfast,breakfastList)\r\n.then(res => {\r\n    console.log(res);\r\n})\r\n复制代码首先往爬虫函数里传http和list两个参数，因为我需要将不同网页的数据存入不同的list里面。然后函数return一个Promise函数，然后在promise函数里发起请求，如果请求没有报错的话，就const body = res.body获取网页的html的body结构，然后通过 ('a img', this).attr('src');获取我们需要的图片的src；通过const name = ('b', this).text().trim();获取到需要的价格。最后将这三个数据以对象的形式push进数组，然后resolve出来。到这里我们的爬虫函数就写好啦，然后下面就需要把数据传入云数据库了。exports.main = async (event, context) => {\r\n        const breakfastData = await maidanglaoSpider(breakfast, breakfastList);\r\n        const chaozhitaocanData = await maidanglaoSpider(chaozhitaocan, chaozhitaocanList);\r\n        const happymealsData = await maidanglaoSpider(happymeals, happymealsList);\r\n        const sidesData = await maidanglaoSpider(sides, sidestList);\r\n        const drinkData = await maidanglaoSpider(drink, drinkList);\r\n        const dessertData = await maidanglaoSpider(dessert, dessertList);\r\n        const mccafeData = await maidanglaoSpider(mccafe, mccafeList);\r\n        let arrData = [breakfastData,chaozhitaocanData,happymealsData,sidesData,drinkData,dessertData,mccafeData]\r\n        \r\n        for(let i = 0; i < arrData.length; i++) {\r\n            await db.collection('food').add({\r\n                data: {\r\n                    id: i,\r\n                    detail: arrData[i]\r\n                }\r\n            })\r\n        }\r\n}\r\n复制代码我首先将不同的数据命名好，然后将他们放进arrData数组里，然后通过遍历这个数组，把每一项数据都存入云函数里。云数据库内容如下当我同一个小组的大佬看到我的云数据库以后，对我进行了夸赞：“您真是将数据库运用到了极致。”当然了，这并不是夸赞，而是无情的嘲讽。我在存数据的时候，将所有数据存在了一个集合中，并且在集合中将数据划分开来（这是极度错误的做法，希望大家不要效仿我），由于这是我第一次使用云数据库存数据，所以犯这种错误也能体谅。正确做法是：将每一个种类的数据，存放在一个集合中，不要吝啬数据库的使用。获取数据上面我们已经把爬虫的数据存进云函数了，然后就到了获取数据的时候了。wx.cloud.callFunction({\r\n      name: 'foodData',\r\n      success: (res) => {\r\n        // console.log(res);\r\n        db.collection('breakfast')\r\n        .get()\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[0].id}`\r\n          food.detail = res.data[0].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[1].id}`\r\n          food.detail = res.data[1].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[2].id}`\r\n          food.detail = res.data[2].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[3].id}`\r\n          food.detail = res.data[3].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[4].id}`\r\n          food.detail = res.data[4].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[5].id}`\r\n          food.detail = res.data[5].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n        .then(res => {\r\n          let food = {};\r\n          food.id =  `l${res.data[6].id}`\r\n          food.detail = res.data[6].detail.slice(0,5);\r\n          food.title = 0;\r\n          let scrollRight = this.data.scrollRight;\r\n          scrollRight.push(food);\r\n          console.log(food);\r\n          this.setData({\r\n            scrollRight\r\n          })\r\n          return res\r\n        })\r\n复制代码本来我想的是利用循环，把数据遍历出来，然后通过循环存进定义的空数组里。但是我怎么也存不进去，实在找不到原因，我就把数据的每一项都单独拎出来然后存进去。虽然代码很不美观，但是总算把数据存进去了。这个函数要写在onLoad生命周期函数里，这样可以在页面加载的时候就把数据获取到，然后渲染到页面上。至此，我的个人页面就完成了，小伙伴们也将他们的页面提交到了github上面，本以为工作就结束了，可以高高兴兴的玩耍了。但是转头一想，页面跳转的工作还没人做呢，哎，谁让我是小组长呢，只能由我这个“老父亲”来做收尾工作了。收尾工作其实收尾工作很简单，就是改一下路由跳转，并且传送一下对应的数据就行。传送和接收数据代码如下：wx.setStorage({\r\n        key:\"itemsIndex\",\r\n        data: this.data.items[idx],\r\n    })\r\nwx.getStorage({\r\n      key: 'itemsIndex',\r\n      success: (res) => {\r\n        let storeInfo = this.data.storeInfo;\r\n        storeInfo.name = res.data.name;\r\n        storeInfo.address = res.data.address;\r\n        // console.log(storeInfo);\r\n        this.setData({\r\n          storeInfo\r\n        })\r\n      },\r\n      fail: () => {},\r\n      complete: () => {}\r\n    });\r\n复制代码在跳转页面时，利用wx.setStorage将数据放入缓存区，然后在需要数据的页面，利用wx.getStorage获取缓存区的数据。好啦，工作算是结束了，给大家来看看我们的最终成果把！嘿嘿，总体来说，还算过得去吧一些总结小程序写完了，总得有一些工作总结对吧，我觉得通过这次几个小伙伴通力合作，我感慨还是蛮多的，给大家总结一下几点吧！第一！最重要的就是！心平气和。几个小伙伴合作写项目，难免在一些观点上面有分歧，但是大家一定要心平气和的商讨，不能各执己见。虽然我们团队在写项目的时候也有几句争吵，但是总体来说还算平和。第二！一定要注意代码的质量，以前一直是一个人写代码，没有体会到代码质量的重要性，但是通过这次合作，我发现代码一定要写的简单易懂，也要多写注释，这样方便别人修改你的代码，同时也方便自己阅读。第三！一定要坚持，有些事情看似很难，但是只要坚持下来，你会发现那些困难，再一点点土崩瓦解，到最后会被你完全击溃。第四！不懂就问，不管是老师，同学，还是百度，不懂就要去问，不能把问题放在那里不解决，只要多问多思考，就会一点点有思路了。以上几点就是这次小项目完成的总结啦，同时也是这篇文章的收尾了，这篇文章是我第一次写文章，所以我知道可能很差，所以大家有什么建议的话，一定要给我留言，方便我改进，同时如果大家对这个项目有什么不懂的，也可以在留言区问，我会细心解答的！这是这个项目的github地址： github.com/Yeqing98/Ma… （有需要的小伙伴可以拿去参考一下噢！）"}
{"title": "开发 地图标记工具 后记 ", "author": "Rolan", "pub_time": "2019-7-3 00:12", "content": "每个云函数都是独立的一个 Node.js 项目，单独部署每个云函数都要自己初始化 cloud ，获取 db 等操作不同云开发环境之间没有隔离，甚至默认会相互调用，如可能会发生 release 环境会默认调用 test 环境的数据库、存储等前端中初始化时传入的环境 id ，只是设置前端直接调用数据库、存储时使用的环境 id ，并不能设置云函数调用的数据库、存储。为了云函数正确调用相应环境的数据库、存储，应在每个云函数中作明确指定调用的环境id。这里推荐\tnate 的做法以保持环境一致性：\thttps://developers.weixin.qq.com/community/develop/doc/000e688bc58fe0bab777b05665b800本地调试时需要自己手工为每个云函数安装依赖函数修改后没有修改标记，不能知道哪个函数没有更新到远程函数修改后需要一个一个手动上传，且上传较慢甚至上传失败云开发控制台不稳定，经常报错，会有莫名的问题，如看不到函数日志等(也可能由于用的是 Nightly 版的缘故)所以，个人觉得，云开发尚不成熟，个人较小的项目使用云开发还可以，稍微大一点点的或公司项目，强烈不推荐使用云开发。小程序开发官方的小程序开发方式中，wxml 中并不能使用 js 中的方法，与vue中的 filter 相似的功能需要借助 wxs ，wxs 像 js 但并不完全是 js 。组件是组件，页面是页面，且结构不一样。每次更新数据都要手动调用 setData() 方法以更新视图。map组件，层级非常高，要在上部显示组件，需要使用特定组件，这些组件的样式设置也会有一些不同，受到更多的限制。例如，需要显示一个 icon 形式的 button ，只能借助 cover-image 组件。三个小程序码接口，若需要获取极多的码，需要用 getUnlimitted 接口，且该接口不能为未发布的页面生成码，所以只有发布了带有目标页面的小程序后才能预览最终显示效果。该接口限制参数长度32个字符，云开发中的 _id 字符就32个字符可直接传入，若需更多参数，需要自行处理，传入的scene字符串会被 encode 后作为 options.scene 参数传入页面，获取时需要自行 decode 还原成传入的 scene 字符串。"}
{"title": "马蜂窝旅游小程序 ", "author": "Rolan", "pub_time": "2019-7-3 00:13", "content": "前段时间学习了关于微信小程序的开发，光说不练假把式，所以就打算自己手撸一个微信小程序，而网上电商类小程序太多了，所以就选择了旅游攻略类小程序来练手。这是我第一次写小程序和第一次写文章，不足之处请多包涵，谢谢。下面我会分享我在写小程序的时候遇到的问题和获得的经验，希望能给你带来帮助，也欢迎大佬指正。最后，我要感谢我在写小程序的时候给我帮助的老师和同学，还有百度上所有给过我帮助的有名的无名的作者。我的废话说完了，先上项目效果图。开发前的准备微信开发者工具VsCodeEasy Mock项目的所有页面自定义顶部导航栏组件微信小程序自带的顶部导航栏 满足不了实际的需求所以就自己写了一个组件，顶部导航栏要想使用 自定义组件（链接中详细介绍了关于自定义组件的使用方法）必须把app.json中window属性设置为：\"window\": {\r\n    \"navigationBarTextStyle\": \"black\",//导航栏标题颜色，仅支持 black / white\r\n    \"navigationStyle\": \"custom\" //导航栏样式，仅支持以下值：default 默认样式custom 自定义导航栏，只保留右上角胶囊按钮\r\n  }\r\n复制代码wxml<view class='nav-wrap' style='height: {{height*2 + 20}}px; background-color:{{navbarData.backgroundColor}};opacity:{{navbarData.opacity}}'>\r\n  <view style=\"width:100%;height:100%;\">\r\n    <!--城市名-->\r\n    <navigator url=\"/pages/destination/destination\" hover-class=\"none\">\r\n      <view class=\"nav-city\" style='margin-top:{{height*2 + 20-36}}px;' wx:if='{{navbarData.showMain}}'>\r\n        <text>{{navbarData.cityName}}</text>\r\n        <view class=\"downtips\"></view>\r\n      </view>\r\n    </navigator>\r\n    <navigator url=\"/pages/search/search\" hover-class=\"none\">\r\n    <!--搜索框-->\r\n    <view class=\"section\" style='top:{{height*2 + 20-34}}px;' wx:if='{{navbarData.showMain}}'>\r\n      // 这里的搜索框不是一个input组件，只是一个view可供点击然后跳到搜索页\r\n      <view class='search_icon'>\r\n        <icon type='search' size='14px'></icon>\r\n      </view>\r\n      <view class='placehold'>搜索目的地/景点/攻略</view>\r\n    </view>\r\n    </navigator>\r\n  </view>\r\n  <!-- 标题 -->\r\n  <view wx:if=\"{{navbarData.title!=''}}\" class='nav-title' style='line-height: {{height*2 + 44}}px;'>\r\n    {{navbarData.title}}\r\n  </view>\r\n  <!-- 返回上一级按钮 和 返回主页按钮-->\r\n  <block wx:if=\"{{navbarData.showCapsule===1}}\">\r\n    <view class='nav'>\r\n      <view class='nav_back' bindtap=\"_navback\">\r\n        <image src='/images/back.png'></image>\r\n      </view>\r\n      <view class=\"line\"></view>\r\n        <view class='nav_home' bindtap=\"_backhome\">\r\n          <image src='/images/home.png'></image>\r\n        </view>\r\n    </view>\r\n  </block>\r\n</view>\r\n复制代码组件中的元素都可以通过当前页面传入组件的数据控制显示与否js就写了两个路由跳转 函数，微信小程序官方文档有很详细的介绍，这里就不多赘述了。登录界面初进小程序，会跳到登录授权页面，因为微信小程序不再支持 wx.getUserInfo接口直接弹出授权框的开发方式，所以这里直接使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。<button style='background:green; color:#fff' open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">同意授权</button\r\n复制代码小程序在授权允许访问用户信息后，又会弹出位置授权框用来获取用户当前所在地，来渲染主页面的数据。调用小程序给的接口wx.getLocation(需要用户授权) 来获取经纬度，再把获取到的经纬度利用百度地图开放平台 提供给小程序使用的API来获取当前城市的名字，并将城市名字放入缓存，好让主页面获取到。##注意： 使用wx.getLocation()需要在app.json中配置\"permission\": {\r\n    \"scope.userLocation\": {\r\n      \"desc\": \"小程序将获取你的位置信息\"\r\n    }\r\n  }\r\n复制代码登录界面js// miniprogram/pages/login/login.js\r\nconst app = getApp()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    show: false,\r\n    // 顶部导航栏数据\r\n    navbarData: {\r\n      showCapsule: 0, //是否显示左上角图标   1表示显示    0表示不显示\r\n      title: '马蜂窝旅游', //导航栏 中间的标题\r\n      backgroundColor: '#354a98', //'#354a98'\r\n      opacity: 1,\r\n      showMain: 0,\r\n    },\r\n    // 此页面 页面内容距最顶部的距离\r\n    height: app.globalData.height * 2 + 20,\r\n  },\r\n  bindGetUserInfo(res) {\r\n    let that =this\r\n    let info = res;\r\n    if (info.detail.userInfo) {\r\n      wx.login({\r\n        success: function (res) {\r\n          that.getPlaceData()\r\n        }\r\n      })\r\n    }\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    let that = this;\r\n    //页面加载时判断用户是否授权过，如果授权过直接跳到主页面，没有就显示授权按钮\r\n    wx.getUserInfo({\r\n      success: function (res) {\r\n        wx.switchTab({\r\n          url: '/pages/main/index'\r\n        })\r\n      },\r\n      fail(err) {\r\n        that.setData({\r\n          show: true\r\n        })\r\n      }\r\n    })\r\n  },\r\n  // 获取城市名字\r\n  getCityName(location) {\r\n    return new Promise((resolve, reject) => {\r\n      let that = this;\r\n      var e = {\r\n        coord_type: \"gcj02\",\r\n        output: \"json\",\r\n        pois: 0,\r\n        ak: '',//放上自己的ak密钥 密钥申请见上文百度地图开方平台链接\r\n        sn: \"\",\r\n        timestamp: \"\"\r\n      };\r\n      e.location = location;\r\n      wx.request({\r\n        url: \"https://api.map.baidu.com/geocoder/v2/\",\r\n        data: e,\r\n        header: {\r\n          \"content-type\": \"application/json\"\r\n        },\r\n        method: \"GET\",\r\n        success: function (t) {\r\n          let currentCity = t.data.result.addressComponent.city;\r\n          if (currentCity.slice(currentCity.length - 1) == \"市\") {\r\n            currentCity = currentCity.slice(0, currentCity.length - 1)\r\n          }\r\n          wx.setStorageSync('currentCity', currentCity)\r\n          resolve(currentCity) //通过城市名字 请求城市数据\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // 获取经纬度\r\n  getLocation() {\r\n    return new Promise((resolve, reject) => {\r\n      wx.getLocation({\r\n        type: 'wgs84',\r\n        success(res) {\r\n          const latitude = res.latitude\r\n          const longitude = res.longitude\r\n          let location = latitude + ',' + longitude\r\n          console.log(location)\r\n          resolve(location) //获取城市名字\r\n        }\r\n      })\r\n    })\r\n  },\r\n  getPlaceData() { // 获取地理信息\r\n    let that = this\r\n    this.getLocation().then((val) => {\r\n      return that.getCityName(val)\r\n    }).then(()=>{\r\n      wx.switchTab({\r\n        url: '/pages/main/index'\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码主页面写小程序的时候我不知道主页面有两种样式，等我知道的时候已经写了不少东西了，所以就没有写成组件了，代码看起来就很冗长，这是我的失误（MangFu），希望你在想好写什么小程序的时候，一定要把小程序的页面结构想好来否则就会和我一样，要改的话就要改很多地方。普通城市页面热门城市页面进入主页是，页面会先获取到缓存中的城市名字，再通过城市名字去请求数据，再根据请求到的数据中的ishot属性，如果ishot属性为真，就显示热门城市的页面 ，反之就显示普通城市的页面‘我的’页面‘我的’页面中主要是为了显示用户收藏的内容景点详情页因为种种原因（lan）页面中的大半数据没有放到Easy Mock里，马蜂窝本来就以大数据出名，数据ttm多了。洲/国家/城市列表页这个页面的布局分为三部分，头部搜索框用绝对定位定死、左部各大洲的列表用绝对定位定死，右部各大洲的国家是一个微信小程序自带的组件scroll-viewwxml<!-- pages/destination/destination.wxml -->\r\n<nav-bar navbar-data='{{navbarData}}'></nav-bar>\r\n<view class=\"destination\" style='top: {{height}}px'>\r\n<!--头部-->\r\n  <view class=\"des_head\">\r\n  <navigator url=\"/pages/search/search\" hover-class=\"none\">\r\n    <view class=\"des_search\">\r\n      <view class=\"des_search_icon\">\r\n        <icon type='search' size='30rpx' color=\"#000000\"></icon>\r\n      </view>\r\n      搜索目的地\r\n    </view>\r\n  </navigator>\r\n  </view>\r\n  <!--左部-->\r\n  <view class=\"des_continents\">\r\n    <view class=\"des_continent {{curIndex===index?'add':''}}}\" wx:for=\"{{continents}}\" wx:for-item=\"continent\" wx:key='{{index}}' data-index='{{index}}' bindtap=\"switch_des\">\r\n      <view class='des_continent_name {{curIndex===index?\"on\":\"\"}}}'>{{continent.name}}</view>\r\n    </view>\r\n  </view>\r\n  <!--右部-->\r\n  <scroll-view class='des_cities' scroll-y>\r\n    <block wx:if=\"{{curIndex==0}}\">\r\n      <view class=\"des_cities_content\" wx:for=\"{{continents[curIndex].cities}}\" wx:key=\"{{index}}\" wx:for-item=\"des_city\">\r\n        <view class=\"des_cities_title\">{{des_city.title}}</view>\r\n        <view class=\"des_city\" wx:for=\"{{des_city.city}}\" wx:key=\"{{index}}\" bindtap='goMain' data-city_name=\"{{item.city_name}}\">\r\n          {{item.city_name}}\r\n        </view>\r\n      </view>\r\n    </block>\r\n    <block wx:else>\r\n      <view class=\"des_area\" wx:for=\"{{continents[curIndex].cities}}\" wx:key=\"{{index}}\" wx:for-item=\"des_city\" bindtap='goMain' data-city_name=\"{{des_city.city_name}}\">\r\n          <view class=\"des_img\">\r\n            <image src=\"{{des_city.img}}\" />\r\n          </view>\r\n          <view class=\"des_city_name\">{{des_city.city_name}}</view>\r\n        </view>\r\n    </block>\r\n  </scroll-view>\r\n</view>\r\n\r\n复制代码js// pages/destination/destination.js\r\nconst app = getApp()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n  <!--顶部导航栏数据-->\r\n    navbarData: {\r\n      showCapsule: 1, //是否显示左上角图标   1表示显示    0表示不显示\r\n      title: '目的地切换', //导航栏 中间的标题\r\n      backgroundColor: '#fff',//背景颜色\r\n      showMain: 0 ///显示搜索框\r\n    },\r\n    height: app.globalData.height * 2 + 20,\r\n    continents: [],\r\n    curIndex: 0 //当前洲的索引值\r\n  },\r\n  <!--左部各大洲的点击事件，来改变右边显示的内容，并且改变自身样式-->\r\n  switch_des(e) {\r\n    let curIndex = e.currentTarget.dataset.index;\r\n    this.setData({\r\n      curIndex,\r\n    })\r\n  },\r\n  <!--右部国家/城市的点击事件，获取点击的元素上绑定的国家/城市的名字，放入缓存，并跳转到主页-->\r\n  goMain(e){\r\n    const city_name = e.currentTarget.dataset.city_name;\r\n    wx.setStorageSync('currentCity', city_name)\r\n    wx.switchTab({\r\n      url: '/pages/main/index'\r\n    })\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    let that = this\r\n    <!--请求数据-->\r\n    wx.request({\r\n      url: 'https://www.easy-mock.com/mock/5ca457f04767c3737055c868/example/mafengwo/continents',\r\n      success:(res)=>{\r\n        that.setData({\r\n          continents: res.data.continents\r\n        })\r\n      }\r\n    })\r\n  }\r\n}\r\n复制代码搜索页实现的功能点击切换列表以主页为例其实所有的切换列表功能都差不多，实现方法就是在被点击元素上设置一个自定义属性 ( data-* ) 为唯一索引值，用bind-tap 绑定一个点击事件，通过点击事件获取这个唯一索引值，再通过唯一索引值去数据源找到想要的内容，然后通过数据控制页面上显示的内容,在data数据源中设置一个数据如mcurIndex,表示当前选择的元素，用来区别于其他元素，显示不同的样式。wxml<view class='menu_list'>\r\n    <!-- {{mcurIndex===index?\"on\":\"\"}} 表示如果自身的索引值为当前选择的元素索引值时，添加一个类名‘on’-->\r\n    <view class='list {{mcurIndex===index?\"on\":\"\"}}' wx:for=\"{{placeData.allGuide}}\" data-mindex=\"{{index}}\" bindtap='selected_menu' wx:key=\"{{index}}\">\r\n        {{item.name}}\r\n    </view>\r\n</view>\r\n复制代码jsselected_menu(e) {\r\n    this.setData({\r\n      mcurIndex: e.target.dataset.mindex,\r\n      size: 0,\r\n      showend: false\r\n    })\r\n    <!--调用自己写的函数来获取要显示的内容的数据-->\r\n    this.bitiyan()\r\n  }\r\n复制代码滑动页面改变顶部导航栏的可见度和上拉加载滑动页面改变顶部导航栏的可见度以主页为例这里的实现方法是使用 scroll-view组件，组件中有个 bindscroll 属性，会在页面滚动时触发bindscroll 绑定的事件还会给函数传递一个对象event,其中的scrollTop属性是我们需要的，根据scrollTop知道页面滚动了多少，然后动态设置要传给组件的数据里的 opacity 属性。<scroll-view class=\"main_scro\" scroll-y bindscroll=\"scroll\" bindscrolltolower=\"bindDownLoad\">\r\n</scroll-view>\r\n复制代码jsscroll(e) {\r\n    let opacity = 0;\r\n    if (e.detail.scrollTop < 60) {\r\n      opacity = (e.detail.scrollTop / 100).toFixed(1);\r\n    } else {\r\n      opacity = 1;\r\n    }\r\n    this.data.navbarData.opacity = opacity;\r\n    if (e.detail.scrollTop<10){\r\n      this.setData({\r\n        shownav: false\r\n      })\r\n    }else{\r\n      this.setData({\r\n        shownav: true\r\n      })\r\n    }\r\n    this.setData({\r\n      navbarData: this.data.navbarData,\r\n    })\r\n  }\r\n复制代码上拉加载以主页为例这里的实现方法在scroll-view 组件中加 bindscrolltolower 属性，会在页面触底时触发bindscrolltolower 绑定的事件。<scroll-view class=\"main_scro\" scroll-y bindscroll=\"scroll\" bindscrolltolower=\"bindDownLoad\">\r\n</scroll-view>\r\n复制代码bindDownLoad() {\r\n    let part = 0; //已经显示的数据长度\r\n    let all = 0; //总的数据长度\r\n    <!--判断当前城市是否为热门城市-->\r\n    if (this.data.ishot) {\r\n      // 待完善 因为效果相同就没写了\r\n    } else {\r\n      if (this.data.mcurIndex === 0) {\r\n        part = this.data.cur_view.length * 2;\r\n        all = this.data.placeData.allGuide[this.data.mcurIndex].content[this.data.hlcurIndex].content.length;\r\n      } else {\r\n        part = this.data.cur_view.length;\r\n        all = this.data.placeData.allGuide[this.data.mcurIndex].content.length;\r\n      }\r\n\r\n      if (part < all) {\r\n        wx.showLoading({\r\n          title: '正在加载'\r\n        })\r\n        setTimeout(() => {\r\n          this.bitiyan(this.data.placeData)\r\n          wx.hideLoading()\r\n        }, 1000)\r\n      } else {\r\n        <!--当所有数据都加载完了，就显示end 图标-->\r\n        this.setData({\r\n          showend: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n复制代码关于scroll-view组件有几点需要注意的设置竖向滚动的时后一定要设高度，有时候会发现设置了高度100%后，当滑到底部的时候，会显示不完整，这时候要看下你是否设置了margin/padding，或者父元素设置了margin/padding,这时的scroll-view组件的高度就要减去相应的margin/padding当设置为横向滚动时需要注意，scroll-view 中需要滑动的元素不可以用 float 浮动；scroll-view 中的包裹需要滑动的元素的大盒子用 display:flex 是没有作用的；scroll-view 中的需要滑动的元素要用 dislay:inline-block 进行元素的横向编排；包裹 scroll-view 的大盒子有明确的宽和加上样式--> overflow:hidden;white-space:nowrap;收藏功能收藏功能我是写在一个组件里，本来是想和顶部组件一样，供多个页面使用，后来因为写的页面中就只有一个有用到这个组件，这里就不单独说明这个组件了，而且这个组件和顶部组件基本差不多。收藏功能的实现，当点击某一个景点时会触发点击事件，相信你看了列表切换功能，已经知道了bind-tap 的使用方法，这里就不重复了。这里就是获取元素上的自定义属性，通过路由传参的方法传给详情页，详情页根据传递过来的数据，去数据源里获取相应的数据,再将数据传递给组件，当点击详情页上的收藏按钮时，会触发绑定的事件，然后会更新缓存中的collectData收藏夹数据。‘我的’页面会显示收藏夹中的数据详情页js<!--生命周期函数，监听页面加载-->\r\nonLoad: function(options) {\r\n    <!--options中包含了传递过来的参数-->\r\n    let name = options.name;\r\n    this.getinfo(name)\r\n}，\r\n<!--通过名字获取想要的数据-->\r\ngetinfo(name){\r\n    <!--先获取缓存中已经存在的收藏夹数据，如果不存在就将collectData设为空数组-->\r\n    let collectData = wx.getStorageSync('collectData') || [];\r\n    if (collectData.filter(e => e.name === name).length > 0) {\r\n      this.setData({\r\n        placeData: collectData.filter(e => e.name === name)[0]\r\n      })\r\n    } else {\r\n      let placeData = wx.getStorageSync('placeData')\r\n      let view = placeData.allGuide[0].content.map(e => e.content)\r\n      let newView = []\r\n      for (let i = 0; i < view.length; i++) {\r\n        newView.push(...view[i])\r\n      }\r\n      this.setData({\r\n        placeData: newView.find(e => e.name === name)\r\n      })\r\n    }\r\n    this.setBottom();\r\n  },\r\n  <!--设置要传递给bottom组件的数据-->\r\n  setBottom(){\r\n    this.data.bottomData.placeData = this.data.placeData;\r\n    let bottomData = this.data.bottomData;\r\n    this.setData({\r\n      bottomData\r\n    })\r\n  }\r\n复制代码bottom组件的js// components/bottom/bottom.js\r\nconst app = getApp()\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    bottomData: {   //   由父页面传递的数据，变量名字自命名\r\n      type: Object,\r\n      value: {},\r\n      observer: function (newVal, oldVal) {\r\n       }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    height: ''\r\n  },\r\n  attached: function () {\r\n    // 获取是否是通过分享进入的小程序\r\n    this.setData({\r\n      share: app.globalData.share\r\n    })\r\n    // 定义导航栏的高度   方便对齐\r\n    this.setData({\r\n      height: app.globalData.height\r\n    })\r\n  },\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    <!--点击收藏按钮触发的事件-->\r\n    collected(){\r\n      <!--将isCollect(是否收藏过),collectors(收藏人数)从数据中解构出来-->\r\n      let {isCollect,collectors} = this.data.bottomData.placeData;\r\n      isCollect = !isCollect;\r\n      this.data.bottomData.placeData.isCollect = isCollect;\r\n      let collectData = wx.getStorageSync('collectData') || [];\r\n      if(isCollect){\r\n        wx.showToast({\r\n          title: '收藏成功',\r\n          icon: 'success',\r\n          duration: 2000\r\n        })\r\n        collectors++;\r\n        collectData.push(this.data.bottomData.placeData);\r\n      }else{\r\n        wx.showToast({\r\n          title: '已取消收藏',\r\n          icon: 'success',\r\n          duration: 2000\r\n        })\r\n        collectors--;\r\n        collectData = collectData.filter(e => e.name != this.data.bottomData.placeData.name)\r\n      }\r\n      this.data.bottomData.placeData.collectors = collectors;\r\n      <!--将收藏夹数据放入缓存-->\r\n      wx.setStorageSync('collectData', collectData)\r\n      let bottomData = this.data.bottomData;\r\n      this.setData({\r\n        bottomData\r\n      })\r\n    }\r\n  }\r\n})\r\n\r\n复制代码搜索功能效果一效果二搜索功能的实现是通过原生组件input 上的bindinput属性，当键盘输入时触发bindinput属性绑定的方法，实时获取中输入的值，然后将获取到的值放入请求地址中请求数据，再将请求获得的数据放入页面的data数据源中，当请求到的数据不为空时，页面上会显示得到的所有相关数据，如效果一。当按下搜索按钮时会触发input框上bindconfirm属性绑定的事件，此时页面上会显示请求到的数据中的第一条，如效果二。wxml<input style='width:500rpx' bindconfirm='confirm' confirm-type='search' focus='true' placeholder=\"搜索目的地/景点/攻略\" bindinput='search'></input>\r\n复制代码js// pages/search/search.js\r\nconst app = getApp()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    navbarData: {\r\n      showCapsule: 1, //是否显示左上角图标   1表示显示    0表示不显示\r\n      title: '马蜂窝旅游', //导航栏 中间的标题\r\n      backgroundColor: '#ffffff', //'#354a98'\r\n      city: '',\r\n      opacity: 1,\r\n      showMain: 0\r\n    },\r\n    height: app.globalData.height * 2 + 20,\r\n    result: [],\r\n    searchparams: '',\r\n    show: true,\r\n    searchHistory: [],\r\n    showResult: false,\r\n    showconfirm: false,\r\n    placedata: []\r\n  },\r\n  <!--清空历史纪录-->\r\n  clear() {\r\n    this.setData({\r\n      searchHistory: []\r\n    })\r\n    wx.removeStorageSync('searchHistory')\r\n  },\r\n  <!--当点击键盘上搜索按钮触发的事件-->\r\n  confirm(e) {\r\n    if (e.detail.value != '') {\r\n      let searchHistory = wx.getStorageSync('searchHistory') || []\r\n      if (searchHistory.filter(a => a === e.detail.value).length === 0) {\r\n        searchHistory.push(e.detail.value)\r\n        wx.setStorageSync('searchHistory', searchHistory)\r\n      }\r\n      if (this.data.result.length > 0) {\r\n        let currentCity = this.data.result[0].name;\r\n        this.getCityDataByName(currentCity);\r\n      }\r\n      this.setData({\r\n        show: false,\r\n        showResult: false,\r\n        showconfirm: true\r\n      })\r\n    }\r\n  },\r\n  <!--跳到主页面-->\r\n  gotomain(e) {\r\n    wx.setStorageSync('currentCity', e.currentTarget.dataset.name)\r\n    wx.switchTab({\r\n      url: '/pages/main/index',\r\n    })\r\n  },\r\n  <!--点击历史纪录触发的事件，效果和confirm方法基本相同，不同的是confirm是从页面data中获取数据，而dosearch是从接口中获取数据-->\r\n  gosearch(e) {\r\n    let that = this\r\n    wx.request({\r\n      url: `https://www.easy-mock.com/mock/5ca457f04767c3737055c868/example/mafengwo/search?name=${e.currentTarget.dataset.name}`,\r\n      success: (res) => {\r\n        if (res.data.data.length > 0) {\r\n          that.getCityDataByName(res.data.data[0].name)\r\n        } else {\r\n          this.setData({\r\n            show: false,\r\n            showResult: false,\r\n            showconfirm: true\r\n          })\r\n        }\r\n      }\r\n    })\r\n\r\n  },\r\n  // 通过城市名字 获取城市数据\r\n  getCityDataByName(cityname) {\r\n    let that = this\r\n    wx.request({\r\n      url: 'https://www.easy-mock.com/mock/5ca457f04767c3737055c868/example/mafengwo/china',\r\n      success: (res) => {\r\n        let placedata = [];\r\n        placedata.push(...res.data.data.china.filter(e => e.chName === cityname))\r\n        that.setData({\r\n          placedata,\r\n          show: false,\r\n          showResult: false,\r\n          showconfirm: true\r\n        })\r\n      }\r\n    })\r\n  },\r\n  <!--当键盘输入时触发的事件-->\r\n  search(e) {\r\n    let that = this\r\n    wx.request({\r\n      url: `https://www.easy-mock.com/mock/5ca457f04767c3737055c868/example/mafengwo/search?name=${e.detail.value}`,\r\n      success: (res) => {\r\n        if (res.data.data.length > 0) {\r\n          that.changecolor(res.data.data, e.detail.value)\r\n        } else {\r\n          that.setData({\r\n            result: [],\r\n            searchparams: '',\r\n            showResult: false\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  <!--改变名字颜色-->\r\n  changecolor(result, searchparams) {\r\n    for (let j = 0; j < result.length; j++) {\r\n      let i = result[j].name.search(searchparams);\r\n      let left = result[j].name.slice(0, i),\r\n        mid = result[j].name.slice(i, i + searchparams.length),\r\n        right = result[j].name.slice(i + searchparams.length);\r\n      result[j].left = left;\r\n      result[j].mid = mid;\r\n      result[j].right = right;\r\n    }\r\n    this.setData({\r\n      result,\r\n      searchparams,\r\n      show: false,\r\n      showResult: true,\r\n      showconfirm: false\r\n    })\r\n  },\r\n  _navback() {\r\n    wx.navigateBack({\r\n      delta: 1\r\n    })\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function() {\r\n    <!--获取缓存中的搜索历史并放入数据源-->\r\n    let searchHistory = wx.getStorageSync('searchHistory') || []\r\n    this.setData({\r\n      searchHistory\r\n    })\r\n  }\r\n复制代码这个API接口是我用Easy Mock写的Easy Mock地址链接Easy Mock 代码{\r\n  \"data\": function({\r\n    _req\r\n  }) {\r\n    let i = 0,\r\n    <!--数据源_data由于篇幅原因就放了一小段数据-->\r\n      _data = [\r\n        {\r\n            name: '亚洲',\r\n            type: '目的地'\r\n          },\r\n          {\r\n            name: '欧洲',\r\n            type: '目的地'\r\n          },\r\n          {\r\n            name: '大洋洲',\r\n            type: '目的地'\r\n          },\r\n          {\r\n            name: '非洲',\r\n            type: '目的地'\r\n          },\r\n          {\r\n            name: '北美洲',\r\n            type: '目的地'\r\n          },\r\n          {\r\n            name: '南美洲',\r\n            type: '目的地'\r\n          },\r\n          {\r\n            name: '南极洲',\r\n            type: '目的地'\r\n          }\r\n      ],\r\n      <!--_req是easymock封装的对象，_req.query(将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字字符串则返回一个空对象);-->\r\n      name = _req.query.name;\r\n    if (name != '') {\r\n    <!--当输入的值不为空时-->\r\n      let result = [];\r\n      let data = []\r\n      for (let j = 0; j < result.length; j++) {\r\n      <!--eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。这里主要是为了给正则表达式动态传参-->\r\n        if (eval('/' + name + '/').test(result[j].name)) {\r\n          data.push(result[j])\r\n        }\r\n        <!--当查询到8个匹配项时跳出循环-->\r\n        if (data.length > 8) break;\r\n      }\r\n      return data\r\n    } else {\r\n    <!--当输入的值为空时直接返回空数组-->\r\n      return []\r\n    }\r\n  }\r\n}\r\n复制代码热门城市动画因为动画只有6个元素，所以就没有必要写成数组遍历创建了，直接写6个盒子，给他们的样式初始化，让他们到自己的初始位置去。微信小程序提供了创建动画实例的API wx.createAnimationwxml<view class='video a' animation=\"{{animation1}}\" data-index='0' bindtap=\"_play\">\r\n  <view class='context'>\r\n    <text>{{placeData.vlog[0].title}}</text>\r\n  </view>\r\n  <view class='vdoIcon'>\r\n    <image src='/images/play.png'></image>\r\n  </view>\r\n</view>\r\n<view class='video b' animation=\"{{animation2}}\" data-index='1' bindtap=\"_play\">\r\n  <view class='context'>\r\n    <text>{{placeData.vlog[1].title}}</text>\r\n  </view>\r\n  <view class='vdoIcon'>\r\n    <image src='/images/play.png'></image>\r\n  </view>\r\n</view>\r\n<view class='video c' animation=\"{{animation3}}\" data-index='2' bindtap=\"_play\">\r\n  <view class='context'>\r\n    <text>{{placeData.vlog[2].title}}</text>\r\n  </view>\r\n  <view class='vdoIcon'>\r\n    <image src='/images/play.png'></image>\r\n  </view>\r\n</view>\r\n<view class='video d' animation=\"{{animation4}}\" data-index='3' bindtap=\"_play\">\r\n  <view class='context'>\r\n    <text>{{placeData.vlog[3].title}}</text>\r\n  </view>\r\n  <view class='vdoIcon'>\r\n    <image src='/images/play.png'></image>\r\n  </view>\r\n</view>\r\n<view class='video e' animation=\"{{animation5}}\" data-index='4' bindtap=\"_play\">\r\n  <view class='context'>\r\n    <text>{{placeData.vlog[4].title}}</text>\r\n  </view>\r\n  <view class='vdoIcon'>\r\n    <image src='/images/play.png'></image>\r\n  </view>\r\n</view>\r\n<view class='video f' animation=\"{{animation6}}\" data-index='5' bindtap=\"_play\">\r\n  <view class='context'>\r\n    <text>{{placeData.vlog[5].title}}</text>\r\n  </view>\r\n  <view class='vdoIcon'>\r\n    <image src='/images/play.png'></image>\r\n  </view>\r\n</view>\r\n复制代码wxss.a{\r\n  opacity: 0.9;\r\n}\r\n.b{\r\n  transform: translate(170rpx,-110rpx) scale(0.8);\r\n  opacity: 0.8;\r\n}\r\n.c{\r\n  transform: translate(210rpx,-250rpx) scale(0.7);\r\n  opacity: 0.7;\r\n}\r\n.d{\r\n  transform: translate(10rpx,-350rpx) scale(0.6);\r\n  opacity: 0.6;\r\n}\r\n.e{\r\n  transform: translate(-250rpx,-290rpx) scale(0.8);\r\n  opacity: 0.5;\r\n}\r\n.f{\r\n  transform: translate(-300rpx,-130rpx) scale(0.9);\r\n  opacity: 0.8;\r\n}\r\n复制代码js// 动画的运行路线\r\n  translate: function(i) {\r\n    // 获取屏幕宽度来实现自适应\r\n    let windowwidth = this.data.windowWidth;\r\n    //动画的运行状态status[x轴偏移量,y轴偏移量,scale缩放倍数,opacity透明度],也是动画的运行路线\r\n    let status = [\r\n      [170, -110, 0.8, 0.7],\r\n      [210, -250, 0.7, 0.6],\r\n      [10, -350, 0.6, 0.5],\r\n      [-250, -300, 0.8, 0.7],\r\n      [-300, -130, 0.9, 0.8],\r\n      [0, 0, 1, 0.9]\r\n    ];\r\n    let x = 0,\r\n      y = 0,\r\n      scale = 0,\r\n      opacity = 0;\r\n    for (let j = 0; j < 6; j++) {\r\n      let animationName = 'animation' + (j + 1);\r\n      x = status[(i + j) % 6][0] / 750 * windowwidth;\r\n      y = status[(i + j) % 6][1] / 750 * windowwidth;\r\n      scale = status[(i + j) % 6][2];\r\n      opacity = status[(i + j) % 6][3];\r\n      this.animation.translate(x, y).scale(scale).opacity(opacity).step()\r\n      this.setData({\r\n        [animationName]: this.animation.export()//导出动画数据传递给组件的 animation 属性\r\n      })\r\n    }\r\n  },\r\n  hotCityAnimation() {\r\n    let i = 0;\r\n    <!--创建动画实例-->\r\n    this.animation = wx.createAnimation({\r\n      duration: 2000,\r\n      timingFunction: 'ease',\r\n    })\r\n    let that = this\r\n    let anicontrol = this.data.anicontrol\r\n    anicontrol = setInterval(function() {\r\n      that.translate(i)\r\n      if (i == 5) {\r\n        i = -1;\r\n      }\r\n      i++;\r\n    }, 3000)\r\n    this.setData({\r\n      anicontrol\r\n    })\r\n  }\r\n复制代码这里要注意的是，因为这是写在tabbar页面的动画，而且用了setinterval定时器，会按照指定的周期（以毫秒计）来执行注册的回调函数，意思就是即使你跳转到别的页面，动画依然在运行，当你回到主页时，动画就会运行出错，出现鬼畜，所以要在主页的onHide周期函数，监听页面隐藏时就把定时器给清除了，并且把动画实例也清除。onHide: function() {\r\n    let anicontrol = this.data.anicontrol;\r\n    clearInterval(anicontrol)\r\n    this.setData({\r\n      animation1: '',\r\n      animation2: '',\r\n      animation3: '',\r\n      animation4: '',\r\n      animation5: '',\r\n      animation6: ''\r\n    })\r\n  }\r\n复制代码关于css写这个小程序我没有用到任何UI框架，这有坏处，也有好处，坏处就是代码进度贼慢，好处就是自己增加了很多对css的理解。有想用UI框架的可以使用 WeUI 。链接里有详细的使用方法。结语因为时间和精力的缘故，小程序只写了几个页面和小部分功能，在写项目的过程中也发现了自己的很多不足，因此吃到了不少苦头，但是也学到了不少，可以说痛并快乐着。希望这篇文章能够对打算写小程序的你有一点帮助。 GitHub源码 在这里，需要自取。"}
{"title": "小程序多图上传并压缩,带预览删除功能 ", "author": "Rolan", "pub_time": "2019-6-17 00:42", "content": "<view class=\"upload_view\">　　<block wx:for=\"{{pics}}\" wx:key=\"*this\">\r\n　　　　<view class=\"q_image_wrap\">\r\n　　　　　　<!-- 图片缩略图  -->\r\n　　　　　　<image class=\"q_image\" src=\"{{item}}\" mode=\"aspectFill\" data-idx=\"{{index}}\" bindtap=\"handleImagePreview\"></image>\r\n　　　　　　<!-- 移除图片的按钮  -->\r\n　　　　　　<view class=\"q_image_remover\" data-idx=\"{{index}}\" bindtap=\"removeImage\">\r\n　　　　　　　　<i-icon type=\"close\" size=\"14\" class=\"icon\" />\r\n　　　　　　</view>\r\n　　　　</view>　　</block>\r\n　　<view class='uploadImg_btn' bindtap=\"chooseImage\" wx:if=\"{{pics.length < 9}}\">\r\n　　　　<image src=\"../../img/upload.png\"></image>\r\n　　</view>\r\n</view> //选择图片\r\n    chooseImage(e) {\r\n        console.log(e)\r\n        var that = this;\r\n        var pics = this.data.pics;\r\n        //---------------------多张上传----------------------------------------------------------------------------------------\r\n        wx.chooseImage({\r\n            count: 9 - pics.length, // 最多可以选择的图片张数，默认9\r\n            sizeType: ['original', 'compressed'], // original 原图，compressed 压缩图，默认二者都有\r\n            sourceType: ['album', 'camera'], // album 从相册选图，camera 使用相机，默认二者都有\r\n            success: function (photo) {\r\n                //图片大小，限制10M以内\r\n                for (var i = 0; i < photo.tempFiles.length; i++) {\r\n                    if (photo.tempFiles[i].size >= 10 * 1024 * 1024) {\r\n                        console.log('请上传10M以内的图片');\r\n                        return;\r\n                    }\r\n                }\r\n                var imgsrc = photo.tempFilePaths;\r\n                //页面上展示的是原图片========pics数组\r\n                pics = pics.concat(imgsrc);\r\n                that.setData({\r\n                    pics: pics\r\n                });\r\n                console.log(that.data.pics)\r\n                that.getCanvasImg(0, 0, photo.tempFilePaths);  //进行压缩\r\n            },\r\n            fail: function () {\r\n                // fail\r\n            },\r\n            complete: function () {\r\n                // complete\r\n            }\r\n        })\r\n    }, //压缩并获取图片，这里用了递归的方法来解决canvas的draw方法延时的问题\r\n    getCanvasImg: function (index, failNum, tempFilePaths) {\r\n        var that = this;\r\n        let imagesPress = that.data.imagesPress;\r\n        if (index < tempFilePaths.length) {\r\n            wx.getImageInfo({\r\n                src: tempFilePaths[index],\r\n                success: function (res) {\r\n                    //---------利用canvas压缩图片--------------\r\n                    var ratio = 2;\r\n                    var canvasWidth = res.width //图片原始长宽\r\n                    var canvasHeight = res.height\r\n                    while (canvasWidth > 400 || canvasHeight > 400) {// 保证宽高在400以内\r\n                        canvasWidth = Math.trunc(res.width / ratio)\r\n                        canvasHeight = Math.trunc(res.height / ratio)\r\n                        ratio++;\r\n                    }\r\n                    that.setData({\r\n                        canvasWidth: canvasWidth,\r\n                        canvasHeight: canvasHeight,\r\n                    })\r\n                    const ctx = wx.createCanvasContext('photo_canvas');\r\n                    ctx.drawImage(tempFilePaths[index], 0, 0, canvasWidth, canvasHeight);\r\n                    ctx.draw(false, function () {\r\n                        index = index + 1;//上传成功的数量，上传成功则加1\r\n                        wx.canvasToTempFilePath({\r\n                            canvasId: 'photo_canvas',\r\n                            success: function success(res) {\r\n                                console.log('最终图片路径' + res.tempFilePath)//最终图片路径\r\n                                imagesPress.push(res.tempFilePath);\r\n                                console.log(that.data.imagesPress)\r\n                                that.setData({\r\n                                    imagesPress: imagesPress\r\n                                })\r\n                                that.uploadCanvasImg(res.tempFilePath);\r\n                                that.getCanvasImg(index, failNum, tempFilePaths);\r\n                            }, fail: function (e) {\r\n                                failNum += 1;//失败数量，可以用来提示用户\r\n                                that.getCanvasImg(inedx, failNum, tempFilePaths);\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            })\r\n\r\n        }\r\n    },//上传图片\r\n    uploadCanvasImg: function (canvasImg) {\r\n        const {$Toast} = require('../../dist/base/index');\r\n        var that = this;\r\n        let attachmentId = that.data.attachmentId\r\n        var tempImg = canvasImg;\r\n        wx.showLoading({\r\n            title: '上传中...',\r\n        });\r\n        wx.uploadFile({\r\n            url: app.globalData.baseUrl + '/api/upload',//文件服务器的地址\r\n            filePath: tempImg,\r\n            header: {\r\n                'Content-type': 'multipart/form-data',\r\n                'token': wx.getStorageSync('token')\r\n            },\r\n            // formData: {\r\n            // },\r\n            name: 'file',\r\n            success: function (res) {\r\n                wx.hideLoading()\r\n                $Toast({\r\n                    content: '上传成功！'\r\n                });\r\n                console.log(res)\r\n            }\r\n        })\r\n    },//删除图片\r\n    removeImage(e) {\r\n        var that = this;\r\n        var pics = that.data.pics;\r\n        var imagesPress = that.data.imagesPress;\r\n        // 获取要删除的第几张图片的下标\r\n        const idx = e.currentTarget.dataset.idx\r\n        // splice  第一个参数是下表值  第二个参数是删除的数量\r\n        pics.splice(idx, 1)\r\n        imagesPress.splice(idx, 1)\r\n        this.setData({\r\n            pics: pics,\r\n            imagesPress: imagesPress\r\n        })\r\n        console.log(that.data.imagesPress)\r\n    },\r\n    //预览图片\r\n    handleImagePreview(e) {\r\n        const idx = e.target.dataset.idx\r\n        const pics = this.data.pics\r\n        wx.previewImage({\r\n            current: pics[idx],  //当前预览的图片\r\n            urls: pics,  //所有要预览的图片\r\n        })\r\n    },"}
{"title": "小程序登录数据解密 ", "author": "Rolan", "pub_time": "2019-6-19 00:13", "content": "小程序开发中，需要用户授权登陆并获取用户的数据，快速对接用户系统。openId与unionid的区别openId : 用户在当前小程序的唯一标识 unionId : 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionId是相同的。详情登录微信开放平台(open.weixin.qq.com) 。GET  https://api.weixin.qq.com/sns/jscode2session?appid=xx&secret=xx&js_code=xx&grant_type=authorization_code\r\n\r\n属性类型默认值必填说明\r\nappid    string    是    小程序 appId    \r\nsecret    string    是    小程序 appSecret    \r\njs_code    string    是    登录时获取的 code    \r\ngrant_type    string    是    授权类型，此处只需填写 authorization_code    \r\n\r\n\r\nObject\r\n返回的 JSON 数据包\r\n属性类型说明\r\nopenid    string    用户唯一标识    \r\nsession_key    string    会话密钥    \r\nunionid    string    用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 UnionID 机制说明。    \r\nerrcode    number    错误码    \r\nerrmsg    string    错误信息解密类class WxBizDataCrypt\r\n{\r\n    private $appid;\r\n    private $sessionKey;\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param $sessionKey string 用户在小程序登录后获取的会话密钥\r\n     * @param $appid string 小程序的appid\r\n     */\r\n    public function __construct( $appid, $sessionKey)\r\n    {\r\n        $this->sessionKey = $sessionKey;\r\n        $this->appid = $appid;\r\n    }\r\n\r\n\r\n    /**\r\n     * 检验数据的真实性，并且获取解密后的明文.\r\n     * @param $encryptedData string 加密的用户数据\r\n     * @param $iv string 与用户数据一同返回的初始向量\r\n     * @param $data string 解密后的原文\r\n     *\r\n     * @return int 成功0，失败返回对应的错误码\r\n     */\r\n    public function decryptData( $encryptedData, $iv, &$data )\r\n    {\r\n        if (strlen($this->sessionKey) != 24) {\r\n            return ErrorCode::$IllegalAesKey;\r\n        }\r\n        $aesKey=base64_decode($this->sessionKey);\r\n\r\n\r\n        if (strlen($iv) != 24) {\r\n            return ErrorCode::$IllegalIv;\r\n        }\r\n        $aesIV=base64_decode($iv);\r\n\r\n        $aesCipher=base64_decode($encryptedData);\r\n\r\n        $result=openssl_decrypt( $aesCipher, \"AES-128-CBC\", $aesKey, 1, $aesIV);\r\n\r\n        $dataObj=json_decode( $result );\r\n        if( $dataObj  == NULL )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        if( $dataObj->watermark->appid != $this->appid )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        $data = $result;\r\n        return ErrorCode::$OK;\r\n    }\r\n}代码如下仅供参考转载时请注明出处及相应链接，本文永久地址：https://blog.yayuanzi.com/25402.html"}
{"title": "基于uni-app的缓存器 ", "author": "Rolan", "pub_time": "2019-6-19 00:34", "content": "在前端开发应用程序中，性能一直都是被大家所重视的一点，然而判断一个应用程序的性能最直观的就是看页面打开的速度。其中提高页页面反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短页面请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。前端常用缓存技术在这里我就不再描述，下面基于Storage对其进行增强，采用Map 基本相同的api。阅读以下内容时遇到不懂的，请先科普阮一峰老师的ECMAScript 6 入门下面是基本代码，会在此基础上进行增强class MinCache {\r\n  // 将数据存储在本地缓存中指定的 name 中\r\n  set (name, data) {\r\n    try {\r\n      uni.setStorageSync(name, data)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  // 从本地缓存中获取指定 name 对应的内容\r\n  get (name) {\r\n    let data\r\n    try {\r\n      data = uni.getStorageSync(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return data\r\n  }\r\n  // 从本地缓存中移除指定 key\r\n  delete (name) {\r\n    try {\r\n      uni.removeStorageSync(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  // 返回一个布尔值，表示 name 是否在本地缓存之中\r\n  has (name) {\r\n    const value\r\n    try {\r\n      const res = uni.getStorageInfoSync()\r\n      value = res.keys.includes(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return value\r\n  }\r\n  // 清理本地数据缓存\r\n  clear () {\r\n    try {\r\n      uni.clearStorageSync()\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n}\r\n\r\nexport default MinCache复制代码我们知道缓存往往是有危害的，那么我们最好规定个时间来去除数据。class CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    // 设置超时时间，单位秒\r\n    this.timeout = timeout\r\n    // 对象创建时候的时间\r\n    this.createTime = Date.now()\r\n  }\r\n}复制代码set (name, data, timeout = 1200) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    try {\r\n      uni.setStorageSync(name, cachecell)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  get (name) {\r\n    let data = null\r\n    try {\r\n      data = uni.getStorageSync(name)\r\n      if (!data) return null\r\n      const currentTime = Date.now()\r\n      const overTime = (currentTime - data.createTime) / 1000\r\n      if (overTime > data.timeout) {\r\n        try {\r\n          uni.removeStorageSync(name)\r\n          data = null\r\n        } catch (e) {\r\n          console.log(e)\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return data\r\n  }复制代码使用了过期时间进行缓存的方式，已经可以满足绝大部分的业务场景。uni-app的Storage在不同端的实现不同：H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理App端为原生的plus.storage，无大小限制，不是缓存，持久化各个小程序端为其自带的storage api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。百度、头条小程序文档未说明大小限制除此之外，H5端还支持websql、indexedDB、sessionStorage；App端还支持SQLite、IO文件等本地存储方案。我们可以看出来Storage在一些端中是有大小限制的，其实我们的数据只是想要缓存，不一定要持久化。也就是说在应用程序生命周期内使用就行，而且直接操作Storage也不是很好。我们知道ES6中有Map可以做缓存下面代码时基于Map封装的let cacheMap =  new Map()\r\nlet instance = null\r\nlet timeoutDefault = 1200\r\n\r\nfunction isTimeout (name) {\r\n  const data = cacheMap.get(name)\r\n  if (!data) return true\r\n  if (data.timeout === 0) return false\r\n  const currentTime = Date.now()\r\n  const overTime = (currentTime - data.createTime) / 1000\r\n  if (overTime > data.timeout) {\r\n    cacheMap.delete(name)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nclass CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    this.timeout = timeout\r\n    this.createTime = Date.now()\r\n  }\r\n}\r\n\r\nclass Cache {\r\n  set (name, data, timeout = timeoutDefault) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    return cacheMap.set(name, cachecell)\r\n  }\r\n  get (name) {\r\n    return isTimeout(name) ? null : cacheMap.get(name).data\r\n  }\r\n  delete (name) {\r\n    return cacheMap.delete(name)\r\n  }\r\n  has (name) {\r\n    return !isTimeout(name)\r\n  }\r\n  clear () {\r\n    return cacheMap.clear()\r\n  }\r\n  setTimeoutDefault (num) {\r\n    if (timeoutDefault === 1200) {\r\n      return timeoutDefault = num\r\n    }\r\n    throw Error('缓存器只能设置一次默认过期时间')\r\n  }\r\n}\r\n\r\nclass ProxyCache {\r\n  constructor () {\r\n    return instance || (instance = new Cache())\r\n  }\r\n}\r\n\r\nexport default ProxyCache复制代码对Storage和Map封装的缓存进行整合我们来分析一下Storage和Map共用一套api在命名上解决以下划线_开头命名的缓存到Storage，并且Map也有副本尽量不操作Storage(读取速度慢)那就必须在应用程序初始化的时候把Storage加载进Map像Vue插件一样使用let cacheMap =  new Map()\r\nlet timeoutDefault = 1200\r\n\r\nfunction isTimeout (name) {\r\n  const data = cacheMap.get(name)\r\n  if (!data) return true\r\n  if (data.timeout === 0) return false \r\n  const currentTime = Date.now()\r\n  const overTime = (currentTime - data.createTime) / 1000\r\n  if (overTime > data.timeout) {\r\n    cacheMap.delete(name)\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.removeStorageSync(name)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nclass CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    this.timeout = timeout\r\n    this.createTime = Date.now()\r\n  }\r\n}\r\n\r\nclass MinCache {\r\n  constructor (timeout) {\r\n    try {\r\n      const res = uni.getStorageInfoSync()\r\n      res.keys.forEach(name => {\r\n        try {\r\n          const value = uni.getStorageSync(name)\r\n          cacheMap.set(name, value)\r\n        } catch (e) {\r\n          console.log(e)\r\n        }\r\n      })\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    timeoutDefault = timeout\r\n  }\r\n  set (name, data, timeout = timeoutDefault) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    let cache = null\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.setStorageSync(name, cachecell)\r\n        cache = cacheMap.set(name, cachecell)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    } else {\r\n      cache = cacheMap.set(name, cachecell)\r\n    }\r\n    return cache\r\n  }\r\n  get (name) {\r\n    return isTimeout(name) ? null : cacheMap.get(name).data\r\n  }\r\n  delete (name) {\r\n    let value = false\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.removeStorageSync(name)\r\n        value = cacheMap.delete(name)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    } else {\r\n      value = cacheMap.delete(name)\r\n    }\r\n    return value\r\n  }\r\n  has (name) {\r\n    return !isTimeout(name)\r\n  }\r\n  clear () {\r\n    let value = false\r\n    try {\r\n      uni.clearStorageSync()\r\n      cacheMap.clear()\r\n      value = true\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return value\r\n  }\r\n}\r\n\r\nMinCache.install = function (Vue, {timeout = 1200} = {}) {\r\n  Vue.prototype.$cache = new MinCache(timeout)\r\n}\r\n\r\nexport default MinCache复制代码使用方法name以下划线_开头命名的缓存到Storage，并且Map也有副本事件名参数说明返回值setname缓存的key,data缓存的数据,timeout(必须数字单位s)缓存时间，默认缓存1200s, timeout设置为0表示永久缓存设置缓存数据Map集合getname缓存的key获取数据(缓存过期将返回null)返回缓存的数据datahasname缓存的key检查值true/falsedeletename缓存的key删除数据true/falseclear-清空Storage和Map缓存数据true/false// 注册缓存器\r\nVue.use(MinCache)\r\n// 设置默认缓存时间\r\n// Vue.use(MinCache, {timeout: 600})复制代码// 'name'不是以下划线开头的表示会缓存到Map中，在程序生命周期内有并且在有效时间内有效\r\nthis.$cache.set('name', 'MinCache')\r\n\r\n// 过期时间设置为0表示不会过期\r\n// 注意：'test'并不是以下划线命名表示在程序生命周期永久缓存\r\nthis.$cache.set('test', 'testdemo', 0)\r\n\r\n// 过期时间设置为0表示不会过期\r\n// 注意：'_imgURL'是以下划线命名表示永久缓存到Storage\r\nthis.$cache.set('_imgURL', 'data', 0)复制代码// 获取缓存的数据\r\nthis.imgURL = this.$cache.get('_imgURL')\r\nthis.name = this.$cache.get('name')\r\nthis.test = this.$cache.get('test')复制代码具体使用方法可以参考\tgithubuni-app路由的封装"}
{"title": "通过json用canvas生成分享海报,支持微信小程序和web ", "author": "Rolan", "pub_time": "2019-6-19 00:39", "content": "需求在项目里写过几个canvas生成分享海报页面后,觉得这是个重复且冗余的工作.于是就想有没有能通过类似json直接生成海报的库.然后就在github找到到两个项目:wxa-plugin-canvas ,不太喜欢配置文件的写法.就没多去了解mp_canvas_drawer ,使用方式就比较符合直觉,不过可惜功能有点少.然后就想着能不能自己再造个轮子.于是就有了这个项目 json2canvas ,你可以简单的理解为是mp_canvas_drawer的增强版吧.json2canvas canvas绘制海报,写个json就够了.项目的canvas绘制是基于 cax 实现的.所以天然的带来一个好处,json2canvas同时支持小程序和web功能支持缩放. 如果设计稿是750,而画布只有375时.你不需要任何换算,只需要将scale设置为0.5即可.支持图片圆角支持圆型,矩形,矩形圆角(背景色支持线性渐变)长文本自动换行(感谢 coolzjy@v2ex 提供的正则 https://regexr.com/4f12l ,优化了换行的计算方式(不会粗暴的折断单词))支持分组(cax里很好用的一个功能)同时支持小程序和web示例demo-web 界面左边的json,可以进行编辑,直接看效果哟~小程序demogit clone https://github.com/willnewii/json2canvas.git\r\n微信开发者工具导入项目 example/weapp/小程序安装npm i json2canvas\r\n微信开发者工具->工具->构建npm在需要使用的界面引入Component{\r\n  \"usingComponents\": {\r\n    \"json2canvas\":\"/miniprogram_npm/json2canvas/index\"\r\n  }\r\n}举个例子想要生成一个这样的海报,需要怎么做？(红框是图片元素,蓝框是文字元素,其余的是一张背景图。)简单,一个json搞定.具体支持的元素和参数,请查看项目 readme{\r\n        \"width\": 750,\r\n        \"height\": 1334,\r\n        \"scale\": 0.5,\r\n        \"children\": [\r\n            {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/bg_concerts_1.jpg\",\r\n                \"width\": 750,\r\n                \"height\": 1334\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\",\r\n                \"width\": 100,\r\n                \"x\": 48,\r\n                \"y\": 44,\r\n                \"isCircular\": true,\r\n            }, {\r\n                \"type\": \"circle\",\r\n                \"r\": 50,\r\n                \"lineWidth\": 5,\r\n                \"strokeStyle\": \"#CCCCCC\",\r\n                \"x\": 48,\r\n                \"y\": 44,\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"歌词本\",\r\n                \"font\": \"30px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": 168,\r\n                \"y\": 75,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/medal_concerts_1.png\",\r\n                \"width\": 300,\r\n                \"x\": \"center\",\r\n                \"y\": 361\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"一生活一场 五月天\",\r\n                \"font\": \"38px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": \"center\",\r\n                \"y\": 838,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"北京6场，郑州2场，登船，上班，听到你想听的歌了吗？\",\r\n                \"font\": \"24px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": \"center\",\r\n                \"y\": 888,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"rect\",\r\n                \"width\": 750,\r\n                \"height\": 193,\r\n                \"fillStyle\": \"#FFFFFF\",\r\n                \"x\": 0,\r\n                \"y\": \"bottom\"\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\",\r\n                \"width\": 117,\r\n                \"height\": 117,\r\n                \"x\": 47,\r\n                \"y\": 1180\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"长按识别小程序二维码\",\r\n                \"font\": \"26px Arial\",\r\n                \"color\": \"#858687\",\r\n                \"x\": 192,\r\n                \"y\": 1202\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"加入五月天 永远不会太迟\",\r\n                \"font\": \"18px Arial\",\r\n                \"color\": \"#A4A5A6\",\r\n                \"x\": 192,\r\n                \"y\": 1249\r\n            }]\r\n    }问题反馈有什么问题可以直接 提issue"}
{"title": "[填坑手册]小程序目录结构和组件化使用心得 ", "author": "Rolan", "pub_time": "2019-6-20 00:14", "content": "小程序目录结构关于小程序的目录结构，可以说一开始大家都有各自的开发习惯和命名规则，但一旦项目变得复杂庞大的时候，你就发现管理起来和后期维护变得很麻烦，如果是 协同开发 的话，更容易出现 “互坑” 的情况。智库君在一年多的小程序开发中也跳过不少的坑，总结了一套还算好维护的目录结构跟大家分享（仅供 参考 ，觉得好拿去，觉得不好欢迎提出意见），以下是实战项目中的结构示例：├─  app.js    --- 小程序加载时优先加载的入口JS\r\n├─  app.json   ---入口文件和公共配置\r\n├─  app.wxss     ---公共样式表\r\n├─  project.config.json     ---小程序全局配置文件\r\n├─  sitemap.json     ---允许微信索引文件\r\n│  \r\n├─cloud-functions     ---云函数\r\n│  └─setCrypto      ---数据加密模块，用户加密一些数据\r\n│          index.js\r\n│          package.json\r\n│          ...\r\n│          ...\r\n│          \r\n├─components      ---小程序自定义组件\r\n│  ├─plugins      --- （重点）可独立运行的大型模块，可以打包成plugins\r\n│  │  ├─comment         ---评论模块\r\n│  │  │  │  index.js\r\n│  │  │  │  index.json\r\n│  │  │  │  index.wxml\r\n│  │  │  │  index.wxss\r\n│  │  │  │  services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n│  │  │  │      \r\n│  │  │  └─submit    ---评论模块子模块：提交评论\r\n│  │  │          index.js\r\n│  │  │          index.json\r\n│  │  │          index.wxml\r\n│  │  │          index.wxss\r\n│  │  │      \r\n│  │  └─canvasPoster     ---canvas海报生成模块\r\n│  │          index.js\r\n│  │          index.json\r\n│  │          index.wxml\r\n│  │          index.wxss\r\n│  │          services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n│  │     ...\r\n│  │     ...\r\n│  │          \r\n│  └─templates   ---（重点）模板，通过外部传参的容器，不做过多的数据处理\r\n│      │      \r\n│      ├─slideshow     ---滚屏切换模板\r\n│      │      index.js\r\n│      │      index.json\r\n│      │      index.wxml\r\n│      │      index.wxss\r\n│      │      service.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n│      │      \r\n│      └─works       ---作品模板\r\n│          │  index.js\r\n│          │  index.json\r\n│          │  index.wxml\r\n│          │  index.wxss\r\n│          │  service.js\r\n│          │  \r\n│          ├─articlePlugin    ---作品模板中的文章类型\r\n│          │      index.js\r\n│          │      index.json\r\n│          │      index.wxml\r\n│          │      index.wxss\r\n│          │      \r\n│          ├─galleryPlugin    ---作品模板中的九宫格类型\r\n│          │      index.js\r\n│          │      index.json\r\n│          │      index.wxml\r\n│          │      index.wxss\r\n│          │      \r\n│          └─videoPlugin     ---作品模板中的视频类型\r\n│                  index.js\r\n│                  index.json\r\n│                  index.wxml\r\n│                  index.wxss\r\n│                  ...\r\n│                  ...\r\n│                  \r\n├─config     ---自定义配置文件\r\n│      config.js    ---存放基础配置\r\n│      constants.js   ---存储常量\r\n│      weui.wxss   ---第三方文件wxss，js等\r\n│      ...\r\n│      ...\r\n│      \r\n├─pages     ---小程序页面\r\n│  ├─user      ---用户页面\r\n│  │      index.js\r\n│  │      index.json\r\n│  │      index.wxml\r\n│  │      index.wxss\r\n│  ├─news      ---新闻页面\r\n│  │      index.js\r\n│  │      index.json\r\n│  │      index.wxml\r\n│  │      index.wxss\r\n│  │      \r\n│  └─home      ---首页\r\n│         index.js\r\n│         index.json\r\n│         index.wxml\r\n│         index.wxss\r\n│         ...   \r\n│         ...   \r\n│          \r\n├─request      ---https请求管理（根据switch tab分类会比较好）\r\n│      common.js    ---一些公共请求获取，如兑换openId,unionId 等\r\n│      news.js\r\n│      uri.js     --- （重点）总的URI请求管理，方便切换和配置DEV,QA,PROD环境\r\n│      user.js\r\n│      ...\r\n│      ...\r\n│      \r\n└─utils       ---功能组件\r\n        logger.js    ---日志管理\r\n        util.js       ---公共小组件库\r\n        ...\r\n        ...\r\n        \r\n复制代码例如微信自己的wepy的官方文档，现在也添加了目录结构说明：为什么一定要写这个目录结构呢？不知道大家有没有发现，在以往的老项目交接和多人协同开发中，容易遇到别人写的模块，变量命名不准确，或者资料缺损，一次十来个方法/组件间的互相调用，直接把接（盘）手的人整懵逼了，所以智库君觉得，无论是独立开发，还是协同开发，留一份完整的目录说明文档是很有必要的， 勿坑他人 OR 未来的自己~~~component使用心得大家在开发过程中肯定会去看官方文档，但不可能全看完才开始写代码，大多数情况都是用到了再看，本人也是，所以下面抽一些开发中遇到的重点来讲：一、引用组件模板页面的自定义组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。 在组件模板中可以提供一个 节点，用于承载组件引用时提供的子节点。<!-- 组件模板 -->\r\n<view class=\"wrapper\">\r\n  <view>这里是组件的内部节点</view>\r\n  <slot></slot>\r\n</view>\r\n复制代码<!-- page页/父页面引用组件的页面模板 -->\r\n<view>\r\n  <component-tag-name>\r\n    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n    <view>这里是插入到组件slot中的内容</view>\r\n    <view>在加载组件的页面里自定义内容，将没有复用性的内容写在这里</view>\r\n  </component-tag-name>\r\n</view>\r\n复制代码页面自定义部分默认是加载在组件 上方 。为什么要在引用组件的页面添加这些内容呢？因为组件其中一个重要的特点是 复用性 ，但是有的时候可能要根据不同场景做一些 自定义 ，如果在组件中写大量的场景/逻辑判断，会增加组件的冗余，而且这些方法只是被 复用一次 的话，完全可以不写到组件里。二、“一键换肤”根据不同场景给组件引入外部样式<!-- 外部引用组件的页面传入样式 -->\r\n<WorkComponent extra-class=\"style1\" j-data=\"{{workData}}\"></WorkComponent>\r\n复制代码//组件中js\r\nComponent({\r\n    /**\r\n    * 引入外部样式，可传多个class\r\n    */\r\n    externalClasses: ['extra-class','extra-class2'],\r\n})\r\n复制代码extra-class从外部引入父级css，可用根据不同场景配置不同的样式方案，这样使得组件自定义能力更强。三、数据清洗与容错//service.js  思路示例\r\nmodule.exports = {\r\n    /**\r\n     * 功能：处理作者列表\r\n     * @param list\r\n     * @returns {Array}\r\n     */\r\n    authorList: function (list = []) {\r\n        let result = [];\r\n        list.forEach(item => {\r\n            result.push({\r\n                guid: item.recommend_obj_id || '',\r\n                type: item.recommend_type || '',\r\n                logo: (item.theme_pic || '').trim() || '',\r\n                title: item.title || ''\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n};\r\n复制代码如果外部传入的数据要分别导入多个组件中，可以在组件中建立一个对应的service.js，有2个作用：清洗数据，避免setData()的时有过多的脏数据错误数据的兼容，添加数据缺省值，增加代码健壮性四、canvas在component组件中无法选中的问题//这里只需要在后面 添加this对象\r\n    let ctx = wx.createCanvasContext('myCanvas', this);\r\n复制代码其他一些默认组件，遇到类似的问题，一般只要引用时传入this对象即可解决。五、组件之间的通讯在实际生产环境中，我们常常需要控制各个组件之间的互相通信/传参，下面介绍下具体的用法：WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。事件：用于子组件向父组件传递数据，可以传递任意数据。如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。设置监听事件：<!-- wxml 中 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->\r\n<component-tag-name bindmyevent=\"setMyEvent\" />\r\n<!-- 或者可以写成 -->\r\n<component-tag-name bind:myevent=\"setMyEvent\" />\r\n复制代码// index.js 父页面中\r\nPage({\r\n  setMyEvent: function(e){\r\n    let self = this;\r\n    if (e.detail) { // 自定义组件触发事件时提供的detail对象\r\n      switch (e.detail) {\r\n        case \"hidden\":  //隐藏 悬浮框上的评论\r\n          this.setData({\r\n            isFixCommentShow: false\r\n          });\r\n          break;\r\n        case \"fixRefresh\":   //刷新悬浮框\r\n          this.setData({\r\n            fixRefresh: true\r\n          });\r\n          break;\r\n        case \"commentRefresh\":  //刷新评论\r\n          this.setData({\r\n            commentRefresh: Math.random()\r\n          });\r\n          break;\r\n        case \"createPoster\":  //生成海报组件\r\n          self.setPosterSave();\r\n          break;\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码父页面引用子组件，子组件发送的信息，可以通过bind的方法监听到，来获取到具体的传参值。触发事件自定义组件触发事件时，需要使用 triggerEvent方法，指定事件名、detail对象和事件选项：<!-- 页面 page.wxml -->\r\n<another-component bindcustomevent=\"pageEventListener1\">\r\n   <my-component bindcustomevent=\"pageEventListener2\"></my-component>\r\n</another-component>\r\n<!-- 组件 another-component.wxml -->\r\n<view bindcustomevent=\"anotherEventListener\">\r\n   <slot />\r\n</view>\r\n<!-- 组件 my-component.wxml -->\r\n<view bindcustomevent=\"myEventListener\">\r\n  <slot />\r\n</view>\r\n复制代码//组件中js\r\nComponent({\r\n  properties: {},\r\n  methods: {\r\n    onTap: function(){\r\n        var myEventDetail = {} // detail对象，提供给事件监听函数\r\n        var myEventOption = {} // 触发事件的选项\r\n        this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n        //myEventOption的一些配置：\r\n        this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1\r\n        this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1\r\n    }\r\n  }\r\n});\r\n复制代码myEventOption 的配置：bubbles（Boolean）：事件是否冒泡composed（Boolean）：事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部capturePhase（Boolean）：事件是否拥有捕获阶段需要强调一点：建议大家不要在组件上bind太多的监听，一方面以后管理起来会比较麻烦，另一方面首次加载如果调用过多方法会引起数据渲染的卡顿。Component官方文档： developers.weixin.qq.com/miniprogram…往期回顾：[填坑手册]小程序Canvas生成海报（一）[拆弹时刻]小程序Canvas生成海报（二）"}
{"title": "在小程序中实现 Mixins 方案 ", "author": "Rolan", "pub_time": "2019-6-20 00:20", "content": "原文来自我的博客：jrainlau.github.io/#/article?n…\r\n\r\n\r\n在原生开发小程序的过程中，发现有多个页面都使用了几乎完全一样的逻辑。由于小程序官方并没有提供 Mixins 这种代码复用机制，所以只能采用非常不优雅的复制粘贴的方式去“复用”代码。随着功能越来越复杂，靠复制粘贴来维护代码显然不科学，于是便寻思着如何在小程序里面实现 Mixins。\r\n什么是 Mixins\r\nMixins 直译过来是“混入”的意思，顾名思义就是把可复用的代码混入当前的代码里面。熟悉 VueJS 的同学应该清楚，它提供了更强大了代码复用能力，解耦了重复的模块，让系统维护更加方便优雅。\r\n先看看在 VueJS 中是怎么使用 Mixins 的。\r\n// define a mixin object\r\nvar myMixin = {\r\n  created: function () {\r\n    this.hello()\r\n  },\r\n  methods: {\r\n    hello: function () {\r\n      console.log('hello from mixin!')\r\n    }\r\n  }\r\n}\r\n\r\n// define a component that uses this mixin\r\nvar Component = Vue.extend({\r\n  mixins: [myMixin]\r\n})\r\n\r\nvar component = new Component() // => \"hello from mixin!\"\r\n复制代码在上述的代码中，首先定义了一个名为 myMixin 的对象，里面定义了一些生命周期函数和方法。接着在一个新建的组件里面直接通过 mixins: [myMixin] 的方式注入，此时新建的组件便获得了来自 myMixin 的方法了。\r\n明白了什么是 Mixins 以后，便可开始着手在小程序里面实现了。\r\nMixins 的机制\r\nMixins 也有一些小小的细节需要注意的，就是关于生命周期事件的执行顺序。在上一节的例子中，我们在 myMixin 里定义了一个 created() 方法，这是 VueJS 里面的一个生命周期事件。如果我们在新建组件 Component 里面也定义一个 created() 方法，那么执行结果会是如何呢？\r\nvar Component = Vue.extend({\r\n  mixins: [myMixin],\r\n  created: function () {\r\n    console.log('hello from Component!')\r\n  }\r\n})\r\n\r\nvar component = new Component()\r\n\r\n// =>\r\n// Hello from mixin!\r\n// Hello from Component!\r\n复制代码可以看运行结果是先输出了来自 Mixin 的 log，再输出来自组件的 log。\r\n除了生命周期函数以外，再看看对象属性的混入结果：\r\n// define a mixin object\r\nconst myMixin = {\r\n  data () {\r\n    return {\r\n      mixinData: 'data from mixin'\r\n    }\r\n  }\r\n}\r\n\r\n// define a component that uses this mixin\r\nvar Component = Vue.extend({\r\n  mixins: [myMixin],\r\n  data () {\r\n    return {\r\n      componentData: 'data from component'\r\n    }\r\n  },\r\n  mounted () {\r\n    console.log(this.$data)\r\n  }\r\n})\r\n\r\nvar component = new Component()\r\n复制代码\r\n在 VueJS 中，会把来自 Mixins 和组件的对象属性当中的内容（如 data, methods等）混合，以确保两边的数据都同时存在。\r\n经过上述的验证，我们可以得到 VueJS 中关于 Mixins 运行机制的结论：\r\n\r\n生命周期属性，会优先执行来自 Mixins 当中的，后执行来自组件当中的。\r\n对象类型属性，来自 Mixins 和来自组件中的会共存。\r\n\r\n但是在小程序中，这套机制会和 VueJS 的有一点区别。在小程序中，自定义的方法是直接定义在 Page 的属性当中的，既不属于生命周期类型属性，也不属于对象类型属性。为了不引入奇怪的问题，我们为小程序的 Mixins 运行机制多加一条：\r\n\r\n小程序中的自定义方法，优先级为 Page > Mixins，即 Page 中的自定义方法会覆盖 Mixins 当中的。\r\n\r\n代码实现\r\n在小程序中，每个页面都由 Page(options) 函数定义，而 Mixins 则作用于这个函数当中的 options 对象。因此我们实现 Mixins 的思路就有了——劫持并改写 Page 函数，最后再重新把它释放出来。\r\n新建一个 mixins.js 文件：\r\n// 保存原生的 Page 函数\r\nconst originPage = Page\r\n\r\nPage = (options) => {\r\n  const mixins = options.mixins\r\n  // mixins 必须为数组\r\n  if (Array.isArray(mixins)) {\r\n    delete options.mixins\r\n    // mixins 注入并执行相应逻辑\r\n    merge(mixins, options)\r\n  }\r\n  // 释放原生 Page 函数\r\n  originPage(options)\r\n}\r\n复制代码原理很简单，关键的地方在于 merge() 函数。merge 函数即为小程序 Mixins 运行机制的具体实现，完全按照上一节总结的三条结论来进行。\r\n// 定义小程序内置的属性/方法\r\nconst originProperties = ['data', 'properties', 'options']\r\nconst originMethods = ['onLoad', 'onReady', 'onShow', 'onHide', 'onUnload', 'onPullDownRefresh', 'onReachBottom', 'onShareAppMessage', 'onPageScroll', 'onTabItemTap']\r\n\r\nfunction merge (mixins, options) {\r\n  mixins.forEach((mixin) => {\r\n    if (Object.prototype.toString.call(mixin) !== '[object Object]') {\r\n      throw new Error('mixin 类型必须为对象！')\r\n    }\r\n    // 遍历 mixin 里面的所有属性\r\n    for (let [key, value] of Object.entries(mixin)) {\r\n      if (originProperties.includes(key)) {\r\n        // 内置对象属性混入\r\n        options[key] = { ...value, ...options[key] }\r\n      } else if (originMethods.includes(key)) {\r\n        // 内置方法属性混入，优先执行混入的部分\r\n        const originFunc = options[key]\r\n        options[key] = function (...args) {\r\n          value.call(this, ...args)\r\n          return originFunc && originFunc.call(this, ...args)\r\n        }\r\n      } else {\r\n        // 自定义方法混入\r\n        options = { ...mixin, ...options }\r\n      }\r\n    }\r\n  })\r\n}\r\n复制代码Mixins 使用\r\n\r\n在小程序的 app.js 里引入 mixins.js\r\n\r\nrequire('./mixins.js')\r\n复制代码\r\n撰写一个 myMixin.js\r\n\r\nmodule.exports = {\r\n  data: { someData: 'myMixin' },\r\n  onShow () { console.log('Log from mixin!') }\r\n}\r\n复制代码\r\n在  page/index/index.js 中使用\r\n\r\nPage({\r\n  mixins: [require('../../myMixin.js')]\r\n})\r\n复制代码\r\n大功告成！此时小程序已经具备 Mixins 的能力，对于代码解耦与复用来说将会更加方便。作者：Jrain链接：https://juejin.im/post/5d0a07eb6fb9a07eba2c4142来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "mpVue + 云开发微信小程序之旅 ", "author": "Rolan", "pub_time": "2019-6-20 00:46", "content": "本文是使用mpVue + 小程序云开发构建的mini型的微信小程序，小程序加载过程会稍微比较慢，如存在问题望各路大神指教。 小程序分为三个部分：1. 首页主要是展示发布的内容；2. 写日记是提供添加数据的项；3. 详情页是浏览内容正文的具体详情喜欢的小伙伴动动您的小手给个小星星哦，谢谢！！ 小程序源码小程序二维码首页先看首页效果图，顶部是一个轮播 此轮播是获取预览人数排名第一个的发布的图片 ，中间部分是内容展示区 全部，最新，我的 。直接上代码吧// index.vue\r\nmethods： {\r\n    // 跳转详情\r\n    navigateTo (id) {\r\n      wx.navigateTo({\r\n        url: '../diaryDetail/main?id=' + id\r\n      })\r\n    },\r\n    // 切换 全部， 最新， 我的\r\n    switechNav (index) {\r\n      this.isActive = index\r\n      if (index === 0) {\r\n        this.getDiaryList()\r\n      }\r\n      if (index === 1) {\r\n        this.getNewList()\r\n      }\r\n      if (index === 2) {\r\n        this.getOpenId()\r\n      }\r\n    },\r\n    // 最近发布的，按时间排序前10条\r\n    getNewList () {\r\n      const that = this\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      wx.cloud.callFunction({\r\n        name: 'diaryList'\r\n      }).then(res => {\r\n        let infoList = res.result.data.reverse()\r\n        setTimeout(function () {\r\n          wx.hideLoading()\r\n        }, 2000)\r\n        that.diaryList = infoList.slice(0, 10)\r\n      })\r\n    },\r\n    // 获取自己发布的\r\n    getMyList () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const diary = db.collection('diary')\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      diary.where({\r\n        _openid: that.openId\r\n      }).get({\r\n        success: function (res) {\r\n          setTimeout(function () {\r\n            wx.hideLoading()\r\n          }, 2000)\r\n          if (res.data.length === 0) {\r\n            toast('您暂时没有发布文章日记', 'none')\r\n          }\r\n          that.diaryList = res.data.reverse()\r\n        }\r\n      })\r\n    },\r\n    // 通过云函数获取日记的list\r\n    getDiaryList () {\r\n      const that = this\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      wx.cloud.callFunction({\r\n        name: 'diaryList'\r\n      }).then(res => {\r\n        setTimeout(function () {\r\n          wx.hideLoading()\r\n        }, 2000)\r\n        let infoList = res.result.data\r\n        that.diaryList = infoList.sort(function (a, b) {\r\n          return b.preview - a.preview\r\n        })\r\n        that.imgUrls = that.diaryList[0].imagesList\r\n      })\r\n    }，\r\n    // 获取openid\r\n    getOpenId () {\r\n      const that = this\r\n      wx.cloud.callFunction({\r\n        name: 'user'\r\n      }).then(res => {\r\n        that.openId = res.result.OPENID\r\n        that.getMyList()\r\n      })\r\n    }\r\n}\r\n复制代码工具函数工具函数在 utils/index.js，做时间格式化和弹出提示function addZero (n) {\r\n  return n > 10 ? n : '0' + n\r\n}\r\n// toast 弹出提示\r\nexport function toast (title = '成功', icon = 'success', duration = 2000) {\r\n  wx.showToast({\r\n    title: title,\r\n    icon: icon,\r\n    duration: duration\r\n  })\r\n}\r\n// 时间格式化\r\nexport function getNowFormatDate () {\r\n  const now = new Date()\r\n  const year = now.getFullYear()\r\n  const month = addZero(now.getMonth() + 1)\r\n  const day = addZero(now.getDate())\r\n  const hh = addZero(now.getHours())\r\n  const mm = addZero(now.getMinutes())\r\n  const ss = addZero(now.getSeconds())\r\n  const timer = year + '-' + month + '-' + day + ' ' + hh + ':' + mm + ':' + ss\r\n  return timer\r\n}\r\n\r\nexport default {\r\n  toast,\r\n  getNowFormatDate\r\n}\r\n复制代码详情页展示内容详情，顶部轮播是作者上传的图片，可以点击查看原图，有为日记点赞，以及评论功能// diaryDetail.vue\r\nmethods: {\r\n    // id 是文章id通过首页跳转传过来 page页面可以用 this.$root.$mp.query.id 获取\r\n    getDiaryDetail (id) {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const diary = db.collection('diary')\r\n      diary.doc(id).get().then(res => {\r\n        that.detailInfo = res.data\r\n        that.detailImgs = res.data.imagesList\r\n      })\r\n    },\r\n  // 点赞\r\n    dianZan () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const _id = this.$root.$mp.query.id\r\n      const dianzan = db.collection('dianzan')\r\n      dianzan.where({\r\n        textId: _id,\r\n        _openid: that.openId\r\n      }).get({\r\n        success: function (res) {\r\n          if (res.data.length === 0) {\r\n            that.addDZ()\r\n            return false\r\n          }\r\n          toast('不能重复点赞哦！', 'none')\r\n        }\r\n      })\r\n    },\r\n    // 添加点赞人，以便可以判断是否重复点赞\r\n    addDZ () {\r\n      const that = this\r\n      const _id = this.$root.$mp.query.id\r\n      const db = wx.cloud.database()\r\n      const dianzan = db.collection('dianzan')\r\n      dianzan.add({\r\n        data: {\r\n          textId: _id, // 文字id\r\n          isZan: 1 // 1 为点赞\r\n        }\r\n      }).then(res => {\r\n        that.isAnimate = true\r\n        that.changeDZCount(_id)\r\n      })\r\n    },\r\n    // 调用点赞云函数，自增点赞数\r\n    changeDZCount (id) {\r\n      const that = this\r\n      wx.cloud.callFunction({\r\n        name: 'dianzan',\r\n        data: {\r\n          _id: id\r\n        }\r\n      }).then(res => {\r\n        toast('谢谢您的认可哦！', 'none')\r\n        that.getDiaryDetail(id)\r\n      })\r\n    },\r\n    // 判断阅读的人是否对这篇文章已经点过赞，如果点过赞进入页面心直接变红\r\n    getZan () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const _id = this.$root.$mp.query.id\r\n      const dianzan = db.collection('dianzan')\r\n      dianzan.where({\r\n        textId: _id,\r\n        _openid: that.openId\r\n      }).get({\r\n        success: function (res) {\r\n          if (res.data.length) {\r\n            that.isAnimate = true\r\n          }\r\n        }\r\n      })\r\n    },\r\n    // 获取评论\r\n    getComment (id) {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const comment = db.collection('comment')\r\n      comment.where({\r\n        textId: id\r\n      }).get({\r\n        success: function (res) {\r\n          that.commentList = res.data.reverse()\r\n        }\r\n      })\r\n    },\r\n    // 添加评论\r\n    addComment () {\r\n      if (this.content === '') {\r\n        toast('请输入评论内容', 'none')\r\n        return false\r\n      }\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const comment = db.collection('comment')\r\n      comment.add({\r\n        data: {\r\n          textId: this.$root.$mp.query.id, // 正文id\r\n          user: that.userInfo, // 用户信息\r\n          content: that.content, // 评论内容\r\n          time: getNowFormatDate() // 评论时间\r\n        }\r\n      }).then(res => {\r\n        that.contentCount = 0\r\n        that.getComment(this.$root.$mp.query.id)\r\n      })\r\n    },\r\n    // 判断用户是否发表过评论\r\n    getIsComment () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const comment = db.collection('comment')\r\n      comment.where({\r\n        _openid: that.openId,\r\n        textId: this.$root.$mp.query.id\r\n      }).get().then(res => {\r\n        if (res.data.length === 0) {\r\n          that.addComment()\r\n          toast('发表成功')\r\n          that.content = ''\r\n          return false\r\n        }\r\n        toast('不能重复发表评论哦！', 'none')\r\n      })\r\n    },\r\n    // 绑定评论字数\r\n    handleContentInput (e) {\r\n      this.contentCount = e.target.value.length\r\n    },\r\n    // 发表评论\r\n    onGotUserInfo (e) {\r\n      this.userInfo = e.target.userInfo\r\n      this.getIsComment()\r\n    },\r\n    // 轮播图 全屏预览图片 调用微信API wx.previewImage\r\n    handleImagePreview (e) {\r\n      let idx = e.target.dataset.idx\r\n      let images = this.detailImgs\r\n      wx.previewImage({\r\n        current: images[idx],\r\n        urls: images\r\n      })\r\n    }\r\n}\r\n复制代码写日记将 wx.chooseImage() 生成的临时图片保存到微信云存储，主要掉用 wx.cloud.uploadFile()方法// write.vue\r\nmethods: {\r\n    // 上传图片，并将临时图片保存到云存储中\r\n    chooseImage () {\r\n      const that = this\r\n      wx.chooseImage({\r\n        count: 9,\r\n        sizeType: ['original', 'compressed'],\r\n        sourceType: ['album', 'camera'],\r\n        success: function (res) {\r\n          // 将选择的图片上传到云存储\r\n          for (let i = 0; i < res.tempFilePaths.length; i++) {\r\n            const filePath = res.tempFilePaths[i]\r\n            const name = Math.random() * 1000000\r\n            const cloudPath = name + filePath.match(/\\.[^.]+?$/)[0]\r\n            wx.cloud.uploadFile({\r\n              cloudPath,\r\n              filePath,\r\n              success: res => {\r\n                let images = that.imagesList.concat(res.fileID)\r\n                that.imagesList = images.length <= 9 ? images : images.slice(0, 9)\r\n              }\r\n            })\r\n          }\r\n        }\r\n      })\r\n    },\r\n    // 限制标题字数\r\n    handleTitleInput (e) {\r\n      this.titleCount = e.target.value.length\r\n    },\r\n    // 限制标题字数\r\n    handleContentInput (e) {\r\n      this.contentCount = e.target.value.length\r\n    },\r\n    // 全屏预览图片\r\n    handleImagePreview (e) {\r\n      console.log(e)\r\n      let idx = e.target.dataset.idx\r\n      let images = this.imagesList\r\n      wx.previewImage({\r\n        current: images[idx], // 当前预览的图片索引\r\n        urls: images // 所有要预览的图片\r\n      })\r\n    },\r\n    // 移除不想要的图\r\n    removeImage (e) {\r\n      const that = this\r\n      const idx = e.target.dataset.idx // 当前需要移除的图片索引\r\n      wx.showModal({\r\n        title: '提示',\r\n        content: '您确定删除这张照片吗？',\r\n        success (res) {\r\n          if (res.confirm) {\r\n            that.imagesList.splice(idx, 1)\r\n            toast('删除成功')\r\n          } else if (res.cancel) {\r\n            console.log('用户点击取消')\r\n          }\r\n        }\r\n      })\r\n    },\r\n    // 发布文章\r\n    onGotUserInfo (e) {\r\n      if (this.title === '') {\r\n        toast('请输入文章标题', 'none')\r\n        return false\r\n      }\r\n      if (this.content === '') {\r\n        toast('请输入文章内容', 'none')\r\n        return false\r\n      }\r\n      if (this.imagesList.length === 0) {\r\n        toast('您还没上传图片', 'none')\r\n        return false\r\n      }\r\n      this.userInfo = e.target.userInfo\r\n      this.getOpenId()\r\n    },\r\n    // 往数据库里写数据\r\n    sendMessage () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const diary = db.collection('diary')\r\n      diary.add({\r\n        data: {\r\n          title: that.title, // 正文标题\r\n          content: that.content, // 正文内容\r\n          imagesList: that.imagesList, // 上传图片 list\r\n          avatarUrl: that.userInfo.avatarUrl, // 头像\r\n          nickname: that.userInfo.nickName, // 名字\r\n          preview: 0, // 预览数\r\n          fabulous: 0, // 点赞数\r\n          creatTime: getNowFormatDate()\r\n        }\r\n      }).then(res => {\r\n        toast('发布成功')\r\n        that.title = that.content = ''\r\n        that.titleCount = that.contentCount = 0\r\n        that.imagesList = []\r\n      })\r\n    },\r\n}\r\n复制代码末尾在使用云开发中需要将如下代码放到根目录的 src/main.js中wx.cloud.init({\r\n  env: '云开发环境ID'\r\n})\r\n复制代码app.json 文件下添加 \"cloud\": true 告诉小程序使用云开发, project.config.json文件下添加 \"cloudfunctionRoot\": \"static/functions/\", 指定存放云函数的目录"}
{"title": "玩玩微信小程序（多图预警） ", "author": "Rolan", "pub_time": "2019-6-21 00:21", "content": "趁着最近下班比较早，还是有时间看下其他知识点。于是，自己屁颠屁颠的玩了下微信小程序。环境安装我使用的是 mac 电脑来开发，那我简单说下我自己的准备工作吧～首先，你需要一个良好的编辑器工具，我这里下载了 sublime、vscode和微信开发者工具 。我选择使用 微信开发者工具 进行开发，因为对开发者友好。有说vscode比较友好的，需要配置些东西，这就要百度一下了。然后，如果你的小程序要上线或需要使用里面比较完整的功能，你需要注册一个微信小程序，获取 appId 。我这里是学习而已，所以只是用微信提供的测试 appId ，这个测试 appId 在使用 微信开发者工具 新建项目的时候有得选择。嗯～就是这么简单，惊喜不～意外不:hushed:项目结构当你使用 微信开发者工具 新建项目的时候，它会自动帮你新建一个规范的项目目录结构。当然，我们也可以从零开始进行搭建啦。我下面简单罗列下我项目中的结构(截止2019年06月21日)：- app.js\r\n- app.json\r\n- assets\r\n  - tabbar\r\n\t- home_active.png\r\n\t- home.png\r\n\t- profile_active.png\r\n\t- profile.png\r\n- pages\r\n  - home\r\n\t- home.js\r\n\t- home.json\r\n\t- home.wxml\r\n\t- home.wxss\r\n  - profile\r\n\t- profile.js\r\n\t- profile.json\r\n\t- profile.wxml\r\n\t- profile.wxss\r\n- page.wxss\r\n- project.config.json\r\n- README.md\r\n复制代码也许你已经注意到了文件后缀名 js, json, wxml, wxss 。那么它们具体是干什么用的呢？js后缀名的文件是你写 javascript 的地方了，项目的一些逻辑代码。json后缀名的文件是你写页面的配置的地方， app.json 是应用的整体配置， home.json 是 home 页面的配置， profile.json 是 profile 页面的配置。wxml后缀名的文件是你写页面骨架的地方，类似我们的 html 。wxss后缀名的文件是你写页面样式的地方，类似我们的 css 。练手项目在看了文档，百度了些资料，就开始想一个练手的项目 -- github信息展示 。首先，我们搭建好项目的目录，之后就是根据文档啥的进行我们的项目构思的实现了。具体的过程我这里就不赘述了，毕竟在文章后面会配上项目代码的github地址啦:dog:～我们来看下效果吧："}
{"title": "基于Proxy的小程序状态管理 ", "author": "Rolan", "pub_time": "2019-6-21 00:34", "content": "作者：wwayne原文： 基于Proxy的小程序状态管理Fundebug经授权转载，版权归原作者所有。微信小程序的市场在进一步的扩大，而背后的技术社区仍在摸索着最好的实践方案。我在帮助Nike，沃尔玛以及一些创业公司开发小程序后，依旧认为使用小程序原生框架是一个更高效，稳定的选择，而使用原生框架唯独缺少一个好的状态管理库，如果不引入状态管理则会让我们在模块化，项目结构以及单元测试上都有些捉襟见肘。目前相对比较稳健的做法是针对redux或者mobx做一个adaptor应用到小程序中，但这样需要自己想办法打包引入外部库，还要想怎么去写这个adaptor，总显得有些麻烦。于是我迸发出一个想法去写一个专用于小程序的状态管理库，它使用起来足够简单并且可以通过小程序自己的npm机制安装。目前我已经用这个开源库开发了两个电商小程序，在提高我开发效率的同时亦保证了程序的性能，所以接下来我想谈谈这背后的理念以启发更多开发者尝试新的解决方案。基于Proxy的状态管理实现Proxy在小程序中已经得到了足够好的支持，目前并没有发现在任何iPhone或者Android上不能使用Proxy的情况。而基于Proxy的状态管理其实也就是订阅监听的模式，一方面监听数据的变化，另一方面将这些变化传达给订阅的小程序页面。举一个比较常见的例子，当一个用户从自己的主页进入用户编辑页面，然后更改了自己的用户名点击保存后，用户主页和用户编辑页上的用户名这时候都应该被更新。这背后的程序逻辑则是：更新这个行为将触发Proxy去通知状态管理库，然后状态管理库负责检查此时还在页面栈中的所有页面，更新订阅了用户名这个数据的页面，如下图：Part1: 监听数据变化监听数据变化其实就是监听各个Store的属性变化，实现上就是在各个Store前面加了一层Proxy，用更直观的图片来表示就是这样：当一个Store被观察以后，它的属性就都变成了Proxy实例，当这个属性值是Object或者Array的时候，它内部的值也会被包装成Proxy实例，这样无论多深层的数据变动都能被监听到。而在Proxy的后面，Store的属性其实是被另一套数据(紫色部分)所维护，这套数据不负责监听，它就是纯数据，针对属性的任何变动最后都会应用到这套数据上来，它的作用是维护和返回最新的数据。实现细节： https://github.com/wwayne/min…Part2: 页面数据绑定因为小程序每个页面的js都是向Page中传递一个对象，这就让我们有机会包装这个对象，从而实现：进入页面后，将页面保存在页面栈中将来自状态管理库的数据映射到这个页面的data上来页面退出时，将页面从页面栈中移除实现细节： https://github.com/wwayne/min…Part3： 页面订阅更新当数据被监听到变化后，我们需要依次做两件事，先是找到所有存储在页面栈里的页面，然后根据各个页面订阅的数据来检查变化，如果有变化就通知这些页面，从而让它们去触发setData更新页面。实现细节： https://github.com/wwayne/min…使用状态管理的例子有了状态管理库，现在我们就来实现一开始举例的更新用户信息的操作，我们的文件路径如下：stores/\r\n  user.js\r\npages/\r\n  userEdit/\r\n     index.js\r\n     index.wxml\r\n1. 首先我们创建一个Store保存用户的信息，并且监听它的变化：// stores/user.js\r\nimport { observe } from 'minii'\r\n\r\nClass UserStore {\r\n  constructor () {\r\n     this.name = 'bob'\r\n  }\r\n\r\n  changeName (name) {\r\n     this.name = name\r\n  }\r\n}\r\n\r\nexport default observe(new UserStore(), 'user')\r\n2. 接着在我们的小程序页面订阅Store的信息// pages/userEdit/index.js\r\nimport { mapToData } from 'minii'\r\nimport userStore from '../../stores/user'\r\n\r\nconst connect = mapToData(state => (({\r\n  myName: state.user.name\r\n}))\r\nPage(connect({\r\n  updateNameToJames () {\r\n    userStore. changeName('james')\r\n  }\r\n}))\r\n3. 完成，现在可以在页面中使用和更新数据了// pages/userEdit/index.wxml\r\n<text>{{ myName }}</text>\r\n<button bindtap=\"updateNameToJames\">update name to James</button>\r\n最后小程序因为有体积的限制，所以我希望在代码量上也尽量做到轻量和便捷，所以目前这个状态管理库并没有太多很复杂的功能，在小程序打包后所占用的体积也不到1kb，颇有点够用就好的意思。我也已经用它开发了两款小程序，在经历了一段时间的用户使用后，我也更有信心说这个方案在小程序中是可行的。如果你有任何想法和建议，都欢迎告诉我。项目Github: https://github.com/wwayne/minii关于作者Hi, 我是wwayne，是一名居住在上海的独立软件工程师，我正在开发我的新产品 talk-to-kim , 你可以在 Github 或者专栏 一个人写代码 找到我"}
{"title": "小程序框架原理综合分析和 fard 的新思路 ", "author": "Rolan", "pub_time": "2019-6-24 00:07", "content": "halo，大家好，我是 132 ，好久不贱~今天给大家带来的是一个 fre 转小程序的新框架，叫 fard，它使用了非常精彩的思路，将 fre 代码跑到小程序环境里背景当下国内前端环境中，几乎每一个框架作者最终都会研究小程序，如 nerv 和 taro，anu 和 nanachi加上前阵子某人发微博说出 “hooks 无法用于别处，想用就得重新实现” 这种膝盖言论我急迫的想要给 fre 一个归宿，寻找适用于 fre 的小程序方案现有方案在做 fard 之前，我看了几乎所有的小程序框架，以下：编译型封装型tarowepynanachimpxmpvueuniappchameleon以上列举的只是常见的，还有很多小众的没有写出，小程序框架比小程序还多::>_<::编译型对于编译型框架，基本上就是 AST 转译，写 react/vue 的语法，编译出小程序的语法这样做的好处是理论上无所不能，啥都能转，甚至使用 parcel 的策略能让编译速度很快但是致命缺陷是，全程写的不是真的 react，react 内部的遍历过程根本没走，而且还需要制定足够严格的语法约定我认为，这个方向是走投无路的方向封装型封装型框架，基本就是对小程序的 API 进行封装，使其长得像 vue优点是能够最大程度的接近原生，缺点是没有足够的抽象层，无法跨端跨端了解完两种类型的框架，我们来探讨一下“跨端”跨端一直是很多人乐此不疲的事情，跨端的关键点在于寻找一个【抽象中间层】比如 taro 等使用 AST 作为抽象中间层flutter 使用各个端都支持的渲染引擎作为抽象中间层RN 自己搞了个 bridge，把桥作为抽象中间层weex 利用 v8 搞了个 runtime 作为抽象中间层(以上仅仅是举例，不要深究他们的原理)所以，fard 只需要寻找一个中间层，就完事了Fard 原理好吧，通篇，就这段是重点 ::>_<::首先，fard 是 fre 转小程序的框架，fre 是 react like 框架，它包含了整个 reconcilerreconciler 全程都是 js 的遍历行为，能够跑在任何 js 环境中，小程序也不例外所以最终 fard 的方案，就和 RN 类似，在小程序端跑 fre reconciler 过程，跑完再通过某个【桥】反馈给小程序视图好吧，上图如图，首先，在小程序里，跑 fre reconciler 的所有逻辑，hooks 就位于这个阶段，所以 hooks 所有逻辑，都是在 fre 中跑完的跑完后就好说了，我们拿到了一个 vdom (也可以说 fiber，但是我们只需要子集 vdom )拿到这个 vdom 后，就去 setData，附加给 Page好的，到这里，可以说全程 js 逻辑，该拿到的都拿到了，就差怎么反馈给视图了小程序自身也是 vdom 机制的，如果说它默认提供 vdom 的接口的话，我们直接将 vdom 附加过去即可但是并没有，小程序开放的唯一的修改视图的方法就是 template所以我们需要根据 vdom 改造 template，使其成为桥梁这个也非常简单，比如 vdom 长这个样子：let vdom = {\r\n    name:'@2',\r\n    type:'view',\r\n    children:[\r\n        {\r\n            name:'@1',\r\n            type:'text'\r\n        }\r\n    ]\r\n}\r\n复制代码我们完全可以通过 template 模拟出来<template is=\"@2\">\r\n    <view>\r\n        <block wx:for=\"{{props.children}}\" wx:key=\"\">\r\n            <template is=\"{{item.name}}\"></template>\r\n      </block>\r\n    </view>\r\n</template>\r\n\r\n<template is=\"@1\">\r\n    <text></text>\r\n</template>\r\n\r\n复制代码我们可以通过 template 模拟出整个 vdom，很好，bridge 就这么搞定了其实到这里，fard 就搞定了剩下的就是，增加更多的 case，封装更多的通用 API，提高性能了综合分析我们看到 fard 是类似 RN 的原理，我们高度抽象 fre 的 reconciler 层和小程序的 template bridge，使得整个设计非常的简单却精彩而且它能够完美的支持 jsx 和 hooks API，不存在任何约定任何限制任何规范毕竟，这才是 jsx 真正的意义同样的，hooks API 自出现以来，关于它内部的黑魔法也一直令人津津乐道，我用实际行动证明，hooks API 完全可以用到任何端，也包括 webgl前提是要有设计精巧的抽象中间层"}
{"title": "小程序生成海报代码分享 ", "author": "Rolan", "pub_time": "2019-6-24 00:26", "content": "今天下午花了一下午时间把之前项目添加了对海报生成的支持,本代码已提交到微信，已通过审核，已发布，已经过本人验收，以下功能可用需要的同学可以移步下面链接https://gitee.com/jgl1210/eas...本代码实现功能1、海报上添加图片2、海报上添加文字3、海报下载4、海报保存到本地"}
{"title": "微信小程序自定义组件boundingClientRect获取到的rect值为null ", "author": "Rolan", "pub_time": "2019-6-24 00:36", "content": "解决办法：在自定义组件内获取必须用SelectorQuery.in()Component({\r\n  lifetimes: {\r\n    ready() {\r\n      const query = wx.createSelectorQuery().in(this)\r\n      const num = Math.ceil(this.data.picList.length / LINE_LENGTH)\r\n      query.select('.tab-content-item').boundingClientRect((rect) => {\r\n        this.setData({\r\n          swiperHeight: rect.height * num + 'rpx'\r\n        })\r\n      }).exec()\r\n    }\r\n  },\r\n})const query = wx.createSelectorQuery().in(this)这一句是最重要的，要用.in(this)，this传入的是自定义组件的实例。否则获取到的rect值为null"}
{"title": "利用watch在小程序中实现全局状态共享 ", "author": "Rolan", "pub_time": "2019-6-4 00:43", "content": "在之前开发微信小程序的时候，获取用户信息、openid还有地理位置这些信息的时候，都是采用 Promise 的方式异步获取，但是这样的话在页面和App.js中都获取就可能造成 请求重复 的问题。比如为了在每个页面都能获取到这些共享信息，都会选择在App.js中进行获取，然后在页面级进行获取，这两次获取的时间间隔较小时就可能导致前一个请求还未获取到数据，后一个请求就会再次进行获取，这样就产生了两次请求。还有一个问题就是书写麻烦(虽然也能通过async await简化)，比如onLoad() {\r\n    app.getUserInfo()\r\n    .then(userInfo => {\r\n        \r\n    }).catch(err => { /* 错误处理 */ });\r\n    \r\n    // 如果同时需要userInfo和openid，可能就是如下形式：\r\n    Promise.all([app.getUserInfo(), app.getOpenid()])\r\n    .then(res => {\r\n        \r\n    }).catch(err => { /* 错误处理 */ });\r\n}\r\n复制代码正好周末的时候突然想到了vue的watch语法，利用一些相关的知识，就可以解决这个麻烦的问题了。解决思路双向绑定vue的双向绑定原理，3.0将会采用Proxy监听数据变化，不过考虑到小程序这边的Proxy兼容性我不知道，所以采用了2.0的Object.defineProperty来监听数据的变化。主要还是拦截设置的操作，在进行赋值时，将新旧值通知至监听者。观察者模式在页面级的onLoad 监听 app.globalData 各个键名的事件 ，而在app.js的onLoad中则使用Object.defineProperty重新定义app.globalData，这样一旦app.globalData相应的键值发生了变化，就会通知监听的页面该值发生了变化。模块化的引用观察者模式导出的是一个对象（类实例），而不是一个类，所以在导入的时候这个对象是共享的，就可以通过这个对象将app.js和其他页面联系起来。至于模块加载的实质，ES6模块加载的机制，与CommonJS模块完全不同。感兴趣的可以去看看这个。封装Page小程序的Page函数本身是不支持watch，但是我们可以自定义一个函数，进行参数合并就可以了。在页面onLoad时先遍历watch属性，对app.globalData进行监听，可以参考vue的watch用法。页面onUnload时就会进行销毁，此时也应该取消监听，这些我都封装过了，不用手动处理了。有了这些思路，用不了多久，一个雏形就出来了，经过手动测试，感觉没什么问题，我就发布到npm了，大家感兴趣的可以安装体验一下。安装npm i wx-watch -S --production\r\n复制代码使用// app.js\r\nvar { watchData, } = require('/miniprogram_npm/wx-watch/index.js');\r\n\r\nApp({\r\n  onLaunch() {\r\n    this.watchData(); /* 监听this.globalData的变化，并触发事件，其他页面监听的值必须在globalData中预先定义，否则无法监听 */\r\n  },\r\n  watchData,\r\n  globalData: {\r\n    userInfo: null,\r\n  }\r\n});\r\n\r\n// 其他需要监听globalData的页面.js\r\nvar { getPage } = require('../../miniprogram_npm/wx-watch/index.js');\r\nconst app = getApp();\r\n\r\n/**\r\n * getPage(页面参数，app) app必传，因为封装的时候访问不到，就只能传参了\r\n*/\r\ngetPage({\r\n  watch: {\r\n    userInfo(userInfo, oldUserInfo) {\r\n      console.log(`来自app.glodalData的userInfo`);\r\n    }\r\n  },\r\n  // 其他参数\r\n}, app)\r\n复制代码github: github.com/ma125120/wx…要是用的还行，欢迎star。要是有问题，欢迎提交issue。"}
{"title": "小程序如何做全局重新加载 ", "author": "Rolan", "pub_time": "2019-6-4 00:44", "content": "背景：随着业务的增加，我们服务器需要计算大量的用户数据，导致用户跟客服反应页面不能正常展示。反馈给开发后，我们一看，是服务器异常的错误。So，产品想看下我们到底有多少用户页面不能正常展示？方案：后端人员直接在阿里云后台去查哪些接口异常 前端做一个服务器报错页，这样产品在小程序后台能看到这个页面的PV,UV技术方案因为业务庞大，所以我们不可能区在每个页面加上重新加载的逻辑。所以初步考虑使用全局重新加载。需要解决的问题都有哪些？1、首先我们要有网络请求失败的全局控制权（要不然就需要在每个页面处理失败的情况） 2、需要定义好网络失败后是如何跳转到重载页（R）的（用wx.redirectTo，wx.reLaunch还是其他） 3、点击错误页的“重新加载”，如何返回或跳转到出错页(E)（用wx.redirectTo，wx.reLaunch还是其他） 4、跳转到出错页后，如何重新加载数据（把所有请求都放在Page.onShow()里面?） 5、那如果从出错页的上个界面(P)传到出错页（E）options，那重载页（R）又将如何处理？ 6、点击重新加载跟返回，我们希望效果效果一样，又该如何操作？实践的方式如下1、第一个问题： 比较好解决，我们基于wx.request已经封装了为fetch（如果还在用wx.request的项目可以考虑封装下，好处多多）。基于fetch我们可以用res.statusCode来判断服务器是否出错。 2、第二个问题： 暂且先不说具体的跳转方式是怎样的，就跳转的url这个怎么定义也需要我们来讨论下。为什么这么说，因为我们的架构涉及到了分包。分包加载意味着我们的代码不仅仅是在pages下面，还放在了package下。 基于此，我们在跳转的时候，url能直接写成'../serverError/serverError'吗？在主包下面可以正常跳转，但是在分包下，路径是'package/serverError/serverError'，这样跳肯定不行。url应该是根目录下的路径，所以'/pages/serverError/serverError'。 路径确认后，我们可以跳转了。如果是wx.redirectTo（关闭当前页面，跳转到应用内的某个页面），想象下关闭E跳转到R，点击重新加载，再关闭R跳转到E，这么跳转路径复杂，用户体验不好，并且options的参数需要逐级传递。wx.reLaunch类似。我们用所以我们选择wx.navigateTo。 3、第三个问题： 综合问题二的解释，跳回到E，我们用wx.navigateBack。 4、第四个问题： 如果从R用wx.navigateBack回到E的话，肯定会触发E.onShow()方法。但是有些请求我们除了写在Page.onShow()里，还有些是写在Page.onLoad()里的，所以我们必须想办法调起E.onLoad()。 大家对于getCurrentPages()这个方法肯定不陌生，官方定义是来获取当前页面栈，我们一般用它来获取当前页面路径。其实在这个过程中，我们是能拿到当前页面的实例的，并且实例里面有route（页面路径）options（页面传递参数）data(页面初始参数)以及各种function()等等。 利用previousPageClass()我们可以拿到E的实例，也就可以拿到E.options，当然我们也可以调E.onLoad()。 util.js// 获取当前路径function currentPagePath() {  let pageData = getCurrentPages()  if (pageData.length >= 1) {    let len = pageData.length - 1    let data = pageData[len]    return data.route  } else {    return ''  }}// 获取上个界面的实例function previousPageClass() {  let pageData = getCurrentPages()  if (pageData.length >= 2) {    let len = pageData.length - 2    let preClass = pageData[len]    return preClass  } else {    return ''  }}module.exports = {  currentPagePath,  previousPageClass}第五个问题： 基于问题的四的方案，我们可以调E.onLoad(E.options)来将我们的参数回传回去。 第六个问题： 点击返回，相当于页面卸载，也就是执行了R.onUnload(),这个时候我们只需要执行E.onLoad(E.options)这个方法，把options传过去，以及调用起E.onLoad()就OK了。 但是点击重新加载，我们是调的wx.navigateBack()，这个方法也会走R.onUnload()。这是时候可能有些苦恼了，我们隐藏掉返回按钮？发现官方并没有提供此方法。禁用R.onUnload()，好像也不行。因为R.onUnload()是在点击重新加载后才执行的，所以我们可以记录下用户是否点击了重新加载的行为。然后我们通过记录的行为，即便用户点击了重新加载，然后触发了R.onUnload()，我们不去执行E.onLoad(E.options)就OK了。 // pages/serverError/serverError.jsimport { previousPageClass } from '../../utils/util.js'let isClickReload = falsePage({  onLoad: function (options) {    isClickReload = false  },  onUnload: function () {    if(!isClickReload) {      this.callbackParams()    }      },  /**   * 点击事件   */  clickReload: function (e) {    isClickReload = true    wx.navigateBack()    this.callbackParams()  },  // 点击返回，参数回传  callbackParams: function () {    let preOptions = previousPageClass().options    previousPageClass().onLoad(preOptions)  }})至此所有问题，基本都已解决。 Demo代码附上，欢迎参考。"}
